<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>专业软件开发人员必须精通的事项</title>
      <link href="/2023/11/22/%E4%B8%93%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E7%B2%BE%E9%80%9A%E7%9A%84%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/11/22/%E4%B8%93%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E7%B2%BE%E9%80%9A%E7%9A%84%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>以下内容摘抄自《代码整洁之道：程序员的职业素养》</p><blockquote><p>设计模式。必须能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验。</p><p>设计原则。必须了解SOLID原则，而且要深刻理解组件设计原则。</p><p>方法。必须理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等。</p><p>实践。必须掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程。</p><p>工件。必须了解如何使用UML图、DFD图、结构图、Petri网络图、状态迁移图表、流程图和决策表。</p></blockquote><p>有空展开写写</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robert C. Martin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《代码整洁之道：程序员的职业素养》笔记</title>
      <link href="/2023/11/22/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/22/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="译者序1：享受职业素养"><a href="#译者序1：享受职业素养" class="headerlink" title="译者序1：享受职业素养"></a>译者序1：享受职业素养</h2><ul><li><p>因为我们需要招聘的不是“经历丰富”的人，而是“有职业素养”的人。你遇到的问题可能很容易也可能很难，但我看重的并不是问题的难度，而是解决问题的方式、步骤以及反思的程度。</p></li><li><p>与问题本身的难度相比，解决问题的方式、步骤以及反思的程度，才能体现出一个人的职业素养</p></li><li><p>基本技能不够熟练，当然谈不上职业素养。但是仅仅能迅速地编写代码，却不关心代码背后的意义，不能迅速判断、解决程序运行中的各种问题，不能自信满满地为自己交付的程序承担责任，同样是与职业素养绝缘的</p></li><li><p>（说“是”时）你对自己将会做某件事做了清晰的事实陈述，而且还明确说明了完成期限。那不是指别人，而是指你自己。你陈述的是自己会去执行的一项行动，而且，你不是“可能”去做，或是“可能做到”，而是“会”做到。</p></li><li><p>这两个项目之所以会搞砸，因为开发人员没有坚决抵制各种不专业的需求（比如一些无关紧要但成本巨大的需求），抵制各种不专业的行为（比如为了赶工期而降低对程序质量的要求），最终只好喝下自己酿出的苦酒。</p></li><li><p>花三分的力气去抵制无理的需求，可以节省十分甚至二十分的开发时间</p></li></ul><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Joe并不信任我们，只有对技术团队进行微观管理才能让他安心。而与此同时，出于某种原因，他确实能够信任法务团队，也并没有要对他们进行微观管理的想法。这一切说明了什么问题？法务团队肯定以某种方式展现了他们的专业精神，而技术团队尚未做到这点。</li></ul><p>技术人员需要如何改变才能被视为专业人士呢</p><h2 id="必读引言"><a href="#必读引言" class="headerlink" title="必读引言"></a>必读引言</h2><ul><li>后来，我曾经因为粗心耽误了关键日期被炒鱿鱼，因为不小心向客户泄露机密数据几乎被炒鱿鱼。我曾经领导过毫无成功希望的项目，看着它垮掉，明知需要他人帮助却无动于衷。我曾经好强地固守自己的技术决策，即便这些决策在客户的需求面前黯然失色。我曾经雇用完全不合适的人，让我的老板背上沉重的负担。最糟糕的是，因为我领导无方，其他两个人被炒了鱿鱼。</li></ul><h2 id="第1章-专业主义"><a href="#第1章-专业主义" class="headerlink" title="第1章 专业主义"></a>第1章 专业主义</h2><ul><li><p>发布软件时，你应该确保QA找不出任何问题。故意发送明知有缺陷的代码，这种做法是极其不专业的。<strong>什么样的代码是有缺陷的呢？那些你没把握的代码都是！</strong></p></li><li><p>你怎么知道代码能否常运行呢？很简单，测试！一遍遍地测，翻来覆去、颠来倒去地测，使出浑身解数来测！</p></li><li><p>但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码。</p></li><li><p>要想证明软件易于修改，唯一办法就是做些实际的修改。如果发现这些改动并不像你预想的那样简单，你便应该改进设计，使后续修改变简单。</p></li><li><p>为什么大多数开发人员不敢不断修改他的代码呢？因为他们害怕会改坏代码！为什么会有这样的担心呢？因为他们没做过测试。</p></li><li><p>不能铭记过去的人，注定要重蹈覆辙。</p></li></ul><p>==下面列出了每个专业软件开发人员必须精通的事项。==</p><p>==下面列出了每个专业软件开发人员必须精通的事项。==</p><p>==下面列出了每个专业软件开发人员必须精通的事项。==</p><p>#TODO有空写个博客展开写下这个</p><blockquote><p>设计模式。必须能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验。</p><p>设计原则。必须了解SOLID原则，而且要深刻理解组件设计原则。</p><p>方法。必须理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等。</p><p>实践。必须掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程。</p><p>工件。必须了解如何使用UML图、DFD图、结构图、Petri网络图、状态迁移图表、流程图和决策表。</p></blockquote><h2 id="第2章-说“不”"><a href="#第2章-说“不”" class="headerlink" title="第2章 说“不”"></a>第2章 说“不”</h2><ul><li><p>专业人士敢于说明真相而不屈从于权势。专业人士有勇气对他们的经理说“不”。</p></li><li><p>面对艰难决定，直面不同角色的冲突是最好的办法。</p></li><li><p>你的经理要求你在明天之前完成登录页面，这就是他在追求和捍卫的一个目标，那是尽他的工作职责。如果你明知第二天之前不可能完成登录页面，嘴上却说“好的，我会试试的”，那么便是你失职了。这时候，尽职的唯一选择是说“不，这不可能”。</p></li><li><p>“为什么”远不如“事实”重要</p></li><li><p>许诺“尝试”，就意味着你承认自己之前未尽全力，承认自己还有余力可施。许诺“尝试”，意味着只要你再加把劲还是可以达成目标的；而且，这也是一种表示你将再接再厉去实现目标的承诺。因此，只要你许诺自己会去“尝试”，你其实是在承诺你会确保成功。这样，压力就要由你自己来扛了。如果你的“尝试”没有达成预期的结果，那就表示你失败了。</p></li><li><p>客户所要的任何一项功能，一旦写起来，总是远比它开始时所说的要复杂许多，但最终你还是会接下这些活。</p></li><li><p>成为英雄及“解决问题”的诱惑诚然巨大，只是我们要明白，牺牲专业原则以求全，并非问题的解决之道。舍弃这些原则，只会制造出更多的麻烦。</p></li></ul><h2 id="第3章-说“是”"><a href="#第3章-说“是”" class="headerlink" title="第3章 说“是”"></a>第3章 说“是”</h2><ul><li><p>做出承诺，包含三个步骤。（1）口头上说自己将会去做。（2）心里认真对待做出的承诺。（3）真正付诸行动。</p></li><li><p>我们有竭力逃避承担责任的倾向。</p></li><li><p>识别真正承诺的诀窍在于，要去搜寻与下列相似的语句：我将在……之前……（例如，我将在周二之前完成这个任务。）</p></li><li><p>你只能承诺自己能完全掌控的事。</p></li><li><p>如果你无法兑现承诺，那么最重要的就是尽早向你的承诺对象发出预警，越快越好，越早越好。</p></li><li><p>如果是专业开发人员，就不会放弃底线。</p></li></ul><h2 id="第4章-编码"><a href="#第4章-编码" class="headerlink" title="第4章 编码"></a>第4章 编码</h2><ul><li><p>能够感知到错误确实非常重要。不只对“录入”是这样，对于一切事情莫不如此。具备“出错感知能力”，说明你已经能够非常迅速地获得反馈，能够更为快速地从错误中学习。</p></li><li><p>我发现，要精熟掌握每项技艺，关键都是要具备“信心”和“出错感知”能力。</p></li><li><p>一些曾经进入这种状态但终又从中摆脱出来的人给出了一点儿忠告：避免进入流态区。这种意识状态并非真的极为高效，也绝非毫无错误。这其实只是一种“浅层冥想”状态，在这种状态下，为了追求所谓的速度，理性思考的能力会下降。</p></li><li><p>结对编程最大的一个好处在于，结对中的任一方都不可能进入流态区。流态区是一种与世隔绝的状态，而结对则要求持续密切地进行沟通。</p></li><li><p>当坐到别人旁边的时候，本来挡住去路的问题忽然就会消失了。和别人一起工作时，会发生一种生理上的变化。我不知道这种变化是什么，但是我能够真切感知到这种变化。在我的大脑或身体中会发生一些化学变化，这种变化能帮助我冲破阻塞继续前进。</p></li><li><p><strong>衡量你是否是一名专业人士的一个重要方面，便是看你是否能将调试时间尽量降到最低。绝对的零调试时间是一个理想化的目标，无法达到，但要将之作为努力方向。</strong></p></li><li><p>管理延迟的诀窍，便是早期检测和保持透明。最糟糕的情况是，你一直都在告诉每个人你会按时完成工作，到最后期限来临前你还在这样说，但最终你只能让他们大失所望。不要这么做。相反，要根据目标定期衡量进度，使用三个考虑到多种因素的期限[8]：乐观预估、标称预估、悲观预估。</p></li><li><p>如果可怜的开发人员在压力之下最终屈服，同意尽力赶上截止日期，结局会十分悲惨。那些开发人员会开始抄近路，会额外加班加点工作，抱着创造奇迹的渺茫希望。</p></li><li><p><strong>在程序员所能表现的各种不专业行为中，最糟糕的是明知道还没有完成任务却宣称已经完成。</strong></p></li><li><p>如果有人向你伸出援手，要诚挚接受，心怀感激地接受帮助并诚意合作。</p></li><li><p><strong>花时间手把手地辅导年轻程序员是资深程序员的专业职责所在。同样道理，向资深导师寻求辅导也是年轻程序员的专业职责。</strong></p></li></ul><h2 id="第5章-测试驱动开发"><a href="#第5章-测试驱动开发" class="headerlink" title="第5章 测试驱动开发"></a>第5章 测试驱动开发</h2><p>==TDD三项法则==</p><p>（1）在编好失败单元测试之前，不要编写任何产品代码。</p><p>（2）只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况。（3）产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。</p><p>遵循这三项法则的话，大概30秒钟就要运行一次代码。先写好一个单元测试的一小部分代码，很快，你会发现还缺少一些类或函数，所以单元测试无法编译。因此必须编写产品代码，让这些测试能够编译成功。产品代码够用即可，然后再回头接着写单元测试代码。</p><p>事后写的测试只是一种防守。而先行编写的测试则是进攻，事后编写测试的作者已经受制于已有代码，他已经知道问题是如何解决的。与采用测试先行的方式编写的测试代码比起来，后写的测试在深度和捕获错误的灵敏度方面要逊色很多。</p><h2 id="第6章-练习"><a href="#第6章-练习" class="headerlink" title="第6章 练习"></a>第6章 练习</h2><ul><li>卡塔是一套设计好的、用来模拟搏斗一方的招式。目标则是要逐步把整套招式练习到纯熟。习武者努力训练自己的身体来熟悉每一招，把它们连贯成流畅的套路。训练有素的卡塔看起来相当漂亮。</li><li>无论如何，专业人士都需要练习。他们这么做，是因为他们关心自己能做到的最好结果。更重要的是，他们用自己的时间练习，因为他们知道保持自己的技能不落伍是自己的责任，而不是雇主的责任。练习的时候你是赚不到钱的，但是练习之后，你会获得回报，而且是丰厚的回报。</li></ul><h2 id="第7章-验收测试"><a href="#第7章-验收测试" class="headerlink" title="第7章 验收测试"></a>第7章 验收测试</h2><ul><li><p>在工作中，有一种现象叫观察者效应，或者不确定原则。每次你向业务方展示一项功能，他们就获得了比之前更多的信息，这些新信息反过来又会影响他们对整个系统的看法。最终结果就是，需求完成得越精细，就越容易被忽视，系统因此也谈不上完工。</p></li><li><p>需求文档中的每一点模糊之处，都对应着业务方的一点分歧。当然，模糊不只来自于分歧或争论。有时候，业务方会想当然地认为看文档的人懂得自己的意思。</p></li></ul><h2 id="第9章-时间管理"><a href="#第9章-时间管理" class="headerlink" title="第9章 时间管理"></a>第9章 时间管理</h2><ul><li><p>如果会议让人厌烦，就离席。</p></li><li><p>“凡是不能在5分钟内解决的争论，都不能靠辩论解决。”争论之所以要花这么多时间，是因为各方都拿不出足够有力的证据。所以这类争论依据的不是事实，而是信念。</p></li><li><p>忧虑和分心也会消耗注意力点数。</p></li><li><p>在走入死胡同时可以迅速意识到，并有足够的勇气走回头路。</p></li><li><p>坑法则（The Rule of Holes）：如果你掉进了坑里，别挖。</p></li></ul><h2 id="第10章-预估"><a href="#第10章-预估" class="headerlink" title="第10章 预估"></a>第10章 预估</h2><ul><li><p>专业开发人员不随便承诺，除非他们确切知道可以完成。道理就是这么简单。</p></li><li><p>控制错误的办法之一是使用大数定律。该定律的意思是：<strong>把大任务分成许多小任务，分开预估再加总，结果会比单独评估大任务要准确很多。这样做之所以能提高准确度，是因为小任务的预估错误几乎可以忽略，不会对总的结果产生明显影响。</strong></p></li></ul><h2 id="第11章-压力"><a href="#第11章-压力" class="headerlink" title="第11章 压力"></a>第11章 压力</h2><ul><li><p>他知道这些是他赖以战胜由最后期限和承诺所带来的压力感的最好方法。</p></li><li><p>观察自己在危机时刻中的反应，就可以了解自己的信念。如果在危机中依然遵循着你守持的纪律，就说明你确实相信那些纪律。</p></li></ul><h2 id="第12章-协作"><a href="#第12章-协作" class="headerlink" title="第12章 协作"></a>第12章 协作</h2><ul><li><strong>人际关系难以应付而且毫无规律</strong>.编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。</li></ul><h2 id="第14章-辅导、学徒期与技艺"><a href="#第14章-辅导、学徒期与技艺" class="headerlink" title="第14章 辅导、学徒期与技艺"></a>第14章 辅导、学徒期与技艺</h2><ul><li><p>成熟工匠手脚麻利，从容淡定，他们能够做出合情合理的估算并遵守承诺。工匠知道何时该说“不”，但他们更懂得如何承诺。成熟工匠可以算是专业人士。</p></li><li><p><strong>技艺是工匠所持的精神状态。技艺的“模因”（meme[6]）中包含着价值观、原则、技术、态度和正见。</strong></p></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robert C. Martin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《架构整洁之道》笔记</title>
      <link href="/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="推荐序一"><a href="#推荐序一" class="headerlink" title="推荐序一"></a>推荐序一</h2><p>我们把这些有“洁癖”、有工匠精精、有修养的程序员叫作工程师，工程师不仅仅是在编写代码，他们会用工程的方法来编写代码，以便让编程开发更为高效和快速。他们把编程当成一种设计，一种工业设计，把代码模块化，让这些模块可以更容易地交互拼装和组织，让代码排列整齐——阅读和维护这些代码就像看阅兵式一样舒心畅快。</p><h2 id="推荐序二-久远的教诲，古老的智慧"><a href="#推荐序二-久远的教诲，古老的智慧" class="headerlink" title="推荐序二 久远的教诲，古老的智慧"></a>推荐序二 久远的教诲，古老的智慧</h2><p>避免随意使用goto，使用if-else、switch-case之类控制语句和函数、子函数组织起来的程序代码，可以保证程序的结构是清楚的，自顶向下层层细化，消灭了杂错，杜绝了混淆。</p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>软件架构学关注的的一个重点是组织结构(structure)。不管是讨论组件(Component)、类(Class)、函数(Function)、模块(Module)，还是层级(Layer)、服务(Service)以及微观与宏观的软件开发过程，软件的组织结构都是我们的主要关注点。</p><h3 id="第1章-设计与架构究竟是什么"><a href="#第1章-设计与架构究竟是什么" class="headerlink" title="第1章 设计与架构究竟是什么"></a>第1章 设计与架构究竟是什么</h3><ul><li><strong>软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。</strong></li><li>一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。如果该成本很低，并且在系统的整个生命周期内一直都能维持这样的低成本，那么这个系统的设计就是优良的。</li></ul><h3 id="第2章-两个价值维度"><a href="#第2章-两个价值维度" class="headerlink" title="第2章 两个价值维度"></a>第2章 两个价值维度</h3><ul><li><p>行为价值：大部分程序员认为这就是他们的全部工作。他们的工作是且仅是：按照需求文档编写代码，并且修复任何Bug。这真是大错特错。</p></li><li><p>架构价值：为了达到软件的本来目的，软件系统必须够“软”——也就是说，软件应该容易被修改。当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便地实现。</p></li><li><p>如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为0。</p></li><li><p>软件系统的第一个价值维度：<strong>系统行为</strong>，是紧急的，但是并不总是特别重要。软件系统的第二个价值维度：<strong>系统架构</strong>，是重要的，但是并不总是特别紧急。</p></li></ul><p>==艾森豪威尔矩阵==</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122204108331.png" alt="image-20231122204108331"></p><h2 id="第2部分-从基础构件开始：编程范式"><a href="#第2部分-从基础构件开始：编程范式" class="headerlink" title="第2部分 从基础构件开始：编程范式"></a>第2部分 从基础构件开始：编程范式</h2><ul><li><strong>编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。这些范式会告诉你应该在什么时候采用什么样的代码结构。</strong></li></ul><h3 id="第3章-编程范式总览"><a href="#第3章-编程范式总览" class="headerlink" title="第3章 编程范式总览"></a>第3章 编程范式总览</h3><p>三个编程范式，它们分别是**结构化编程(structured programming)<strong>、</strong>面向对象编程(object-oriented programming)<strong>以及</strong>函数式编程(functional programming)**。</p><ul><li><p>结构化编程对程序控制权的直接转移进行了限制和规范。</p></li><li><p>面向对象编程对程序控制权的间接转移进行了限制和规范。</p></li><li><p>函数式编程对程序中的赋值进行了限制和规范。</p></li><li><p>每个编程范式的目的都是设置限制。这些范式主要是为了告诉我们不能做什么，而不是可以做什么。</p></li><li><p><strong>这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</strong></p></li></ul><h3 id="第4章-结构化编程"><a href="#第4章-结构化编程" class="headerlink" title="第4章 结构化编程"></a>第4章 结构化编程</h3><ul><li>结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。</li><li>无论在哪一个层面上，从最小的函数到最大组件，软件开发的过程都和科学研究非常类似，它们都是由证伪驱动的。软件架构师需要定义可以方便地进行证伪（测试）的模块、组件以及服务。</li></ul><h3 id="第5章-面向对象编程"><a href="#第5章-面向对象编程" class="headerlink" title="第5章 面向对象编程"></a>第5章 面向对象编程</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122204725715.png" alt="image-20231122204725715"></p><ul><li><p>请注意模块ML1和接口I在源代码上的依赖关系（或者叫继承关系），该关系的方向和控制流正好是相反的，我们称之为依赖反转。这种反转对软件架构设计的影响是非常大的。</p></li><li><p>通过这种（多态）方法，软件架构师可以完全控制采用了面向对象这种编程方式的系统中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者被调用，软件架构师都可以随意更改源代码依赖关系。</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122205041012.png" alt="image-20231122205041012"></p><ul><li>面向对象编程到底是什么？然而对一个软件架构师来说，其含义应该是非常明确的：<strong>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力</strong></li></ul><h3 id="第6章-函数式编程"><a href="#第6章-函数式编程" class="headerlink" title="第6章 函数式编程"></a>第6章 函数式编程</h3><ul><li><p>作为一个软件架构师，当然应该要对并发问题保持高度关注。我们需要确保自己设计的系统在多线程、多处理器环境中能稳定工作。</p></li><li><p>一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。</p></li><li><p>如果我们有足够大的存储量和处理能力，应用程序就可以用完全不可变的、纯函数式的方式来编程。</p></li><li><p>三个编程范式都对程序员提出了新的限制。每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。也就是说，我们过去50年学到的东西主要是——什么不应该做。我们必须面对这种不友好的现实：软件构建并不是一个迅速前进的技术。今天构建软件的规则和1946年阿兰·图灵写下电子计算机的第一行代码时是一样的。尽管工具变化了，硬件变化了，但是软件编程的核心没有变。</p></li></ul><h2 id="第3部分-设计原则"><a href="#第3部分-设计原则" class="headerlink" title="第3部分 设计原则"></a>第3部分 设计原则</h2><blockquote><p>一般情况下，我们为软件构建中层结构的主要目标如下：使软件可容忍被改动。使软件更容易被理解。构建可在多个软件系统中复用的组件。</p></blockquote><ul><li><p>SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类，以及如何将这些类链接起来成为程序。</p></li><li><p>==SRP：单一职责原则==。该设计原则是基于康威定律(Conway’s Law)[插图]的一个推论——一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有一个需要被改变的理由。</p></li><li><p>==OCP：开闭原则==。该设计原则是由Bertrand Meyer在20世纪80年代大力推广的，其核心要素是：如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。</p></li><li><p>==LSP：里氏替换原则==。该设计原则是Barbara Liskov在1988年提出的一个著名的子类型定义。简单来说，这项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。</p></li><li><p>==ISP：接口隔离原则==。这项设计原则主要告诫软件设计师应该在设计中避免不必要的依</p></li><li><p>==DIP：依赖反转原则==。该设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。</p></li></ul><h3 id="第7章-SRP：单一职责原则"><a href="#第7章-SRP：单一职责原则" class="headerlink" title="第7章 SRP：单一职责原则"></a>第7章 SRP：单一职责原则</h3><p>以下是三种相同的表述:</p><blockquote><p>任何一个软件模块都应该有且仅有一个被修改的原因。</p><p>任何一个软件模块都应该只对一个用户(User)或系统利益相关者(Stakeholder)负责。</p><p>任何一个软件模块都应该只对某一类行为者负责</p></blockquote><p>单一职责原则主要讨论的是函数和类之间的关系——但是它在两个讨论层面上会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则(Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心(Axis of Change)。我们在接下来的章节中会深入学习这些原则。</p><h3 id="第8章-OCP：开闭原则"><a href="#第8章-OCP：开闭原则" class="headerlink" title="第8章 OCP：开闭原则"></a>第8章 OCP：开闭原则</h3><ul><li><p>设计良好的计算机软件应该易于扩展，同时抗拒修改。</p></li><li><p>一个好的软件架构设计师会努力将旧代码的修改需求量降至最小，甚至为0。</p></li><li><p>我们可以先将满足不同需求的代码分组（即SRP），然后再来调整这些分组之间的依赖关系（即DIP）</p></li><li><p>如果A组件不想被B组件上发生的修改所影响，那么就应该让B组件依赖于A组件。</p></li><li><p>软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些互相隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改而受到影响。</p></li><li><p><strong>OCP是我们进行系统架构设计的主导原则</strong>，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围</p></li></ul><h3 id="第9章-LSP：里氏替换原则"><a href="#第9章-LSP：里氏替换原则" class="headerlink" title="第9章 LSP：里氏替换原则"></a>第9章 LSP：里氏替换原则</h3><ul><li><p>可替换性：如果对于每个类型是S的对象o1都存在一个类型为T的对象o2，能使操作T类型的程序P在用o2替换o1时行为保持不变，我们就可以将S称为T的子类型。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210636930.png"></p></li></ul><p>正方形/长方形问题是一个著名（或者说臭名远扬）的违反LSP的设计案例,在这个案例中，Square类并不是Rectangle类的子类型，因为Rectangle类的高和宽可以分别修改，而Square类的高和宽则必须一同修改。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210751691.png" alt="image-20231122210751691"></p><ul><li>LSP可以且应该被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。</li></ul><h3 id="第10章-ISP：接口隔离原则"><a href="#第10章-ISP：接口隔离原则" class="headerlink" title="第10章 ISP：接口隔离原则"></a>第10章 ISP：接口隔离原则</h3><ul><li>在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210912274.png" alt="image-20231122210912274"></p><h3 id="第11章-DIP：依赖反转原则"><a href="#第11章-DIP：依赖反转原则" class="headerlink" title="第11章 DIP：依赖反转原则"></a>第11章 DIP：依赖反转原则</h3><ul><li><p><strong>如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。</strong></p></li><li><p>优秀的软件设计师和架构师会花费很大精力来设计接口，以减少未来对其进行改动。毕竟争取在不修改接口的情况下为软件增加新的功能是软件设计的基础常识。</p></li><li><p>如果想要在软件架构设计上追求稳定，就必须多使用稳定的抽象接口，少依赖多变的具体实现。</p></li><li><p>应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。</p></li><li><p>对象的创建过程也应该受到严格限制，对此，我们通常会选择用抽象工厂(abstract factory)这个设计模式。</p></li><li><p>不要在具体实现类上创建衍生类。</p></li><li><p>不要覆盖(override)包含具体实现的函数</p></li><li><p>应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字</p></li></ul><h2 id="第4部分-组件构建原则"><a href="#第4部分-组件构建原则" class="headerlink" title="第4部分 组件构建原则"></a>第4部分 组件构建原则</h2><p><strong>如果说SOLID原则是用于指导我们如何将砖块砌成墙与房间的，那么组件构建原则就是用来指导我们如何将这些房间组合成房子的。</strong></p><h3 id="第12章-组件"><a href="#第12章-组件" class="headerlink" title="第12章 组件"></a>第12章 组件</h3><ul><li><p>组件都是该软件在部署过程中的最小单元</p></li><li><p>设计良好的组件都应该永远保持可被独立部署的特性，这同时也意味着这些组件应该可以被单独开发。</p></li></ul><h3 id="第13章-组件聚合"><a href="#第13章-组件聚合" class="headerlink" title="第13章 组件聚合"></a>第13章 组件聚合</h3><ul><li>究竟是哪些类应该被组合成一个组件呢？这是一个非常重要的设计决策，应该遵循优秀的软件工程经验来行事。但不幸的是，很多年以来，我们对于这么重要的决策经常是根据当下面临的实际情况临时拍脑门决定的。</li></ul><p>三个与构建组件相关的基本原则：</p><p>==REP：复用/发布等同原则。CCP：共同闭包原则。CRP：共同复用原则。==</p><ul><li><p>软件复用的最小粒度应等同于其发布的最小粒度。</p></li><li><p><strong>REP原则</strong>就是指组件中的类与模块必须是彼此紧密相关的。也就是说，一个组件不能由一组毫无关联的类和模块组成，它们之间应该有一个共同的主题或者大方向。</p></li><li><p><strong>CCP</strong>的主要作用就是提示我们要将所有可能会被一起修改的类集中在一处。也就是说，如果两个类紧密相关，不管是源代码层面还是抽象理念层面，永远都会一起被修改，那么它们就应该被归属为同一个组件。通过遵守这个原则，我们就可以有效地降低因软件发布、验证及部署所带来的工作压力。</p></li><li><p>对大部分应用程序来说，可维护性的重要性要远远高于可复用性。</p></li><li><p><strong>CCP原则</strong>实际上就是SRP原则的组件版。在SRP原则的指导下，我们将会把变更原因不同的函数放入不同的类中。而CCP原则指导我们应该将变更原因不同的类放入不同的组件中。</p></li><li><p>不要强迫一个组件的用户依赖他们不需要的东西。**共同复用原则(CRP)**是另外一个帮助我们决策类和模块归属于哪一个组件的原则。该原则建议我们将经常共同复用的类和模块放在同一个组件中。</p></li><li><p>由于这种依赖关系的存在，每当被引用组件发生变更时，引用它的组件一般也需要做出相应的变更。即使它们不需要进行代码级的变更，一般也免不了需要被重新编译、验证和部署。哪怕引用组件根本不关心被引用组件中的变更，也要如此。</p></li><li><p>在CRP原则中，关于哪些类不应该被放在一起的建议是其更为重要的内容</p></li><li><p>CRP原则实际上是ISP原则的一个普适版。ISP原则是建议我们不要依赖带有不需要的函数的类，而CRP原则则是建议我们不要依赖带有不需要的类的组件。可以总结为：<strong>不要依赖不需要用到的东西。</strong></p></li></ul><p>==一张组件聚合三大原则的张力图==</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122211753671.png" alt="image-20231122211753671"></p><p>一般来说，一个软件项目的重心会从该三角区域的右侧开始，先期主要牺牲的是复用性。然后，随着项目逐渐成熟，其他项目会逐渐开始对其产生依赖，项目重心就会逐渐向该三角区域的左侧滑动。换句话说，一个项目在组件结构设计上的重心是根据该项目的开发时间和成熟度不断变动的，我们对组件结构的安排主要与项目开发的进度和它被使用的方式有关，与项目本身功能的关系其实很小。</p><h3 id="第14章-组件耦合"><a href="#第14章-组件耦合" class="headerlink" title="第14章 组件耦合"></a>第14章 组件耦合</h3><ul><li><p><strong>组件依赖关系图中不应该出现环。</strong></p></li><li><p>“一觉醒来综合征”的解决方法：第一种是“每周构建”，第二种是“无依赖环原则(ADP)”。</p></li><li><p>每当一个组件发布新版本时，其他依赖这个组件的团队都可以自主决定是否立即采用新版本。若不采用，该团队可以选择继续使用旧版组件，直到他们准备好采用新版本为止。</p></li><li><p>我们可以打破这些组件中的循环依赖，并将其依赖图转化为DAG。目前有以下两种主要机制可以做到这件事情：1.应用依赖反转原则(DIP)：2.创建一个新的组件；</p></li><li><p>根据上述讨论，我们可以得出一个无法逃避的结论：组件结构图是不可能自上而下被设计出来的。它必须随着软件系统的变化而变化和扩张，而不可能在系统构建的最初就被完美设计出来。</p></li><li><p>人们也普遍认为项目粗粒度的组件分组规则所产生的就是组件的依赖结构，也应该在某种程度上与项目的系统功能分解的结果相互对应</p></li><li><p>组件依赖结构图并不是用来描述应用程序功能的，它更像是应用程序在构建性与维护性方面的一张地图</p></li><li><p>如果我们在设计具体类之前就来设计组件依赖关系，那么几乎是必然要失败的。</p></li><li><p><strong>依赖关系必须要指向更稳定的方向。</strong></p></li><li><p><strong>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖，否则这个多变的组件也将会变得非常难以被修改。</strong></p></li><li><p>让软件组件难于修改的一个最直接的办法就是让很多其他组件依赖于它。带有许多入向依赖关系的组件是非常稳定的，因为它的任何变更都需要应用到所有依赖它的组件上，比如下图的X</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231128193729125.png" alt="image-20231128193729125"></p><ul><li><p>稳定性指标：</p><ul><li><strong>Fan-in：入向依赖</strong>，这个指标指代了组件外部类依赖于组件内部类的数量。</li><li><strong>Fan-out：出向依赖</strong>，这个指标指代了组件内部类依赖于组件外部类的数量。</li><li>**I：不稳定性，I=Fan-out/(Fan-in+Fan-out)**。该指标的范围是[0,1],I=0意味着组件是最稳定的，I=1意味着组件是最不稳定的。</li></ul></li><li><p><strong>稳定依赖原则(SDP)的要求是让每个组件的I指标都必须大于其所依赖组件的I指标。也就是说，组件结构依赖图中各组件的I指标必须要按其依赖关系方向递减。</strong></p></li><li><p>我们设计组件架构图的目的就是要决定应该让哪些组件稳定，让哪些组件不稳定。</p></li><li><p>动态类型语言中的依赖关系是非常简单的，因为其依赖反转的过程并不需要声明和继承接口。</p></li><li><p>==稳定抽象原则（SAP）==：一个组件的抽象化程度应该与其稳定性保持一致。</p></li><li><p>抽象程度的衡量：假设A指标是对组件抽象化程度的一个衡量，它的值是组件中抽象类与接口所占的比例。那么：Nc：组件中类的数量。Na：组件中抽象类和接口的数量。A：抽象程度，A=Na÷Nc。A指标的取值范围是从0到1，值为0代表组件中没有任何抽象类，值为1就意味着组件中只有抽象类。</p></li></ul><h2 id="第5部分-软件架构"><a href="#第5部分-软件架构" class="headerlink" title="第5部分 软件架构"></a>第5部分 软件架构</h2><h3 id="第15章-什么是软件架构"><a href="#第15章-什么是软件架构" class="headerlink" title="第15章 什么是软件架构"></a>第15章 什么是软件架构</h3><ul><li>软件系统的架构质量是由它的构建者所决定的，软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。</li></ul><blockquote><p>如果想设计一个便于推进各项工作的系统，其策略就是要在设计中尽可能长时间地保留尽可能多的可选项。</p></blockquote><p>==说白了就是要可扩展性要强==</p><ul><li><p>一个系统的部署成本越高，可用性就越低。</p></li><li><p>架构应该起到揭示系统运行过程的作用。</p></li><li><p>系统维护的主要成本集中在“探秘”和“风险”这两件事上。其中，“探秘(spelunking)”的成本主要来自我们对于现有软件系统的挖掘，目的是确定新增功能或被修复问题的最佳位置和最佳方式。而“风险(risk)”，则是指当我们进行上述修改时，总是有可能衍生出新的问题，这种可能性就是风险成本。</p></li><li><p>软件架构师的目标是创建一种系统形态，该形态会以策略为最基本的元素，并让细节与策略脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容。</p></li><li><p>如果在开发高层策略时有意地让自己摆脱具体细节的纠缠，我们就可以将与具体实现相关的细节决策推迟或延后，因为越到项目的后期，我们就拥有越多的信息来做出合理的决策。</p></li><li><p>一个优秀的软件架构师应该致力于最大化可选项数量。</p></li><li><p>优秀的架构师会小心地将软件的高层策略与其底层实现隔离开，让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖。</p></li><li><p>优秀的架构师所设计的策略应该允许系统尽可能地推迟与实现细节相关的决策，越晚做决策越好。</p></li></ul><h3 id="第16章-独立性"><a href="#第16章-独立性" class="headerlink" title="第16章 独立性"></a>第16章 独立性</h3><ul><li><p>一个设计良好的软件架构必须支持以下几点：系统的用例与正常运行、系统的维护、系 统的开发、系统的部署。</p></li><li><p>一个设计良好的架构在行为上对系统最重要的作用就是明确和显式地反映系统设计意图的行为，使其在架构层面上可见。</p></li><li><p>任何一个组织在设计系统时，往往都会复制出一个与该组织内沟通结构相同的系统。</p></li><li><p>设计目标一定是实现“立刻部署”。一个设计良好的架构通常不会依赖于成堆的脚本与配置文件，也不需要用户手动创建一堆“有严格要求”的目录与文件。总而言之，一个设计良好的软件架构可以让系统在构建完成之后立刻就能部署。</p></li><li><p><strong>如果我们按照变更原因的不同对系统进行解耦，就可以持续地向系统内添加新的用例，而不会影响旧有的用例。如果我们同时对支持这些用例的UI和数据库也进行了分组，那么每个用例使用的就是不同面向的UI与数据库，因此增加新用例就更不太可能会影响旧有的用例了</strong></p></li><li><p>为了在不同的服务器上运行，被隔离的组件不能依赖于某个处理器上的同一个地址空间，它们必须是独立的服务，然后通过某种网络来进行通信。许多架构师将上面这种组件称为“服务”或“微服务”，至于是前者还是后者，往往取决于某些非常模糊的代码行数阈值。对于这种基于服务来构建的架构，架构师们通常称之为<strong>面向服务的架构(service-oriented architecture)，即SOA</strong>。</p></li><li><p>如果有两段看起来重复的代码，它们走的是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两段代码就不是真正的重复。</p></li></ul><h3 id="第17章-划分边界"><a href="#第17章-划分边界" class="headerlink" title="第17章 划分边界"></a>第17章 划分边界</h3><ul><li><p>软件架构设计本身就是一门划分边界的艺术。</p></li><li><p>一个系统最消耗人力资源的是什么？答案是系统中存在的耦合——尤其是那些过早做出的、不成熟的决策所导致的耦合。</p></li><li><p>边界线应该画在那些不相关的事情中间。GUI与业务逻辑无关，所以两者之间应该有一条边界线。数据库与GUI无关，这两者之间也应该有一条边界线。数据库又与业务逻辑无关，所以两者之间也应该有一条边界线。</p></li><li><p>将系统设计为插件式架构，就等于构建起了一面变更无法逾越的防火墙。</p></li></ul><h3 id="第18章-边界剖析"><a href="#第18章-边界剖析" class="headerlink" title="第18章 边界剖析"></a>第18章 边界剖析</h3><ul><li><p>高层进程的源码中不应该包含低层进程的名字、物理内存地址或是注册表键名。</p></li><li><p>系统架构中最强的边界形式就是服务。</p></li><li><p>一个系统中通常会同时包含高通信量、低延迟的本地架构边界和低通信量、高延迟的服务边界。</p></li></ul><h3 id="第19章-策略与层次"><a href="#第19章-策略与层次" class="headerlink" title="第19章 策略与层次"></a>第19章 策略与层次</h3><ul><li><p>计算机程序不过就是一组仔细描述如何将输入转化为输出的策略语句的集合。</p></li><li><p>架构设计的工作常常需要将组件重排组合成为一个有向无环图。图中的每一个节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了一种组件之间的依赖关系，它们将不同级别的组件链接起来。</p></li><li><p>低层组件应该成为高层组件的插件</p></li></ul><h3 id="第20章-业务逻辑"><a href="#第20章-业务逻辑" class="headerlink" title="第20章 业务逻辑"></a>第20章 业务逻辑</h3><ul><li><p>业务实体这个概念只要求我们将关键业务数据和关键业务逻辑绑定在一个独立的软件模块内。</p></li><li><p>用例控制着业务实体之间的交互方式。</p></li><li><p>业务实体并不会知道是哪个业务用例在控制它们，这也是依赖反转原则(DIP)的另一个应用情景。也就是像业务实体这样的高层概念是无须了解像用例这样的低层概念的。反之，低层的业务用例却需要了解高层的业务实体。</p></li><li><p>业务逻辑是一个软件系统存在的意义，它们属于核心功能，是系统用来赚钱或省钱的那部分代码，是整个系统中的皇冠明珠。</p></li></ul><h3 id="第21章-尖叫的软件架构"><a href="#第21章-尖叫的软件架构" class="headerlink" title="第21章 尖叫的软件架构"></a>第21章 尖叫的软件架构</h3><p>软件的系统架构应该为该系统的用例提供支持。这就像住宅和图书馆的建筑计划满篇都在非常明显地凸显这些建筑的用例一样，软件系统的架构设计图也应该非常明确地凸显该应用程序会有哪些用例。</p><h3 id="第22章-整洁架构"><a href="#第22章-整洁架构" class="headerlink" title="第22章 整洁架构"></a>第22章 整洁架构</h3><ul><li><p>按照不同关注点对软件进行切割。也就是说，这些架构都会将软件切割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口、系统接口则属于其他层。</p></li><li><p>源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。</p></li><li><p>我们不应该让外层圆中发生的任何变更影响到内层圆的代码。</p></li><li><p>读者必须注意一下这里的依赖关系方向。所有跨边界的依赖线都是指向内的，这很好地遵守了架构的依赖关系规则。</p></li></ul><h3 id="第23章-展示器和谦卑对象"><a href="#第23章-展示器和谦卑对象" class="headerlink" title="第23章 展示器和谦卑对象"></a>第23章 展示器和谦卑对象</h3><ul><li>展示器实际上是采用谦卑对象(humble object)模式的一种形式，这种设计模式可以很好地帮助识别和保护系统架构的边界。</li></ul><h3 id="第24章-不完全边界"><a href="#第24章-不完全边界" class="headerlink" title="第24章 不完全边界"></a>第24章 不完全边界</h3><ul><li>构建不完全边界的一种方式就是在将系统分割成一系列可以独立编译、独立部署的组件之后，再把它们构建成一个组件。换句话说，在将系统中所有的接口、用于输入/输出的数据格式等每一件事都设置好之后，仍选择将它们统一编译和部署为一个组件。</li></ul><h3 id="第28章-测试边界"><a href="#第28章-测试边界" class="headerlink" title="第28章 测试边界"></a>第28章 测试边界</h3><ul><li><p>我们可以将测试组件视为系统架构中最外圈的程序。它们始终是向内依赖的，而且系统中没有其他组件依赖于它们。</p></li><li><p>修改一个通用的系统组件可能会导致成百上千个测试出现问题，我们通常将这类问题称为脆弱的测试问题(fragiletestsproblem)。</p></li></ul><h3 id="第29章-整洁的嵌入式架构"><a href="#第29章-整洁的嵌入式架构" class="headerlink" title="第29章 整洁的嵌入式架构"></a>第29章 整洁的嵌入式架构</h3><ul><li><p>“虽然软件本身并不会随时间推移而磨损，但硬件及其固件却会随时间推移而过时，随即也需要对软件做相应改动。”</p></li><li><p>不要再写固件代码了，让我们的代码活得更久一点！</p></li></ul><h3 id="第32章-应用程序框架是实现细节"><a href="#第32章-应用程序框架是实现细节" class="headerlink" title="第32章 应用程序框架是实现细节"></a>第32章 应用程序框架是实现细节</h3><ul><li><p>我们可以使用框架——但要时刻警惕，别被它拖住。我们应该将框架作为架构最外圈的一个实现细节来使用，不要让它们进入内圈。</p></li><li><p>如果一旦在项目中引入一个框架，很有可能在整个生命周期中都要依赖于它，不管后来情形怎么变化，这个决定都很难更改了。因此，不应该草率地做出决定。</p></li></ul><h3 id="第34章-拾遗"><a href="#第34章-拾遗" class="headerlink" title="第34章 拾遗"></a>第34章 拾遗</h3><ul><li>如果不考虑具体实现细节，再好的设计也无法长久。必须要将设计映射到对应的代码结构上，考虑如何组织代码树，以及在编译期和运行期采用哪种解耦合的模式。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robert C. Martin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>From Now On重新开写！</title>
      <link href="/2023/11/21/thought_%E5%BC%80%E5%A7%8B%E5%86%99blog/"/>
      <url>/2023/11/21/thought_%E5%BC%80%E5%A7%8B%E5%86%99blog/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Hello，Blog！"><a href="#Hello，Blog！" class="headerlink" title="Hello，Blog！"></a>Hello，Blog！</h1><p>​本科的时候就有写blog的习惯，觉得与人分享是件快乐的事，同时在写博客的过程中也可以让自己重新审视一下自己学过的知识，在大概距离现在半年前就又有了开始写博客的念头，磕磕绊绊，只整理了三四篇就停了，现在，让我们继续重启吧！继续记录一下看过的一些书，和有趣的一些知识。</p><p>​就以，《From now on》这首我喜欢的歌曲作为这段路途的开头吧。</p><blockquote><p>From now on</p><p>从现在</p><p>These eyes will not be blinded by the lights</p><p>我双眼不会被幻象遮盖</p><p>From now on</p><p>从现在</p><p>What’s waited till tomorrow starts tonight</p><p>那些拖欠的事情今夜就</p><p>Tonight</p><p>Let this promise in me start</p><p>我愿将错误补偿</p><p>Like an anthem in my heart</p><p>如心中圣歌奏响</p><p>From now on</p><p>从现在</p><p>From now on</p></blockquote><p>​2023.11.21  22:07 于深圳</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《软件测试的艺术》笔记</title>
      <link href="/2023/11/21/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/21/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="第1章-一次自评价测试"><a href="#第1章-一次自评价测试" class="headerlink" title="第1章 一次自评价测试"></a>第1章 一次自评价测试</h2><p>所谓软件测试，<strong>就是一个过程或一系列过程，用来确认计算机代码完成了其应该完成的功能，不执行其不该有的操作。软件应当是可预测且稳定的，不会给用户带来意外惊奇。</strong></p><h2 id="第2章-软件测试的心理学和经济学"><a href="#第2章-软件测试的心理学和经济学" class="headerlink" title="第2章 软件测试的心理学和经济学"></a>第2章 软件测试的心理学和经济学</h2><p>要成功地测试一个软件应用程序，测试人员也需要有正确的态度（也许用“愿景”（vision）这个词会更好一些）。在某些情况下，测试人员的态度可能比实际的测试过程本身还要重要。</p><h3 id="2-1-软件测试的心理学"><a href="#2-1-软件测试的心理学" class="headerlink" title="2.1 软件测试的心理学"></a>2.1 软件测试的心理学</h3><ol><li><p><strong>每当测试一个程序时，应当想到要为程序增加一些价值。</strong>通过测试来增加程序的价值，是指测试提高了程序的可靠性或质量。提高了程序的可靠性，是指找出并最终修改了程序的错误。</p></li><li><p><strong>测试是为发现错误而执行程序的过程。</strong></p></li></ol><p>​3. 人类行为总是倾向于具有高度目标性，确立一个正确的目标有着重要的心理学影响。</p><ol start="4"><li><p><strong>如果在测试某段程序时发现了错误，而且这些错误是可以修复的，就将这次合理设计并得到有效执行的测试称做是“成功的”。如果本次测试可以最终确定再无其他可查出的错误，同样也被称做是“成功的”。</strong>所谓“不成功的”测试，仅指未能适当地对程序进行检查，在大多数情况下，未能找出错误的测试被认为是“不成功的”，这是因为认为软件中不包含错误的观点基本上是不切实际的。</p></li><li><p>心理学研究表明，当人们开始一项工作时，如果已经知道它是不可行的或无法实现时，人的表现就会相当糟糕。</p></li><li><p><strong>软件测试更适宜被视为试图发现程序中错误（假设其存在）的破坏性的过程。</strong>一个成功的测试用例，通过诱发程序发生错误，可以在这个方向上促进软件质量的改进。当然，最终我们还是要通过软件测试来建立某种程度的信心：软件做了其应该做的，未做其不应该做的。但是通过对错误的不断研究是实现这个目的的最佳途径。</p></li></ol><h4 id="2-2-1-黑盒测试"><a href="#2-2-1-黑盒测试" class="headerlink" title="2.2.1 黑盒测试"></a>2.2.1 黑盒测试</h4><p>黑盒测试是一种重要的测试策略，又称为数据驱动的测试或输入/输出驱动的测试。使用这种测试方法时，<strong>将程序视为一个黑盒子。测试目标与程序的内部机制和结构完全无关，而是将重点集中放在发现程序不按其规范正确运行的环境条件。</strong></p><h4 id="2-2-2-白盒测试"><a href="#2-2-2-白盒测试" class="headerlink" title="2.2.2 白盒测试"></a>2.2.2 白盒测试</h4><p>白盒测试或称逻辑驱动的测试，允许我们检查程序的内部结构。这种测试策略对程序的逻辑结构进行检查，从中获取测试数据（遗憾的是，常常忽略了程序的规范）。</p><blockquote><p>所谓穷举路径测试，即如果使用测试用例执行了程序中所有可能的控制流路径，那么程序有可能得到了完全测试。</p></blockquote><p>==注意这里的表述是有可能。==</p><p>“穷举路径测试即完全的测试”论断存在的第二个问题是，虽然我们可以测试到程序中的所有路径，但是程序可能仍然存在着错误。这有三个原因。第一，<strong>即使是穷举路径测试也决不能保证程序符合其设计规范。</strong>举例来说，如果要编写一个升序排序程序，但却错误地编成了一个降序排序程序，那么穷举路径测试就没多大价值了；程序仍然存在着一个缺陷：它是个错误的程序，因为不符合设计的规范。第二，<strong>程序可能会因为缺少某些路径而存在问题。</strong>穷举路径测试当然不能发现缺少了哪些必需路径。第三，穷举路径测试可能不会暴露数据敏感错误。</p><h3 id="2-3-软件测试的原则"><a href="#2-3-软件测试的原则" class="headerlink" title="2.3 软件测试的原则"></a>2.3 软件测试的原则</h3><p>==表2-1总结了这些重要原则==</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_4" alt="img"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_5" alt="img"></p><p>原则1：测试用例中一个必需部分是对预期输出或结果的定义。</p><p>一个测试用例必须包括两个部分：1.对程序的输入数据的描述。2.对程序在上述输入数据下的正确输出结果的精确描述。</p><p>原则2：程序员应当避免测试自己编写的程序。</p><p>原则3：编写软件的组织不应当测试自己编写的软件。</p><p>原则4：应当彻底检查每个测试的执行结果。</p><p>原则5：测试用例的编写不仅应当根据有效和预期的输入情况，而且也应当根据无效和未预料到的输入情况。</p><p>原则6：检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”。</p><p>原则7：应避免测试用例用后即弃，除非软件本身就是一个一次性的软件。</p><p>原则8：计划测试工作时不应默许假定不会发现错误。</p><p>原则9：程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比。</p><p>原则10：软件测试是一项极富创造性、极具智力挑战性的工作。</p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>==在阅读本书接下来的内容时，请牢记以下几个重要的测试原则：·软件测试是为发现错误而执行程序的过程。·尽量避免编码人员测试自己的程序。·好的测试用例能够对未发现的错误高度敏感。·成功的测试用例能够发现未知的错误。·成功的测试需要仔细定义输入输出的期望值。·成功的测试需要仔细研究分析测试结果。==</p><h2 id="第3章-代码检查、走查与评审"><a href="#第3章-代码检查、走查与评审" class="headerlink" title="第3章 代码检查、走查与评审"></a>第3章 代码检查、走查与评审</h2><p>在开始讨论人工测试技术之前，有一条重要的注意事项：由于包含了人为因素在内，导致很多方法的正规性要差于由计算机执行的数学证明，人们可能会怀疑某些如此简单和不正规的东西是否有用。反之亦然。这些不正规的方法并没有妨碍测试取得成功；相反，它们从以下两个方面显著地提高了测试的功效和可靠性。</p><p>首先，<strong>人们普遍认识到错误发现得越早，改正错误的成本越低，正确改正错误的可能性也越大。</strong>其次<strong>，程序员在开始基于计算机的测试时似乎要经历一个心理上的转变。从内部产生的压力似乎会急剧增长，并产生一个趋势，要“尽可能快地修正这个缺陷”。</strong>由于这些压力的存在，程序员在改正某个由基于计算机测试发现的错误时所犯的失误，要比改正早期发现的问题时所犯的失误更多一些。</p><h3 id="3-1-代码检查与走查"><a href="#3-1-代码检查与走查" class="headerlink" title="3.1 代码检查与走查"></a>3.1 代码检查与走查</h3><p><strong>代码检查、走查以及可用性测试是三种主要的人工测试方法。</strong></p><p>代码检查与走查都要求人们组成一个小组来阅读或直观检查特定的程序。</p><p>代码走查的另一个优点在于，一旦发现错误，通常就能在代码中对其进行精确定位，这就降低了调试（错误修正）的成本。另外，这个过程通常发现成批的错误，这样错误就可以一同得到修正。而基于计算机的测试通常只能暴露出错误的某个表症（程序不能停止，或打印出了一个无意义的结果），错误通常是逐个地被发现并得到纠正的。</p><p>一些测试人员在使用了人工方法之后发现，对于某些特定类型的错误，人工方法比基于计算机的方法更有效，而对于其他错误类型，基于计算机的方法更有效。这就意味着，代码检查/走查与基于计算机的测试是互补的。缺少其中任何一种，错误检查的效率都会降低。</p><h4 id="3-2-2-检查议程与注意事项"><a href="#3-2-2-检查议程与注意事项" class="headerlink" title="3.2.2 检查议程与注意事项"></a>3.2.2 检查议程与注意事项</h4><p>大多数的代码检查都是按<strong>每小时大约阅读150行代码的速度进行。</strong>因此，对大型软件的检查应安排多个代码检查会议同时进行，每个代码检查会议处理一个或几个模块或子程序。</p><h4 id="3-2-4-代码检查的衍生功效"><a href="#3-2-4-代码检查的衍生功效" class="headerlink" title="3.2.4 代码检查的衍生功效"></a>3.2.4 代码检查的衍生功效</h4><ol><li>程序员通常会得到编程风格、算法选择及编程技术等方面的反馈信息。</li><li>其他参与者也可以通过接触程序员的错误和编程风格而同样受益匪浅。通常来说，这种类型的测试方法能够增强项目中团队的凝聚力，减少消极人际关系滋长的可能性，有利于打造高度合作的、高效的以及信得过的开发模式。</li></ol><h3 id="3-3-用于代码检查的错误列表"><a href="#3-3-用于代码检查的错误列表" class="headerlink" title="3.3 用于代码检查的错误列表"></a>3.3 用于代码检查的错误列表</h3><p>代码检查过程的一个重要部分就是对照一份错误列表，来检查程序是否存在常见错误。请参考下面博客：《软件测试的艺术》原书第3版的3.3节笔记-用于代码检查的错误列表</p><h3 id="3-5-桌面检查"><a href="#3-5-桌面检查" class="headerlink" title="3.5 桌面检查"></a>3.5 桌面检查</h3><p>人工查找错误的第三种过程是古老的桌面检查方法。</p><p>对于大多数人而言，桌面检查的效率是相当低的。其中的一个原因是，它是一个完全没有约束的过程。另一个重要的原因是它违反了本书第2章提出的测试原则，即人们一般不能有效地测试自己编写的程序。因此桌面检查最好由其他人而非该程序的编写人员来完成</p><h3 id="4-1-白盒测试"><a href="#4-1-白盒测试" class="headerlink" title="4.1 白盒测试"></a>4.1 白盒测试</h3><p>白盒测试关注的是<strong>测试用例执行的程度或覆盖程序逻辑结构（源代码）的程度。</strong></p><p>判定覆盖或分支覆盖是较强一些的逻辑覆盖准则。该准则要求必须编写足够的测试用例，使得每一个判断都至少有一个为真和为假的输出结果。换句话说，也就是每条分支路径都必须至少遍历一次。</p><p>在条件覆盖情况下，要编写足够的测试用例以确保将一个判断中的每个条件的所有可能的结果至少执行一次。</p><p>判定/条件覆盖准则。这种准则要求设计出充足的测试用例，将一个判断中的每个条件的所有可能的结果至少执行一次，将每个判断的所有可能的结果至少执行一次，将每个入口点都至少调用一次。</p><p>对于包含每个判断只存在一种条件的程序，最简单的测试准则就是设计出足够数量的测试用例，实现：（1）将每个判断的所有结果都至少执行一次；（2）将所有的程序入口（例如入口点或ON单元）都至少调用一次，以确保全部的语句都至少执行一次。而对于包含多重条件判断的程序，最简单的测试准则是设计出足够数量的测试用例，将每个判断的所有可能的条件结果的组合，以及所有的入口点都至少执行一次（加入“可能”二字，是因为有些组合情况难以生成）。</p><h4 id="4-2-1-等价划分"><a href="#4-2-1-等价划分" class="headerlink" title="4.2.1 等价划分"></a>4.2.1 等价划分</h4><ol><li>每个测试用例都必须体现尽可能多的不同的输入情况，以使最大限度地减少测试所需的全部用例的数量。</li><li>应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类，这样就可以合理地假设（但是，显然不能绝对肯定）测试每个等价类的代表性数据等同于测试该类的其他任何数据。</li></ol><p>上面两种思想形成了称为等价划分的黑盒测试方法。第二种思想可以用来设计一个“令人感兴趣的”输入条件集合以供测试，而第一个思想可以随后用来设计涵盖这些状态的一个最小测试用例集。</p><p>使用等价划分方法设计测试用例主要有两个步骤：（1）确定等价类；（2）生成测试用例。</p><h4 id="4-2-3-边界值分析"><a href="#4-2-3-边界值分析" class="headerlink" title="4.2.3 边界值分析"></a>4.2.3 边界值分析</h4><p><strong>考虑了边界条件的测试用例与其他没有考虑边界条件的测试用例相比，具有更高的测试回报率。</strong>所谓边界条件，是指输入和输出等价类中那些恰好处于边界、或超过边界、或在边界以下的状态。</p><p>边界值分析方法与等价划分方法存在两方面的不同：1.与从等价类中挑选出任意一个元素作为代表不同，边界值分析需要选择一个或多个元素，以便等价类的每个边界都经过一次测试。2.与仅仅关注输入条件（输入空间）不同，还需要考虑从结果空间（输出等价类）设计测试用例。</p><p>==通用指南==：</p><p>1.如果输入条件规定了一个输入值范围，那么应针对范围的边界设计测试用例，针对刚刚越界的情况设计无效输入测试用例。</p><p>2.如果输入条件规定了输入值的数量，那么应针对最小数量输入值、最大数量输入值，以及比最小数量少一个、比最大数量多一个的情况设计测试用例。</p><p>3.对每个输出条件应用指南1。</p><p>4.对每个输出条件应用指南2。</p><p>5.如果程序的输入或输出是一个有序序列（例如顺序的文件、线性列表或表格），则应特别注意该序列的第一个和最后一个元素。</p><p>6.此外，发挥聪明才智找出其他的边界条件。</p><h3 id="4-3-错误猜测"><a href="#4-3-错误猜测" class="headerlink" title="4.3 错误猜测"></a>4.3 错误猜测</h3><p>错误猜测主要是一项依赖于直觉的非正规的过程，因此很难描述出这种方法的规程。其基本思想是列举出可能犯的错误或错误易发情况的清单，然后依据清单来编写测试用例。</p><h2 id="第5章-模块（单元）测试"><a href="#第5章-模块（单元）测试" class="headerlink" title="第5章 模块（单元）测试"></a>第5章 模块（单元）测试</h2><p>模块测试的目的是将模块的功能与定义模块的功能规格说明或接口规格说明进行比较。</p><h3 id="5-1-测试用例设计"><a href="#5-1-测试用例设计" class="headerlink" title="5.1 测试用例设计"></a>5.1 测试用例设计</h3><p>在为模块测试设计的测试用例时，需要使用两种类型的信息：<strong>模块的规格说明</strong>和<strong>模块的源代码</strong>。规格说明一般都规定了模块的输入和输出参数以及模块的功能。模块测试总体上是面向白盒测试的。</p><p>模块测试中测试用例的设计过程如下：使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例。</p><h3 id="5-2-增量测试"><a href="#5-2-增量测试" class="headerlink" title="5.2 增量测试"></a>5.2 增量测试</h3><p>软件测试是否应先独立地测试每个模块，然后再将这些模块组装成完整的程序？还是先将下一步要测试的模块组装到测试完成的模块集合中，然后再进行测试？第一种方法称为非增量测试或<strong>“崩溃（big-bang）”测试</strong>，而第二种方法称为<strong>增量测试或集成</strong>。</p><p>1.非增量测试所需的工作量要多一些。</p><p>2.如果使用了增量测试，可以较早地发现模块中与不匹配接口、不正确假设相关的编程错误。</p><p>3.因此，如果使用了增量测试，调试会进行得容易一些。</p><p>4.增量测试会将测试进行得更彻底。</p><p>5.非增量测试所占用的机器时间显得少一些。</p><p>6.模块测试阶段开始时，如果使用的是非增量测试，就会有更多的机会进行并行操作（也就是说，所有的模块可以同时测试）。</p><h3 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h3><p>单元测试用来检查软件的功能实现是否满足了规格说明书要求。</p><p>彻底的单元测试设计需要使用增量策略，如自顶而下以及自底而上的技术。</p><h2 id="第6章-更高级别的测试"><a href="#第6章-更高级别的测试" class="headerlink" title="第6章 更高级别的测试"></a>第6章 更高级别的测试</h2><p>==·模块测试的目的是发现程序模块与其接口规格说明之间的不一致。·功能测试的目的是为了证明程序未能符合其外部规格说明。·系统测试的目的是为了证明软件产品与其初始目标不一致。==</p><h3 id="6-1-功能测试"><a href="#6-1-功能测试" class="headerlink" title="6.1 功能测试"></a>6.1 功能测试</h3><p>功能测试是一个试图发现程序与其外部规格说明之间存在不一致的过程。外部规格说明是一份从最终用户的角度对程序行为的精确描述。</p><h3 id="6-6-测试结束准则"><a href="#6-6-测试结束准则" class="headerlink" title="6.6 测试结束准则"></a>6.6 测试结束准则</h3><p>最常见的两个准则是：1.用完了安排的测试时间后，测试便结束。2.当执行完所有测试用例都未发现错误，测试便结束。也就是说，当所有的测试用例不成功时便结束。</p><h4 id="7-2-1-测试用户的选择"><a href="#7-2-1-测试用户的选择" class="headerlink" title="7.2.1 测试用户的选择"></a>7.2.1 测试用户的选择</h4><p>如果用户需要太长时间来接受某一软件，这将直接导致该项目的失败。</p><h4 id="7-2-5-何时收工，还是多多益善"><a href="#7-2-5-何时收工，还是多多益善" class="headerlink" title="7.2.5 何时收工，还是多多益善"></a>7.2.5 何时收工，还是多多益善</h4><p>检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”，这其中有着微妙的差别。</p><h2 id="第8章-调试"><a href="#第8章-调试" class="headerlink" title="第8章 调试"></a>第8章 调试</h2><p>==所谓成功的测试，是指它可以证明程序没有实现预期的功能。==调试是一个包含两个步骤的过程，从执行了一个成功的测试用例、发现了一个问题之后开始。第一步，确定程序中可疑错误的准确性质和位置；第二步，修改错误。</p><h3 id="8-1-暴力法调试"><a href="#8-1-暴力法调试" class="headerlink" title="8.1 暴力法调试"></a>8.1 暴力法调试</h3><p>暴力调试方法可至少被划分为三种类型：1.利用内存信息输出来调试。2.根据一般的“在程序中插入打印语句”建议来调试。3.使用自动化的调试工具进行调试。</p><h4 id="8-6-1-定位错误的原则"><a href="#8-6-1-定位错误的原则" class="headerlink" title="8.6.1 定位错误的原则"></a>8.6.1 定位错误的原则</h4><p>在试过了其他的方法之后才使用调试工具，并将其作为头脑思考的辅助手段，而不是替代手段。正如本章前面所述，调试工具比如输出和跟踪工具，代表的是一种偶然的调试方法。经验证明，不使用工具的人即使在调试并不熟悉的程序时，也要比使用工具的人更为成功。</p><p>调试程序的新手最常犯的错误是为了解决问题而试验性地去修改程序。调试者可能会说：“我知道什么出错了，所以我要改动一下DO语句，看一看会发生什么”。这种纯粹是无计划的方法甚至不属于调试；它表现的是盲目的行动。它获得成功的机会不仅很小，而且还会将新的错误引入程序中，使问题更为复杂。</p><h2 id="第9章-敏捷开发模式下的测试"><a href="#第9章-敏捷开发模式下的测试" class="headerlink" title="第9章 敏捷开发模式下的测试"></a>第9章 敏捷开发模式下的测试</h2><p>图　9-1　《敏捷软件开发宣言》</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_96" alt="figure_0155_0100"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_97" alt="figure_0156_0101"></p><h1 id="其他好句"><a href="#其他好句" class="headerlink" title="其他好句"></a>其他好句</h1><ul><li>在一个典型的编程项目中，软件测试或系统测试大约占用50%的项目时间和超过50%的总成本。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》笔记</title>
      <link href="/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="本书特色"><a href="#本书特色" class="headerlink" title="本书特色"></a>本书特色</h3><p>如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_323" alt="img"></p><h3 id="1-11-UML类图"><a href="#1-11-UML类图" class="headerlink" title="1.11 UML类图"></a>1.11 UML类图</h3><p>继承关系用空心三角形+实线来表示</p><p>实现接口用空心三角形+虚线来表示。</p><p>关联关系用实线箭头来表示。</p><p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。聚合关系用空心的菱形+实线箭头来表示。</p><p>合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><p>合成关系用实心的菱形+实线箭头来表示</p><p>合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例</p><p>依赖关系（Dependency），用虚线箭头来表示。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_24" alt="img"></p><h3 id="2-4-策略模式"><a href="#2-4-策略模式" class="headerlink" title="2.4 策略模式"></a>2.4 策略模式</h3><p><strong>策略模式（Strategy）</strong>：<mark>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_47" alt="img"></p><h3 id="2-7-策略模式解析"><a href="#2-7-策略模式解析" class="headerlink" title="2.7 策略模式解析"></a>2.7 策略模式解析</h3><ul><li><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p></li><li><p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能</p></li><li><p>策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试</p></li><li><p>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句</p></li><li><p>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性</p></li><li><p>在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象任何需求的变更都是需要成本的。</p></li></ul><h3 id="3-4-单一职责原则"><a href="#3-4-单一职责原则" class="headerlink" title="3.4 单一职责原则"></a>3.4 单一职责原则</h3><p><strong>单一职责原则（SRP）</strong>：<mark>就一个类而言，应该仅有一个引起它变化的原因。<mark></mark></mark></p><h3 id="3-5-单一职责原则说明"><a href="#3-5-单一职责原则说明" class="headerlink" title="3.5 单一职责原则说明"></a>3.5 单一职责原则说明</h3><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏</p><p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</p><p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p><h3 id="4-2-开放-封闭原则"><a href="#4-2-开放-封闭原则" class="headerlink" title="4.2 开放-封闭原则"></a>4.2 开放-封闭原则</h3><p><strong>开放-封闭原则</strong>：<mark>对于扩展是开放的（Open for extension）’，另一个是说‘对于更改是封闭的（Closed for modification）。<mark></mark></mark></p><p>怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？[ASD]</p><h3 id="4-3-开放-封闭原则说明"><a href="#4-3-开放-封闭原则说明" class="headerlink" title="4.3 开放-封闭原则说明"></a>4.3 开放-封闭原则说明</h3><ul><li><p>无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化[ASD]。</p></li><li><p>等到变化发生时立即采取行动</p></li><li><p>在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[</p></li><li><p>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。</p></li><li><p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难[ASD]。</p></li><li><p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]。</p></li></ul><h3 id="5-3-依赖倒转原则"><a href="#5-3-依赖倒转原则" class="headerlink" title="5.3 依赖倒转原则"></a>5.3 依赖倒转原则</h3><p><strong>依赖倒转原则</strong>：<mark>原话解释是抽象不应该依赖细节，细节应该依赖于抽象，这话绕口，说白了，就是要针对接口编程，不要对实现编程。<mark></mark></mark></p><p>A．高层模块不应该依赖低层模块。两个都应该依赖抽象。B．抽象不应该依赖细节。细节应该依赖抽象。</p><ul><li>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了</li></ul><h3 id="5-4-里氏代换原则"><a href="#5-4-里氏代换原则" class="headerlink" title="5.4 里氏代换原则"></a>5.4 里氏代换原则</h3><p><strong>里氏代换原则</strong>：<mark>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。<mark></mark></mark></p><p><strong>里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。[ASD]</strong></p><ul><li><p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p></li><li><p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p></li></ul><p>依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。</p><h3 id="6-4-装饰模式"><a href="#6-4-装饰模式" class="headerlink" title="6.4 装饰模式"></a>6.4 装饰模式</h3><p><strong>装饰模式（Decorator）</strong>:<mark>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_63" alt="img"></p><p>Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。</p><p>装饰模式是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中</p><p>如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_63" alt="img"></p><h3 id="6-6-装饰模式总结"><a href="#6-6-装饰模式总结" class="headerlink" title="6.6 装饰模式总结"></a>6.6 装饰模式总结</h3><ul><li><p>装饰模式是为已有功能动态地添加更多功能的一种方式。</p></li><li><p>当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为，在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，就像你起初的那个‘人’类，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。而装饰模式却提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了</p></li><li><p><strong>优点</strong>：1.把类中的装饰功能从类中搬移去除，这样可以简化原有的类。2.有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。</p></li></ul><h3 id="7-5-代理模式"><a href="#7-5-代理模式" class="headerlink" title="7.5 代理模式"></a>7.5 代理模式</h3><p><strong>代理模式（Proxy）</strong>:<mark>为其他对象提供一种代理以控制对这个对象的访问。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_76" alt="img"></p><h3 id="7-6-代理模式应用"><a href="#7-6-代理模式应用" class="headerlink" title="7.6 代理模式应用"></a>7.6 代理模式应用</h3><p>以下为几种应用的场合：</p><ul><li><p><strong>远程代理</strong>，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实</p></li><li><p><strong>虚拟代理</strong>，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象</p></li><li><p><strong>安全代理</strong>，用来控制真实对象访问时的权限</p></li><li><p><strong>智能指引</strong>，是指当调用真实的对象时，代理处理另外一些事</p></li></ul><h3 id="8-4-简单工厂vs-工厂方法"><a href="#8-4-简单工厂vs-工厂方法" class="headerlink" title="8.4 简单工厂vs.工厂方法"></a>8.4 简单工厂vs.工厂方法</h3><p><strong>简单工厂的实现</strong></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_77" alt="img"></p><p><strong>工厂方法的实现</strong>（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_79" alt="img"></p><ul><li><p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p></li><li><p>我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，变成了一个工厂抽象接口和多个具体生成对象的工厂</p></li><li><p>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端</p></li></ul><h3 id="9-3-原型模式"><a href="#9-3-原型模式" class="headerlink" title="9.3 原型模式"></a>9.3 原型模式</h3><p><strong>原型模式（Prototype）</strong>:<mark>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_86" alt="img"></p><p>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。</p><h3 id="9-4原型模式的优点"><a href="#9-4原型模式的优点" class="headerlink" title="9.4原型模式的优点"></a>9.4原型模式的优点</h3><ul><li><p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高</p></li><li><p>不用重新初始化对象，而是动态地获得对象运行时的状态。</p></li></ul><h3 id="10-4-模板方法模式"><a href="#10-4-模板方法模式" class="headerlink" title="10.4 模板方法模式"></a>10.4 模板方法模式</h3><p>重复=易错+难改</p><p><strong>模板方法模式</strong>:<mark>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_106" alt="img"></p><h3 id="10-5-模板方法模式特点"><a href="#10-5-模板方法模式特点" class="headerlink" title="10.5 模板方法模式特点"></a>10.5 模板方法模式特点</h3><ul><li><p>模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。</p></li><li><p>模板方法模式就是提供了一个很好的代码复用平台。</p></li><li><p>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p></li></ul><h3 id="11-3-迪米特法则"><a href="#11-3-迪米特法则" class="headerlink" title="11.3 迪米特法则"></a>11.3 迪米特法则</h3><p><strong>迪米特法则（LoD）</strong>:<mark>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。<mark></mark></mark></p><ul><li><p>迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权。</p></li><li><p>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</p></li></ul><h3 id="12-5-何时使用外观模式"><a href="#12-5-何时使用外观模式" class="headerlink" title="12.5 何时使用外观模式"></a>12.5 何时使用外观模式</h3><p><strong>外观模式（Facade）</strong>:<mark>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_114" alt="img"></p><p>在设计初期阶段，应该要有意识的将不同的两个层分离</p><h2 id="第13章-好菜每回味不同——建造者模式"><a href="#第13章-好菜每回味不同——建造者模式" class="headerlink" title="第13章 好菜每回味不同——建造者模式"></a>第13章 好菜每回味不同——建造者模式</h2><h3 id="13-1-炒面没放盐"><a href="#13-1-炒面没放盐" class="headerlink" title="13.1 炒面没放盐"></a>13.1 炒面没放盐</h3><p>依赖倒转原则？抽象不应该依赖细节，细节应该依赖于抽象</p><h3 id="13-4-建造者模式"><a href="#13-4-建造者模式" class="headerlink" title="13.4 建造者模式"></a>13.4 建造者模式</h3><p>如果你需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们需要应用于一个设计模式，‘建造者（Builder）模式’，又叫生成器模式。</p><p><strong>建造者模式（Builder）</strong>:<mark>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_123" alt="img"></p><p>指挥者（Director）一个很重要的类，用它来控制建造过程，也用它来隔离用户与建造过程的关联。”</p><h3 id="13-5-建造者模式应用"><a href="#13-5-建造者模式应用" class="headerlink" title="13.5 建造者模式应用"></a>13.5 建造者模式应用</h3><p>主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。</p><h3 id="14-5-观察者模式"><a href="#14-5-观察者模式" class="headerlink" title="14.5 观察者模式"></a>14.5 观察者模式</h3><p><strong>观察者模式</strong>:<mark>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_136" alt="img"></p><h3 id="14-6-观察者模式特点"><a href="#14-6-观察者模式特点" class="headerlink" title="14.6 观察者模式特点"></a>14.6 观察者模式特点</h3><ul><li><p>动机：将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便</p></li><li><p>适用场景：当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。另外，当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p></li><li><p>解释：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p></li></ul><h3 id="14-9-事件委托说明"><a href="#14-9-事件委托说明" class="headerlink" title="14.9 事件委托说明"></a>14.9 事件委托说明</h3><p><strong>委托就是一种引用方法的类型。</strong>一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。</p><ul><li><p>一个委托可以搭载多个方法，所有方法被依次唤起。更重要的是，它可以使得委托对象所搭载的方法并不需要属于同一个类。</p></li><li><p>委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。</p></li></ul><h2 id="第15章-就不能不换DB吗？——抽象工厂模式"><a href="#第15章-就不能不换DB吗？——抽象工厂模式" class="headerlink" title="第15章 就不能不换DB吗？——抽象工厂模式"></a>第15章 就不能不换DB吗？——抽象工厂模式</h2><h3 id="15-5-抽象工厂模式"><a href="#15-5-抽象工厂模式" class="headerlink" title="15.5 抽象工厂模式"></a>15.5 抽象工厂模式</h3><p><strong>抽象工厂模式（Abstract Factory）</strong>:<mark>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_150" alt="img"></p><h3 id="15-6-抽象工厂模式的优点与缺点"><a href="#15-6-抽象工厂模式的优点与缺点" class="headerlink" title="15.6 抽象工厂模式的优点与缺点"></a>15.6 抽象工厂模式的优点与缺点</h3><ul><li><p>好处便是易于交换产品系列，由于具体工厂类，例如IFactory factory =new AccessFactory()，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置</p></li><li><p>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</p></li></ul><p><strong>编程是门艺术，大批量的改动，显然是非常丑陋的做法。</strong>所以抽象工厂模式很酷。</p><h3 id="16-5-状态模式"><a href="#16-5-状态模式" class="headerlink" title="16.5 状态模式"></a>16.5 状态模式</h3><p><strong>状态模式（State）</strong>:<mark>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_163" alt="img"></p><p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p><h3 id="16-6-状态模式好处与用处"><a href="#16-6-状态模式好处与用处" class="headerlink" title="16.6 状态模式好处与用处"></a>16.6 状态模式好处与用处</h3><p><mark>状态模式的好处<mark></mark></mark></p><ul><li><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p></li><li><p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。</p></li><li><p>状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖</p></li></ul><p><mark>状态模式的用处<mark></mark></mark></p><p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式</p><h3 id="17-2-适配器模式"><a href="#17-2-适配器模式" class="headerlink" title="17.2 适配器模式"></a>17.2 适配器模式</h3><p><strong>适配器模式（Adapter）</strong>:<mark>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<mark></mark></mark></p><p>用途：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_173" alt="img"></p><p>两种类型：类适配器模式和对象适配器模式</p><h3 id="17-3-何时使用适配器模式"><a href="#17-3-何时使用适配器模式" class="headerlink" title="17.3 何时使用适配器模式"></a>17.3 何时使用适配器模式</h3><ul><li><p>使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。即两个类所做的事情相同或相似，但是具有不同的接口时要使用它。</p></li><li><p>在双方都不太容易修改的时候再使用适配器模式适配。</p></li></ul><h3 id="18-4-备忘录模式基本代码"><a href="#18-4-备忘录模式基本代码" class="headerlink" title="18.4 备忘录模式基本代码"></a>18.4 备忘录模式基本代码</h3><p><strong>备忘录（Memento）</strong>：<mark>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_186" alt="img"></p><p>Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</p><ul><li><p>如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态</p></li><li><p>使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来</p></li><li><p>当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原</p></li></ul><h3 id="19-2-组合模式"><a href="#19-2-组合模式" class="headerlink" title="19.2 组合模式"></a>19.2 组合模式</h3><p><strong>组合模式（Composite）</strong>:<mark>将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_196" alt="img"></p><h3 id="19-3-透明方式与安全方式"><a href="#19-3-透明方式与安全方式" class="headerlink" title="19.3 透明方式与安全方式"></a>19.3 透明方式与安全方式</h3><p><strong>透明方式</strong>，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。</p><p><strong>安全方式</strong>，也就是在Component接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法，这样做就不会出现刚才提到的问题，不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</p><h3 id="19-4-何时使用组合模式"><a href="#19-4-何时使用组合模式" class="headerlink" title="19.4 何时使用组合模式"></a>19.4 何时使用组合模式</h3><p>需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。</p><h3 id="19-6-组合模式好处"><a href="#19-6-组合模式好处" class="headerlink" title="19.6 组合模式好处"></a>19.6 组合模式好处</h3><p>组合模式这样定义了类似包含人力资源部和财务部这些基本对象和分公司、办事处等组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。</p><h3 id="20-2-迭代器模式"><a href="#20-2-迭代器模式" class="headerlink" title="20.2 迭代器模式"></a>20.2 迭代器模式</h3><p><strong>迭代器模式（Iterator）</strong>:<mark>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_203" alt="img"></p><p>当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式</p><p>你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。</p><p>为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。</p><h3 id="20-4-迭代器模式的好处"><a href="#20-4-迭代器模式的好处" class="headerlink" title="20.4 迭代器模式的好处"></a>20.4 迭代器模式的好处</h3><p>迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h3 id="21-3-生还是不生是自己的责任"><a href="#21-3-生还是不生是自己的责任" class="headerlink" title="21.3 生还是不生是自己的责任"></a>21.3 生还是不生是自己的责任</h3><p>所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。</p><h3 id="21-4-单例模式"><a href="#21-4-单例模式" class="headerlink" title="21.4 单例模式"></a>21.4 单例模式</h3><p><strong>单例模式（Singleton）</strong>:<mark>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_220" alt="img"></p><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p><p>单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</p><h3 id="22-2-紧耦合的程序演化"><a href="#22-2-紧耦合的程序演化" class="headerlink" title="22.2 紧耦合的程序演化"></a>22.2 紧耦合的程序演化</h3><p>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p><p>在面向对象设计中，我们还有一个很重要的设计原则，那就是合成／聚合复用原则。即<strong>优先使用对象合成／聚合，而不是类继承。</strong></p><h3 id="22-3-合成／聚合复用原则"><a href="#22-3-合成／聚合复用原则" class="headerlink" title="22.3 合成／聚合复用原则"></a>22.3 合成／聚合复用原则</h3><p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样</p><p><strong>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</strong></p><h3 id="22-5-桥接模式"><a href="#22-5-桥接模式" class="headerlink" title="22.5 桥接模式"></a>22.5 桥接模式</h3><p><strong>桥接模式（Bridge）</strong>:<mark>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<mark></mark></mark></p><p>什么叫抽象与它的实现分离，这并不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_233" alt="img"></p><h3 id="23-6-命令模式"><a href="#23-6-命令模式" class="headerlink" title="23.6 命令模式"></a>23.6 命令模式</h3><p><strong>命令模式（Command）</strong>:<mark>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_246" alt="img"></p><h3 id="23-7-命令模式作用"><a href="#23-7-命令模式作用" class="headerlink" title="23.7 命令模式作用"></a>23.7 命令模式作用</h3><p>第一，它能较容易地设计一个命令队列；</p><p>第二，在需要的情况下，可以较容易地将命令记入日志；</p><p>第三，允许接收请求的一方决定是否要否决请求。</p><p>第四，可以容易地实现对请求的撤销和重做；</p><p>第五，由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。其实还有最关键的优点就是命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</p><p><strong>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。</strong>如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。</p><h3 id="24-3-职责链模式"><a href="#24-3-职责链模式" class="headerlink" title="24.3 职责链模式"></a>24.3 职责链模式</h3><p><strong>职责链模式（Chain of Responsibility）</strong>：<mark>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_249" alt="img"></p><h3 id="24-4-职责链的好处"><a href="#24-4-职责链的好处" class="headerlink" title="24.4 职责链的好处"></a>24.4 职责链的好处</h3><ul><li><p>当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p></li><li><p>接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。</p></li><li><p>随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。</p></li><li><p>需要注意的是：一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理</p></li></ul><h2 id="第25章-世界需要和平——中介者模式"><a href="#第25章-世界需要和平——中介者模式" class="headerlink" title="第25章 世界需要和平——中介者模式"></a>第25章 世界需要和平——中介者模式</h2><h3 id="25-2-中介者模式"><a href="#25-2-中介者模式" class="headerlink" title="25.2 中介者模式"></a>25.2 中介者模式</h3><p><strong>中介者模式（Mediator）</strong>:<mark>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_263" alt="img"></p><h3 id="25-4-中介者模式优缺点"><a href="#25-4-中介者模式优缺点" class="headerlink" title="25.4 中介者模式优缺点"></a>25.4 中介者模式优缺点</h3><ul><li><p>中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了‘多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。</p></li><li><p>Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator</p></li><li><p>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</p></li><li><p>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</p></li></ul><p><mark>应用场景<mark></mark></mark></p><ul><li>中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。</li></ul><h3 id="26-2-享元模式"><a href="#26-2-享元模式" class="headerlink" title="26.2 享元模式"></a>26.2 享元模式</h3><p><strong>享元模式（Flyweight）</strong>:<mark>运用共享技术有效地支持大量细粒度的对象。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_272" alt="img"></p><h3 id="26-4-内部状态与外部状态"><a href="#26-4-内部状态与外部状态" class="headerlink" title="26.4 内部状态与外部状态"></a>26.4 内部状态与外部状态</h3><p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。</p><h3 id="26-5-享元模式应用"><a href="#26-5-享元模式应用" class="headerlink" title="26.5 享元模式应用"></a>26.5 享元模式应用</h3><p>如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</p><p>像围棋，一盘棋理论上有361个空位可以放棋子，那如果用常规的面向对象方式编程，每盘棋都可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，毕竟内存空间还是有限的。如果用了享元模式来处理棋子，那么棋子对象可以减少到只有两个实例，结果……你应该明白的。</p><h3 id="27-2-解释器模式（skip）"><a href="#27-2-解释器模式（skip）" class="headerlink" title="27.2 解释器模式（skip）"></a>27.2 解释器模式（skip）</h3><p><strong>解释器模式（interpreter）</strong>:<mark>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_280" alt="img"></p><p>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题</p><h3 id="27-3-解释器模式好处"><a href="#27-3-解释器模式好处" class="headerlink" title="27.3 解释器模式好处"></a>27.3 解释器模式好处</h3><ul><li><p>当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p></li><li><p>容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写</p></li><li><p>解释器模式也有不足的，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理</p></li></ul><h3 id="28-5-访问者模式"><a href="#28-5-访问者模式" class="headerlink" title="28.5 访问者模式"></a>28.5 访问者模式</h3><p><strong>访问者模式（Visitor）</strong>:<mark>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_296" alt="img"></p><p>访问者模式适用于数据结构相对稳定的系统？</p><p>它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化</p><p>访问者模式的目的是要把处理从数据结构分离出来。</p><p>有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。</p><p>访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。</p><p>那访问者的缺点其实也就是使增加新的数据结构变得困难了。</p><p>大多时候你并不需要访问者模式，但当一旦你需要访问者模式时，那就是真的需要它了。</p><h3 id="29-7-行为型模式二组比赛"><a href="#29-7-行为型模式二组比赛" class="headerlink" title="29.7 行为型模式二组比赛"></a>29.7 行为型模式二组比赛</h3><p>如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题</p><p>面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有许多连接。也就是说，有可能每一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难</p><p>访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。</p><p>继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D，从而给它以不同的行为。但这样会将行为硬行编制到父类A当中，而将算法的实现与类A的实现混合起来，从而使得类A难以理解、难以维护和难以扩展，而且还不能动态地改变算法。仔细分析会发现，它们之间的唯一差别是它们所使用的算法或行为，将算法封装在独立的策略Strategy类中使得你可以独立于其类A改变它，使它易于切换、易于理解、易于扩展。</p><p>使用备忘录就不会出现这个问题，它可以避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界。</p><p>迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。</p><h3 id="29-8-决赛"><a href="#29-8-决赛" class="headerlink" title="29.8 决赛"></a>29.8 决赛</h3><p>只要是在做面向对象的开发，创建对象的工作不可避免。创建对象时，负责创建的实体通常需要了解要创建的是哪个具体的对象，以及何时创建这个而非那个对象的规则。而我们如果希望遵循开放-封闭原则、依赖倒转原则和里氏代换原则，那使用对象时，就不应该知道所用的是哪一个特选的对象。此时就需要‘对象管理者’工厂来负责此事。</p><p>在创建对象时，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但它们也更加复杂，通常，设计是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。</p><p>工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂。</p><h1 id="其他好句"><a href="#其他好句" class="headerlink" title="其他好句"></a>其他好句</h1><ul><li>一个程序员如果从来没有熬夜写程序的经历，不能算是一个好程序员，因为他没有痴迷过，所以他不会有大成就。</li><li>面向对象设计其实就是希望做到代码的责任分解。</li><li>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。</li><li>代码无错未必优。</li><li>只要真正深入地理解了设计原则，很多设计模式其实就是原则的应用而已，或许在不知不觉中就在使用设计模式了。</li><li>尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性了。大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。</li><li>MVC是多种模式的综合应用，应该算是一种架构模式</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达Prompt网课笔记</title>
      <link href="/2023/06/24/%E5%90%B4%E6%81%A9%E8%BE%BEPrompt%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/24/%E5%90%B4%E6%81%A9%E8%BE%BEPrompt%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="吴恩达ChatGPT网课笔记Prompt-Engineering——训练ChatGPT前请先训练自己"><a href="#吴恩达ChatGPT网课笔记Prompt-Engineering——训练ChatGPT前请先训练自己" class="headerlink" title="吴恩达ChatGPT网课笔记Prompt Engineering——训练ChatGPT前请先训练自己"></a>吴恩达ChatGPT网课笔记Prompt Engineering——训练ChatGPT前请先训练自己</h1><p>主要是吴恩达的网课，还有部分github的<a href="https://github.com/datawhalechina/prompt-engineering-for-developers">prompt-engineering-for-developers</a>项目，以及部分自己的经验。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" alt="img1"></p><h1 id="一、常用使用技巧"><a href="#一、常用使用技巧" class="headerlink" title="一、常用使用技巧"></a>一、常用使用技巧</h1><ol><li>prompt最好是英文的，如果是中文的prompt，大概会是英文的1.5~2倍的token数量。一方面成本提升，另一方面对于较长的prompt可能会超过上下文上限。</li></ol><h2 id="原则1：编写简洁和具体的介绍"><a href="#原则1：编写简洁和具体的介绍" class="headerlink" title="原则1：编写简洁和具体的介绍"></a>原则1：编写简洁和具体的介绍</h2><h2 id="策略1：使用分隔符"><a href="#策略1：使用分隔符" class="headerlink" title="策略1：使用分隔符"></a>策略1：使用分隔符</h2><ol><li><p>“””</p></li><li><p><mark>```<mark></mark></mark></p></li><li><p><code>- - -</code></p></li><li><p>&lt; &gt;</p></li><li><p>XML 标签：<code>&lt;tag&gt; &lt;/tag&gt;</code></p></li></ol><p>下图是一个例子，黄色部分其实也是需要总结的内容，不过如果没用三个单引号的分隔符，可能chatGPThuiba 黄色部分当成是一个命令，而不是要总结的文本：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504180941770.png" alt="image-20230504180941770"></p><h2 id="策略2：要求结构化输出"><a href="#策略2：要求结构化输出" class="headerlink" title="策略2：要求结构化输出"></a>策略2：要求结构化输出</h2><p>可以要求html、JSON这样的。在提问的时候可以说</p><blockquote><p>请帮我生成一列编造的书籍名称，作者，书的id，请用JSON的格式提供他们，以下是他们应该包含的键:book_id,title,author,genre.</p></blockquote><h2 id="策略3：要求模型检查是否满足条件"><a href="#策略3：要求模型检查是否满足条件" class="headerlink" title="策略3：要求模型检查是否满足条件"></a>策略3：要求模型检查是否满足条件</h2><p>如果任务存在假设没用满足，我们可以告诉模型首先检查这些假设,还可以考虑一些边界条件。</p><blockquote><p>你将得到一个文本是用”””引用的格式给出的，如果他包含了一系列的解释，请重写为&lt;结构化数据&gt;,如果不包含指示，那么就打印:”没有提供步骤</p></blockquote><h1 id="少量训练提示"><a href="#少量训练提示" class="headerlink" title="少量训练提示"></a>少量训练提示</h1><p>在要求模型执行任务之前，首先提供成功执行任务的示例。比如下图的例子，首先提供了一个child想知道耐心的问题，然后我们给出了grandparent应该回答的示范，因为我们要求回答需要一致性风格，所以当child问关于resilience的时候，chatGPT也应该给出相似的答案。</p><p> <img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504181612462.png" alt="image-20230504181612462"></p><h1 id="原则2：给模型思考的时间"><a href="#原则2：给模型思考的时间" class="headerlink" title="原则2：给模型思考的时间"></a>原则2：给模型思考的时间</h1><h2 id="策略1：具体完成任务的步骤"><a href="#策略1：具体完成任务的步骤" class="headerlink" title="策略1：具体完成任务的步骤"></a>策略1：具体完成任务的步骤</h2><p>如下图的例子，prompt中就给出了他应该执行的步骤。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504181900773.png" alt="image-20230504181900773"></p><p>下面是第二个例子，要求更具体一些：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182214341.png" alt="image-20230504182214341"></p><h2 id="策略2：指示模型在匆忙作出结论之前思考解决方案"><a href="#策略2：指示模型在匆忙作出结论之前思考解决方案" class="headerlink" title="策略2：指示模型在匆忙作出结论之前思考解决方案"></a>策略2：指示模型在匆忙作出结论之前思考解决方案</h2><p>比如下面的这个例子，其实学生算的是错的，但是GPT却看不出来：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182449899.png" alt="image-20230504182449899"></p><p>然后利用策略2进行改良：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182528844.png" alt="image-20230504182528844"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182618587.png" alt="image-20230504182618587"></p><p>经过这么做后，chatGPT就有了“思考能力了”。</p><h1 id="模型局限性"><a href="#模型局限性" class="headerlink" title="模型局限性"></a>模型局限性</h1><h2 id="幻觉（Hallucination"><a href="#幻觉（Hallucination" class="headerlink" title="幻觉（Hallucination)"></a>幻觉（Hallucination)</h2><p>即使模型在训练的过程中有大量的专业知识，但是其实它并没有完全记住它所看到的信息，所以它不了解知识边界，所以他可能会尝试回答关于晦涩主题的问题时，编造一些听起来合理但是实际上是错的的内容。</p><p>​下图是一个例子：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182953634.png" alt="image-20230504182953634"></p><p>但其实并没有这个产品。</p><p><mark>一种减少幻觉的策略是要求模型首先从文本中找到任何相关的引用，然后要求它使用这些引用来回答问题，当然这只能减少，有时候源文档他也会编。。<mark></mark></mark></p><h1 id="二、迭代"><a href="#二、迭代" class="headerlink" title="二、迭代"></a>二、迭代</h1><p>一般来说，不会第一次尝试就能用到最终在引用程序中采用的提示，一般需要一个良好的迭代过程来改善。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504183445829.png" alt="image-20230504183445829"></p><p>下面是一个具体的示例，这是一个摘要椅子说明书的示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">fact_sheet_chair = """</span><br><span class="line">OVERVIEW</span><br><span class="line">- Part of a beautiful family of mid-century inspired office furniture, </span><br><span class="line">including filing cabinets, desks, bookcases, meeting tables, and more.</span><br><span class="line">- Several options of shell color and base finishes.</span><br><span class="line">- Available with plastic back and front upholstery (SWC-100) </span><br><span class="line">or full upholstery (SWC-110) in 10 fabric and 6 leather options.</span><br><span class="line">- Base finish options are: stainless steel, matte black, </span><br><span class="line">gloss white, or chrome.</span><br><span class="line">- Chair is available with or without armrests.</span><br><span class="line">- Suitable for home or business settings.</span><br><span class="line">- Qualified for contract use.</span><br><span class="line"></span><br><span class="line">CONSTRUCTION</span><br><span class="line">- 5-wheel plastic coated aluminum base.</span><br><span class="line">- Pneumatic chair adjust for easy raise/lower action.</span><br><span class="line"></span><br><span class="line">DIMENSIONS</span><br><span class="line">- WIDTH 53 CM | 20.87”</span><br><span class="line">- DEPTH 51 CM | 20.08”</span><br><span class="line">- HEIGHT 80 CM | 31.50”</span><br><span class="line">- SEAT HEIGHT 44 CM | 17.32”</span><br><span class="line">- SEAT DEPTH 41 CM | 16.14”</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">- Soft or hard-floor caster options.</span><br><span class="line">- Two choices of seat foam densities: </span><br><span class="line"> medium (1.8 lb/ft3) or high (2.8 lb/ft3)</span><br><span class="line">- Armless or 8 position PU armrests </span><br><span class="line"></span><br><span class="line">MATERIALS</span><br><span class="line">SHELL BASE GLIDER</span><br><span class="line">- Cast Aluminum with modified nylon PA6/PA66 coating.</span><br><span class="line">- Shell thickness: 10 mm.</span><br><span class="line">SEAT</span><br><span class="line">- HD36 foam</span><br><span class="line"></span><br><span class="line">COUNTRY OF ORIGIN</span><br><span class="line">- Italy</span><br><span class="line">"""</span><br><span class="line">prompt = f"""</span><br><span class="line">Your task is to help a marketing team create a </span><br><span class="line">description for a retail website of a product based </span><br><span class="line">on a technical fact sheet.</span><br><span class="line"></span><br><span class="line">Write a product description based on the information </span><br><span class="line">provided in the technical specifications delimited by </span><br><span class="line">triple backticks.</span><br><span class="line"></span><br><span class="line">Technical specifications: ```{fact_sheet_chair}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="1-期望句子短点"><a href="#1-期望句子短点" class="headerlink" title="1.期望句子短点"></a>1.期望句子短点</h2><p>直接运行的时候，会发现其摘要太长了，我们可能希望他短一点：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Your task is to help a marketing team create a </span><br><span class="line">description for a retail website of a product based </span><br><span class="line">on a technical fact sheet.</span><br><span class="line"></span><br><span class="line">Write a product description based on the information </span><br><span class="line">provided in the technical specifications delimited by </span><br><span class="line">triple backticks.</span><br><span class="line"></span><br><span class="line">Use at most 50 words.</span><br><span class="line"></span><br><span class="line">Technical specifications: ```{fact_sheet_chair}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里我门通过了<code>Use at most 50 words.</code>来进行了长度的限制，可以通过不同的方法来实现。</p><h2 id="2-让结果在我们期望的部分精确"><a href="#2-让结果在我们期望的部分精确" class="headerlink" title="2.让结果在我们期望的部分精确"></a>2.让结果在我们期望的部分精确</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Your task is to help a marketing team create a </span><br><span class="line">description for a retail website of a product based </span><br><span class="line">on a technical fact sheet.</span><br><span class="line"></span><br><span class="line">Write a product description based on the information </span><br><span class="line">provided in the technical specifications delimited by </span><br><span class="line">triple backticks.</span><br><span class="line"></span><br><span class="line">The description is intended for furniture retailers, </span><br><span class="line">so should be technical in nature and focus on the </span><br><span class="line">materials the product is constructed from.</span><br><span class="line"></span><br><span class="line">Use at most 50 words.</span><br><span class="line"></span><br><span class="line">Technical specifications: ```{fact_sheet_chair}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>这里通过下面的来实现的 :</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The description is intended for furniture retailers, </span><br><span class="line">so should be technical in nature and focus on the </span><br><span class="line">materials the product is constructed from.</span><br></pre></td></tr></tbody></table></figure><h1 id="三、摘要"><a href="#三、摘要" class="headerlink" title="三、摘要"></a>三、摘要</h1><p>下面是一个关于熊猫玩具的评论：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">prod_review = """</span><br><span class="line">Got this panda plush toy for my daughter's birthday, \</span><br><span class="line">who loves it and takes it everywhere. It's soft and \ </span><br><span class="line">super cute, and its face has a friendly look. It's \ </span><br><span class="line">a bit small for what I paid though. I think there \ </span><br><span class="line">might be other options that are bigger for the \ </span><br><span class="line">same price. It arrived a day earlier than expected, \ </span><br><span class="line">so I got to play with it myself before I gave it \ </span><br><span class="line">to her.</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>下面是一个生成摘要的评论：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Your task is to generate a short summary of a product \</span><br><span class="line">review from an ecommerce site. </span><br><span class="line"></span><br><span class="line">Summarize the review below, delimited by triple </span><br><span class="line">backticks, in at most 30 words. </span><br><span class="line"></span><br><span class="line">Review: ```{prod_review}```</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="1-生成特定需求的摘要"><a href="#1-生成特定需求的摘要" class="headerlink" title="1.生成特定需求的摘要"></a>1.生成特定需求的摘要</h2><p>通过修改提示，可以让生成一个更适用于自己业务中特定团队的摘要。下面的例子是需要一个运输和产品交付有关的摘要要求。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504184851720.png" alt="image-20230504184851720"></p><h2 id="2-提取信息的摘要"><a href="#2-提取信息的摘要" class="headerlink" title="2.提取信息的摘要"></a>2.提取信息的摘要</h2><p>比如下面的例子，因为我们要求的是提取相关信息，并且也说明是运输部门需要的，所以这里打印的结果没有给其他无用的信息，只说了这个产品的到达比期望的早了一天：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504185227612.png" alt="image-20230504185227612"></p><h2 id="3-总结多个评论"><a href="#3-总结多个评论" class="headerlink" title="3.总结多个评论"></a>3.总结多个评论</h2><p>我们有对于几种产品的评论：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">review_1 = prod_review </span><br><span class="line"></span><br><span class="line"># review for a standing lamp</span><br><span class="line">review_2 = """</span><br><span class="line">Needed a nice lamp for my bedroom, and this one \</span><br><span class="line">had additional storage and not too high of a price \</span><br><span class="line">point. Got it fast - arrived in 2 days. The string \</span><br><span class="line">to the lamp broke during the transit and the company \</span><br><span class="line">happily sent over a new one. Came within a few days \</span><br><span class="line">as well. It was easy to put together. Then I had a \</span><br><span class="line">missing part, so I contacted their support and they \</span><br><span class="line">very quickly got me the missing piece! Seems to me \</span><br><span class="line">to be a great company that cares about their customers \</span><br><span class="line">and products. </span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"># review for an electric toothbrush</span><br><span class="line">review_3 = """</span><br><span class="line">My dental hygienist recommended an electric toothbrush, \</span><br><span class="line">which is why I got this. The battery life seems to be \</span><br><span class="line">pretty impressive so far. After initial charging and \</span><br><span class="line">leaving the charger plugged in for the first week to \</span><br><span class="line">condition the battery, I've unplugged the charger and \</span><br><span class="line">been using it for twice daily brushing for the last \</span><br><span class="line">3 weeks all on the same charge. But the toothbrush head \</span><br><span class="line">is too small. I’ve seen baby toothbrushes bigger than \</span><br><span class="line">this one. I wish the head was bigger with different \</span><br><span class="line">length bristles to get between teeth better because \</span><br><span class="line">this one doesn’t.  Overall if you can get this one \</span><br><span class="line">around the $50 mark, it's a good deal. The manufactuer's \</span><br><span class="line">replacements heads are pretty expensive, but you can \</span><br><span class="line">get generic ones that're more reasonably priced. This \</span><br><span class="line">toothbrush makes me feel like I've been to the dentist \</span><br><span class="line">every day. My teeth feel sparkly clean! </span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"># review for a blender</span><br><span class="line">review_4 = """</span><br><span class="line">So, they still had the 17 piece system on seasonal \</span><br><span class="line">sale for around $49 in the month of November, about \</span><br><span class="line">half off, but for some reason (call it price gouging) \</span><br><span class="line">around the second week of December the prices all went \</span><br><span class="line">up to about anywhere from between $70-$89 for the same \</span><br><span class="line">system. And the 11 piece system went up around $10 or \</span><br><span class="line">so in price also from the earlier sale price of $29. \</span><br><span class="line">So it looks okay, but if you look at the base, the part \</span><br><span class="line">where the blade locks into place doesn’t look as good \</span><br><span class="line">as in previous editions from a few years ago, but I \</span><br><span class="line">plan to be very gentle with it (example, I crush \</span><br><span class="line">very hard items like beans, ice, rice, etc. in the \ </span><br><span class="line">blender first then pulverize them in the serving size \</span><br><span class="line">I want in the blender then switch to the whipping \</span><br><span class="line">blade for a finer flour, and use the cross cutting blade \</span><br><span class="line">first when making smoothies, then use the flat blade \</span><br><span class="line">if I need them finer/less pulpy). Special tip when making \</span><br><span class="line">smoothies, finely cut and freeze the fruits and \</span><br><span class="line">vegetables (if using spinach-lightly stew soften the \ </span><br><span class="line">spinach then freeze until ready for use-and if making \</span><br><span class="line">sorbet, use a small to medium sized food processor) \ </span><br><span class="line">that you plan to use that way you can avoid adding so \</span><br><span class="line">much ice if at all-when making your smoothie. \</span><br><span class="line">After about a year, the motor was making a funny noise. \</span><br><span class="line">I called customer service but the warranty expired \</span><br><span class="line">already, so I had to buy another one. FYI: The overall \</span><br><span class="line">quality has gone done in these types of products, so \</span><br><span class="line">they are kind of counting on brand recognition and \</span><br><span class="line">consumer loyalty to maintain sales. Got it in about \</span><br><span class="line">two days.</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">reviews = [review_1, review_2, review_3, review_4]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们可以通过一个循环来做提示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(reviews)):</span><br><span class="line">    prompt = f"""</span><br><span class="line">    Your task is to generate a short summary of a product \ </span><br><span class="line">    review from an ecommerce site. </span><br><span class="line"></span><br><span class="line">    Summarize the review below, delimited by triple \</span><br><span class="line">    backticks in at most 20 words. </span><br><span class="line"></span><br><span class="line">    Review: ```{reviews[i]}```</span><br><span class="line">    """</span><br><span class="line"></span><br><span class="line">    response = get_completion(prompt)</span><br><span class="line">    print(i, response, "\n")</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="四、推断"><a href="#四、推断" class="headerlink" title="四、推断"></a>四、推断</h1><p>下面是一个关于灯的例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lamp_review = """</span><br><span class="line">Needed a nice lamp for my bedroom, and this one had \</span><br><span class="line">additional storage and not too high of a price point. \</span><br><span class="line">Got it fast.  The string to our lamp broke during the \</span><br><span class="line">transit and the company happily sent over a new one. \</span><br><span class="line">Came within a few days as well. It was easy to put \</span><br><span class="line">together.  I had a missing part, so I contacted their \</span><br><span class="line">support and they very quickly got me the missing piece! \</span><br><span class="line">Lumina seems to me to be a great company that cares \</span><br><span class="line">about their customers and products!!</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><h2 id="1-推断单个情感"><a href="#1-推断单个情感" class="headerlink" title="1.推断单个情感"></a>1.推断单个情感</h2><p>然后这里讲写一个提示来进行情绪分类：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">What is the sentiment of the following product review, </span><br><span class="line">which is delimited with triple backticks?</span><br><span class="line"></span><br><span class="line">Give your answer as a single word, either "positive" \</span><br><span class="line">or "negative".</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p><code>Give your answer as a single word, either "positive" \ or "negative".</code>通过这句话使得了给出简洁的结果(positive)。</p><h2 id="2-推断多个情感（多标签分类）"><a href="#2-推断多个情感（多标签分类）" class="headerlink" title="2.推断多个情感（多标签分类）"></a>2.推断多个情感（多标签分类）</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Identify a list of emotions that the writer of the \</span><br><span class="line">following review is expressing. Include no more than \</span><br><span class="line">five items in the list. Format your answer as a list of \</span><br><span class="line">lower-case words separated by commas.</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h2 id="3-识别愤怒情感"><a href="#3-识别愤怒情感" class="headerlink" title="3.识别愤怒情感"></a>3.识别愤怒情感</h2><p>对于评论的例子来说，可能我们会特别的关注是否有人的评论有特别愤怒倾向的倾斜，那么我们或许需要对这方面做更加特别的注意:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Is the writer of the following review expressing anger?\</span><br><span class="line">The review is delimited with triple backticks. \</span><br><span class="line">Give your answer as either yes or no.</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h2 id="4-信息提取"><a href="#4-信息提取" class="headerlink" title="4.信息提取"></a>4.信息提取</h2><p>下面的提示要求模型来提取购买物品和制造物品的公司名称：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Identify the following items from the review text: </span><br><span class="line">- Item purchased by reviewer</span><br><span class="line">- Company that made the item</span><br><span class="line"></span><br><span class="line">The review is delimited with triple backticks. \</span><br><span class="line">Format your response as a JSON object with \</span><br><span class="line">"Item" and "Brand" as the keys. </span><br><span class="line">If the information isn't present, use "unknown" \</span><br><span class="line">as the value.</span><br><span class="line">Make your response as short as possible.</span><br><span class="line">  </span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190358094-16831982403691.png" alt="image-20230504190358094"></p><h2 id="5-一次提取多个信息（同时做多个任务"><a href="#5-一次提取多个信息（同时做多个任务" class="headerlink" title="5.一次提取多个信息（同时做多个任务)"></a>5.一次提取多个信息（同时做多个任务)</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Identify the following items from the review text: </span><br><span class="line">- Sentiment (positive or negative)</span><br><span class="line">- Is the reviewer expressing anger? (true or false)</span><br><span class="line">- Item purchased by reviewer</span><br><span class="line">- Company that made the item</span><br><span class="line"></span><br><span class="line">The review is delimited with triple backticks. \</span><br><span class="line">Format your response as a JSON object with \</span><br><span class="line">"Sentiment", "Anger", "Item" and "Brand" as the keys.</span><br><span class="line">If the information isn't present, use "unknown" \</span><br><span class="line">as the value.</span><br><span class="line">Make your response as short as possible.</span><br><span class="line">Format the Anger value as a boolean.</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190507260.png" alt="image-20230504190507260"></p><h2 id="6-主题推断"><a href="#6-主题推断" class="headerlink" title="6.主题推断"></a>6.主题推断</h2><p>下面是一个虚构的报纸文章，讲政府工作人员对他们所工作的机构的感受：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">story = """</span><br><span class="line">In a recent survey conducted by the government, </span><br><span class="line">public sector employees were asked to rate their level </span><br><span class="line">of satisfaction with the department they work at. </span><br><span class="line">The results revealed that NASA  was the most popular </span><br><span class="line">department with a satisfaction rating of 95%.</span><br><span class="line"></span><br><span class="line">One NASA employee, John Smith, commented on the findings, </span><br><span class="line">stating, "I'm not surprised that NASA came out on top. </span><br><span class="line">It's a great place to work with amazing people and </span><br><span class="line">incredible opportunities. I'm proud to be a part of </span><br><span class="line">such an innovative organization."</span><br><span class="line"></span><br><span class="line">The results were also welcomed by NASA's management team, </span><br><span class="line">with Director Tom Johnson stating, "We are thrilled to </span><br><span class="line">hear that our employees are satisfied with their work at NASA. </span><br><span class="line">We have a talented and dedicated team who work tirelessly </span><br><span class="line">to achieve our goals, and it's fantastic to see that their </span><br><span class="line">hard work is paying off."</span><br><span class="line"></span><br><span class="line">The survey also revealed that the </span><br><span class="line">Social Security Administration had the lowest satisfaction </span><br><span class="line">rating, with only 45% of employees indicating they were </span><br><span class="line">satisfied with their job. The government has pledged to </span><br><span class="line">address the concerns raised by employees in the survey and </span><br><span class="line">work towards improving job satisfaction across all departments.</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>然后，下面的提示可以询问模型确定文本中正在讨论的五个主题：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Determine five topics that are being discussed in the \</span><br><span class="line">following text, which is delimited by triple backticks.</span><br><span class="line"></span><br><span class="line">Make each item one or two words long. </span><br><span class="line"></span><br><span class="line">Format your response as a list of items separated by commas.</span><br><span class="line"></span><br><span class="line">Text sample: '''{story}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190723993.png" alt="image-20230504190723993"></p><p>该应用场景就可以是比如说报纸分类，或者是博客的标签分类，假如我们有这些标签：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">topic_list = [</span><br><span class="line">    "nasa", "local government", "engineering", </span><br><span class="line">    "employee satisfaction", "federal government"</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>那么我们可以通过下面的提示，来确定是否上面的主题列表的每个项目都符合这个文章的主题</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Determine whether each item in the following list of \</span><br><span class="line">topics is a topic in the text below, which</span><br><span class="line">is delimited with triple backticks.</span><br><span class="line"></span><br><span class="line">Give your answer as list with 0 or 1 for each topic.\</span><br><span class="line"></span><br><span class="line">List of topics: {", ".join(topic_list)}</span><br><span class="line"></span><br><span class="line">Text sample: '''{story}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>那么就会得到这个结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190918819.png" alt="image-20230504190918819"></p><h2 id="7-新闻提醒"><a href="#7-新闻提醒" class="headerlink" title="7.新闻提醒"></a>7.新闻提醒</h2><p>下面的代码是实现了，如果当前的“新闻”是NASA的话，就会提醒，<mark>可以说是推断的一种应用吧<mark></mark></mark></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">topic_dict = {i.split(': ')[0]: int(i.split(': ')[1]) for i in response.split(sep='\n')}</span><br><span class="line">if topic_dict['nasa'] &lt;mark&gt; 1:</span><br><span class="line">    print("ALERT: New NASA story!")</span><br></pre></td></tr></tbody></table></figure><h1 id="五、转换"><a href="#五、转换" class="headerlink" title="五、转换"></a>五、转换</h1><p>LLM非常擅长将输入转换成不同的格式，例如多语种文本翻译、拼写及语法纠正、语气调整、格式转换等。本章节将介绍如何使用编程的方式，调用API接口来实现“文本转换”功能。</p><h2 id="1-翻译"><a href="#1-翻译" class="headerlink" title="1.翻译"></a>1.翻译</h2><p>下面是一个中文翻译西班牙语的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">将以下中文翻译成西班牙语: \ </span><br><span class="line">```您好，我想订购一个搅拌机。```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2识别语种"><a href="#1-2识别语种" class="headerlink" title="1.2识别语种"></a>1.2识别语种</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">请告诉我以下文本是什么语种: </span><br><span class="line">```Combien coûte le lampadaire?```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3多语种翻译"><a href="#1-3多语种翻译" class="headerlink" title="1.3多语种翻译"></a>1.3多语种翻译</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">请将以下文本分别翻译成中文、英文、法语和西班牙语: </span><br><span class="line">```I want to order a basketball.```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4翻译-正式-x2F-非正式语气"><a href="#1-4翻译-正式-x2F-非正式语气" class="headerlink" title="1.4翻译+正式/非正式语气"></a>1.4翻译+正式/非正式语气</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">请将以下文本翻译成中文，分别展示成正式与非正式两种语气: </span><br><span class="line">```Would you like to order a pillow?```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-5通用翻译器"><a href="#1-5通用翻译器" class="headerlink" title="1.5通用翻译器"></a>1.5通用翻译器</h3><p>交流的用户可能来自各个不同的国家，使用不同的语言，因此我们需要一个通用翻译器，识别各个消息的语种，并翻译成目标用户的母语，从而实现更方便的跨国交流。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">user_messages = [</span><br><span class="line">  "La performance du système est plus lente que d'habitude.",  # System performance is slower than normal         </span><br><span class="line">  "Mi monitor tiene píxeles que no se iluminan.",              # My monitor has pixels that are not lighting</span><br><span class="line">  "Il mio mouse non funziona",                                 # My mouse is not working</span><br><span class="line">  "Mój klawisz Ctrl jest zepsuty",                             # My keyboard has a broken control key</span><br><span class="line">  "我的屏幕在闪烁"                                             # My screen is flashing</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for issue in user_messages:</span><br><span class="line">    prompt = f"告诉我以下文本是什么语种，直接输出语种，如法语，无需输出标点符号: ```{issue}```"</span><br><span class="line">    lang = get_completion(prompt)</span><br><span class="line">    print(f"原始消息 ({lang}): {issue}\n")</span><br><span class="line"></span><br><span class="line">    prompt = f"""</span><br><span class="line">    将以下消息分别翻译成英文和中文，并写成</span><br><span class="line">    中文翻译：xxx</span><br><span class="line">    英文翻译：yyy</span><br><span class="line">    的格式：</span><br><span class="line">    ```{issue}```</span><br><span class="line">    """</span><br><span class="line">    response = get_completion(prompt)</span><br><span class="line">    print(response, "\n&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;=")</span><br></pre></td></tr></tbody></table></figure><p>打印结果:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193143390.png" alt="image-20230504193143390"></p><h2 id="2-语气-x2F-风格"><a href="#2-语气-x2F-风格" class="headerlink" title="2.语气/风格"></a>2.语气/风格</h2><p>写作的语气往往会根据受众对象而有所调整。例如，对于工作邮件，我们常常需要使用正式语气与书面用词，而对同龄朋友的微信聊天，可能更多地会使用轻松、口语化的语气。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">将以下文本翻译成商务信函的格式: </span><br><span class="line">```小老弟，我小羊，上回你说咱部门要采购的显示器是多少寸来着？```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193305409.png" alt="image-20230504193305409"></p><h2 id="3-格式转换"><a href="#3-格式转换" class="headerlink" title="3.格式转换"></a>3.格式转换</h2><p>在下述例子中，我们有一个包含餐厅员工姓名和电子邮件的列表的JSON，我们希望将其从JSON转换为HTML。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data_json = { "resturant employees" :[ </span><br><span class="line">    {"name":"Shyam", "email":"shyamjaiswal@gmail.com"},</span><br><span class="line">    {"name":"Bob", "email":"bob32@gmail.com"},</span><br><span class="line">    {"name":"Jai", "email":"jai87@gmail.com"}</span><br><span class="line">]}</span><br><span class="line"></span><br><span class="line">prompt = f"""</span><br><span class="line">将以下Python字典从JSON转换为HTML表格，保留表格标题和列名：{data_json}</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193352603.png" alt="image-20230504193352603"></p><h2 id="4-拼写及语法纠正-强烈推荐"><a href="#4-拼写及语法纠正-强烈推荐" class="headerlink" title="4.拼写及语法纠正(强烈推荐)"></a>4.拼写及语法纠正(强烈推荐)</h2><p>这个功能大佬非常推荐</p><p>以下给了一个例子，有一个句子列表，其中有些句子存在拼写或语法问题，有些则没有，我们循环遍历每个句子，要求模型校对文本，如果正确则输出“未发现错误”，如果错误则输出纠正后的文本。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">text = [ </span><br><span class="line">  "The girl with the black and white puppies have a ball.",  # The girl has a ball.</span><br><span class="line">  "Yolanda has her notebook.", # ok</span><br><span class="line">  "Its going to be a long day. Does the car need it’s oil changed?",  # Homonyms</span><br><span class="line">  "Their goes my freedom. There going to bring they’re suitcases.",  # Homonyms</span><br><span class="line">  "Your going to need you’re notebook.",  # Homonyms</span><br><span class="line">  "That medicine effects my ability to sleep. Have you heard of the butterfly affect?", # Homonyms</span><br><span class="line">  "This phrase is to cherck chatGPT for speling abilitty"  # spelling</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>那么可以编写如下的提示:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(text)):</span><br><span class="line">    prompt = f"""请校对并更正以下文本，注意纠正文本保持原始语种，无需输出原始文本。</span><br><span class="line">    如果您没有发现任何错误，请说“未发现错误”。</span><br><span class="line">    </span><br><span class="line">    例如：</span><br><span class="line">    输入：I are happy.</span><br><span class="line">    输出：I am happy.</span><br><span class="line">    ```{text[i]}```"""</span><br><span class="line">    response = get_completion(prompt)</span><br><span class="line">    print(i, response)</span><br></pre></td></tr></tbody></table></figure><p>打印结果:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193553626.png" alt="image-20230504193553626"></p><h2 id="5-基于Readlines的纠错"><a href="#5-基于Readlines的纠错" class="headerlink" title="5.基于Readlines的纠错"></a>5.基于Readlines的纠错</h2><p>下图是一个示例，可以看到，通过使用readlines这个库非常的直观。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193932653.png" alt="image-20230504193932653"></p><h2 id="6-一个综合样例：文本翻译-拼写纠正-风格调整-格式转换"><a href="#6-一个综合样例：文本翻译-拼写纠正-风格调整-格式转换" class="headerlink" title="6.一个综合样例：文本翻译+拼写纠正+风格调整+格式转换"></a>6.一个综合样例：文本翻译+拼写纠正+风格调整+格式转换</h2><p>``</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">text = f"""</span><br><span class="line">Got this for my daughter for her birthday cuz she keeps taking \</span><br><span class="line">mine from my room.  Yes, adults also like pandas too.  She takes \</span><br><span class="line">it everywhere with her, and it's super soft and cute.  One of the \</span><br><span class="line">ears is a bit lower than the other, and I don't think that was \</span><br><span class="line">designed to be asymmetrical. It's a bit small for what I paid for it \</span><br><span class="line">though. I think there might be other options that are bigger for \</span><br><span class="line">the same price.  It arrived a day earlier than expected, so I got \</span><br><span class="line">to play with it myself before I gave it to my daughter.</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">prompt = f"""</span><br><span class="line">针对以下三个反引号之间的英文评论文本，</span><br><span class="line">首先进行拼写及语法纠错，</span><br><span class="line">然后将其转化成中文，</span><br><span class="line">再将其转化成优质淘宝评论的风格，从各种角度出发，分别说明产品的优点与缺点，并进行总结。</span><br><span class="line">润色一下描述，使评论更具有吸引力。</span><br><span class="line">输出结果格式为：</span><br><span class="line">【优点】xxx</span><br><span class="line">【缺点】xxx</span><br><span class="line">【总结】xxx</span><br><span class="line">注意，只需填写xxx部分，并分段输出。</span><br><span class="line">将结果输出成Markdown格式。</span><br><span class="line">```{text}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">display(Markdown(response))</span><br></pre></td></tr></tbody></table></figure><p>打印：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504194051241.png" alt="image-20230504194051241"></p><h1 id="六、扩展"><a href="#六、扩展" class="headerlink" title="六、扩展"></a>六、扩展</h1><p>扩展是将短文本，例如一组说明或主题列表，输入到大型语言模型中，让模型生成更长的文本，例如基于某个主题的电子邮件或论文。这样做有一些很好的用途，例如将大型语言模型用作头脑风暴的伙伴。但这种做法也存在一些问题，例如某人可能会使用它来生成大量垃圾邮件。因此，当你使用大型语言模型的这些功能时，请仅以负责任的方式和有益于人们的方式使用它们。</p><h2 id="1-定制邮件"><a href="#1-定制邮件" class="headerlink" title="1.定制邮件"></a>1.定制邮件</h2><p>我们将根据客户评价和情感撰写自定义电子邮件响应。因此，我们将给定客户评价和情感，并生成自定义响应即使用 LLM 根据客户评价和评论情感生成定制电子邮件。</p><p>我们首先给出一个示例，包括一个评论及对应的情感</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># given the sentiment from the lesson on "inferring",</span><br><span class="line"># and the original customer message, customize the email</span><br><span class="line">sentiment = "negative"</span><br><span class="line"></span><br><span class="line"># review for a blender</span><br><span class="line">review = f"""</span><br><span class="line">So, they still had the 17 piece system on seasonal \</span><br><span class="line">sale for around $49 in the month of November, about \</span><br><span class="line">half off, but for some reason (call it price gouging) \</span><br><span class="line">around the second week of December the prices all went \</span><br><span class="line">up to about anywhere from between $70-$89 for the same \</span><br><span class="line">system. And the 11 piece system went up around $10 or \</span><br><span class="line">so in price also from the earlier sale price of $29. \</span><br><span class="line">So it looks okay, but if you look at the base, the part \</span><br><span class="line">where the blade locks into place doesn’t look as good \</span><br><span class="line">as in previous editions from a few years ago, but I \</span><br><span class="line">plan to be very gentle with it (example, I crush \</span><br><span class="line">very hard items like beans, ice, rice, etc. in the \ </span><br><span class="line">blender first then pulverize them in the serving size \</span><br><span class="line">I want in the blender then switch to the whipping \</span><br><span class="line">blade for a finer flour, and use the cross cutting blade \</span><br><span class="line">first when making smoothies, then use the flat blade \</span><br><span class="line">if I need them finer/less pulpy). Special tip when making \</span><br><span class="line">smoothies, finely cut and freeze the fruits and \</span><br><span class="line">vegetables (if using spinach-lightly stew soften the \ </span><br><span class="line">spinach then freeze until ready for use-and if making \</span><br><span class="line">sorbet, use a small to medium sized food processor) \ </span><br><span class="line">that you plan to use that way you can avoid adding so \</span><br><span class="line">much ice if at all-when making your smoothie. \</span><br><span class="line">After about a year, the motor was making a funny noise. \</span><br><span class="line">I called customer service but the warranty expired \</span><br><span class="line">already, so I had to buy another one. FYI: The overall \</span><br><span class="line">quality has gone done in these types of products, so \</span><br><span class="line">they are kind of counting on brand recognition and \</span><br><span class="line">consumer loyalty to maintain sales. Got it in about \</span><br><span class="line">two days.</span><br><span class="line">"""</span><br><span class="line"># 我们可以在推理那章学习到如何对一个评论判断其情感倾向</span><br><span class="line">sentiment = "negative"</span><br><span class="line"></span><br><span class="line"># 一个产品的评价</span><br><span class="line">review = f"""</span><br><span class="line">他们在11月份的季节性销售期间以约49美元的价格出售17件套装，折扣约为一半。\</span><br><span class="line">但由于某些原因（可能是价格欺诈），到了12月第二周，同样的套装价格全都涨到了70美元到89美元不等。\</span><br><span class="line">11件套装的价格也上涨了大约10美元左右。\</span><br><span class="line">虽然外观看起来还可以，但基座上锁定刀片的部分看起来不如几年前的早期版本那么好。\</span><br><span class="line">不过我打算非常温柔地使用它，例如，\</span><br><span class="line">我会先在搅拌机中将像豆子、冰、米饭等硬物研磨，然后再制成所需的份量，\</span><br><span class="line">切换到打蛋器制作更细的面粉，或者在制作冰沙时先使用交叉切割刀片，然后使用平面刀片制作更细/不粘的效果。\</span><br><span class="line">制作冰沙时，特别提示：\</span><br><span class="line">将水果和蔬菜切碎并冷冻（如果使用菠菜，则轻轻煮软菠菜，然后冷冻直到使用；\</span><br><span class="line">如果制作果酱，则使用小到中号的食品处理器），这样可以避免在制作冰沙时添加太多冰块。\</span><br><span class="line">大约一年后，电机发出奇怪的噪音，我打电话给客服，但保修已经过期了，所以我不得不再买一个。\</span><br><span class="line">总的来说，这些产品的总体质量已经下降，因此它们依靠品牌认可和消费者忠诚度来维持销售。\</span><br><span class="line">货物在两天内到达。</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>这里我们将根据情感定制回复，这里的指令是：假设你是一个客户服务AI助手，你的任务是为客户发送电子邮件回复，根据通过三个反引号分隔的客户电子邮件，生成一封回复以感谢客户的评价：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">你是一位客户服务的AI助手。</span><br><span class="line">你的任务是给一位重要客户发送邮件回复。</span><br><span class="line">根据客户通过“```”分隔的评价，生成回复以感谢客户的评价。提醒模型使用评价中的具体细节</span><br><span class="line">用简明而专业的语气写信。</span><br><span class="line">作为“AI客户代理”签署电子邮件。</span><br><span class="line">客户评论：</span><br><span class="line">```{review}```</span><br><span class="line">评论情感：{sentiment}</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>打印：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504194949096.png" alt="image-20230504194949096"></p><h2 id="2-温度系数的使用（重要参数）"><a href="#2-温度系数的使用（重要参数）" class="headerlink" title="2.温度系数的使用（重要参数）"></a>2.温度系数的使用（重要参数）</h2><p>接下来，我们将使用语言模型的一个称为“温度”的参数，它将允许我们改变模型响应的多样性。您可以<mark>将温度视为模型探索或随机性的程度<mark>。</mark></mark></p><p>例如，在一个特定的短语中，“我的最爱食品”最有可能的下一个词是“比萨”，其次最有可能的是“寿司”和“塔可”。因此，在温度为零时，模型将总是选择最有可能的下一个词，而在较高的温度下，它还将选择其中一个不太可能的词，在更高的温度下，它甚至可能选择塔可，而这种可能性仅为五分之一。您可以想象，随着模型继续生成更多单词的最终响应，“我的最爱食品是比萨”将会与第一个响应“我的最爱食品是塔可”产生差异。因此，随着模型的继续，这两个响应将变得越来越不同。</p><p>一般来说，在构建需要可预测响应的应用程序时，我建议使用温度为零。在所有课程中，我们一直设置温度为零，<mark>如果您正在尝试构建一个可靠和可预测的系统，我认为您应该选择这个温度。如果您尝试以更具创意的方式使用模型，可能需要更广泛地输出不同的结果，那么您可能需要使用更高的温度。<mark></mark></mark></p><p>示例:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># given the sentiment from the lesson on "inferring",</span><br><span class="line"># and the original customer message, customize the email</span><br><span class="line">sentiment = "negative"</span><br><span class="line"></span><br><span class="line"># review for a blender</span><br><span class="line">review = f"""</span><br><span class="line">So, they still had the 17 piece system on seasonal \</span><br><span class="line">sale for around $49 in the month of November, about \</span><br><span class="line">half off, but for some reason (call it price gouging) \</span><br><span class="line">around the second week of December the prices all went \</span><br><span class="line">up to about anywhere from between $70-$89 for the same \</span><br><span class="line">system. And the 11 piece system went up around $10 or \</span><br><span class="line">so in price also from the earlier sale price of $29. \</span><br><span class="line">So it looks okay, but if you look at the base, the part \</span><br><span class="line">where the blade locks into place doesn’t look as good \</span><br><span class="line">as in previous editions from a few years ago, but I \</span><br><span class="line">plan to be very gentle with it (example, I crush \</span><br><span class="line">very hard items like beans, ice, rice, etc. in the \ </span><br><span class="line">blender first then pulverize them in the serving size \</span><br><span class="line">I want in the blender then switch to the whipping \</span><br><span class="line">blade for a finer flour, and use the cross cutting blade \</span><br><span class="line">first when making smoothies, then use the flat blade \</span><br><span class="line">if I need them finer/less pulpy). Special tip when making \</span><br><span class="line">smoothies, finely cut and freeze the fruits and \</span><br><span class="line">vegetables (if using spinach-lightly stew soften the \ </span><br><span class="line">spinach then freeze until ready for use-and if making \</span><br><span class="line">sorbet, use a small to medium sized food processor) \ </span><br><span class="line">that you plan to use that way you can avoid adding so \</span><br><span class="line">much ice if at all-when making your smoothie. \</span><br><span class="line">After about a year, the motor was making a funny noise. \</span><br><span class="line">I called customer service but the warranty expired \</span><br><span class="line">already, so I had to buy another one. FYI: The overall \</span><br><span class="line">quality has gone done in these types of products, so \</span><br><span class="line">they are kind of counting on brand recognition and \</span><br><span class="line">consumer loyalty to maintain sales. Got it in about \</span><br><span class="line">two days.</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以编写prompt:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">你是一名客户服务的AI助手。</span><br><span class="line">你的任务是给一位重要的客户发送邮件回复。</span><br><span class="line">根据通过“```”分隔的客户电子邮件生成回复，以感谢客户的评价。</span><br><span class="line">如果情感是积极的或中性的，感谢他们的评价。</span><br><span class="line">如果情感是消极的，道歉并建议他们联系客户服务。</span><br><span class="line">请确保使用评论中的具体细节。</span><br><span class="line">以简明和专业的语气写信。</span><br><span class="line">以“AI客户代理”的名义签署电子邮件。</span><br><span class="line">客户评价：```{review}```</span><br><span class="line">评论情感：{sentiment}</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt, temperature=0.7)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>这里设置了温度，得到了下面的结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504195237697.png" alt="image-20230504195237697"></p><p><mark>在温度为零时，每次执行相同的提示时，您应该期望获得相同的完成。而使用温度为0.7，则每次都会获得不同的输出。<mark></mark></mark></p><p>所以，您可以看到它与我们之前收到的电子邮件不同。让我们再次执行它，以显示我们将再次获得不同的电子邮件。</p><p>因此，我建议您自己尝试温度，以查看输出如何变化。总之，在更高的温度下，模型的输出更加随机。您几乎可以将其视为在更高的温度下，助手更易分心，但也许更有创造力。</p><h1 id="七、聊天机器人"><a href="#七、聊天机器人" class="headerlink" title="七、聊天机器人"></a>七、聊天机器人</h1><p>像 ChatGPT 这样的聊天模型实际上是组装成以一系列消息作为输入，并返回一个模型生成的消息作为输出的。虽然聊天格式的设计旨在使这种多轮对话变得容易，但我们通过之前的学习可以知道，它对于没有任何对话的单轮任务也同样有用。</p><p>接下来，我们将定义两个辅助函数。第一个是单轮的，我们将prompt放入看起来像是某种用户消息的东西中。另一个则传入一个消息列表。这些消息可以来自不同的角色，我们会描述一下这些角色。</p><p>第一条消息是一个系统消息，它提供了一个总体的指示，然后在这个消息之后，我们有用户和助手之间的交替。如果你曾经使用过 ChatGPT 网页界面，那么你的消息是用户消息，而 ChatGPT 的消息是助手消息。系统消息则有助于设置助手的行为和角色，并作为对话的高级指示。你可以想象它在助手的耳边低语，引导它的回应，而用户不会注意到系统消息。</p><p>因此，作为用户，如果你曾经使用过 ChatGPT，你可能不知道 ChatGPT 的系统消息是什么，这是有意为之的。<mark>系统消息的好处是为开发者提供了一种方法，在不让请求本身成为对话的一部分的情况下，引导助手并指导其回应。<mark></mark></mark></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import openai</span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY2")</span><br><span class="line">openai.api_key = OPENAI_API_KEY</span><br><span class="line"></span><br><span class="line">def get_completion(prompt, model="gpt-3.5-turbo"):</span><br><span class="line">    messages = [{"role": "user", "content": prompt}]</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=0, # 控制模型输出的随机程度</span><br><span class="line">    )</span><br><span class="line">    return response.choices[0].message["content"]</span><br><span class="line"></span><br><span class="line">def get_completion_from_messages(messages, model="gpt-3.5-turbo", temperature=0):</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=temperature, # 控制模型输出的随机程度</span><br><span class="line">    )</span><br><span class="line">#     print(str(response.choices[0].message))</span><br><span class="line">    return response.choices[0].message["content"]</span><br></pre></td></tr></tbody></table></figure><p>系统消息说，你是一个说话像莎士比亚的助手。这是我们向助手描述它应该如何表现的方式。然后，第一个用户消息是，给我讲个笑话。接下来的消息是，为什么鸡会过马路？然后最后一个用户消息是，我不知道。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 中文</span><br><span class="line">messages =  [  </span><br><span class="line">{'role':'system', 'content':'你是一个像莎士比亚一样说话的助手。'},    </span><br><span class="line">{'role':'user', 'content':'给我讲个笑话'},   </span><br><span class="line">{'role':'assistant', 'content':'鸡为什么过马路'},   </span><br><span class="line">{'role':'user', 'content':'我不知道'}  ]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response = get_completion_from_messages(messages, temperature=1)</span><br><span class="line">print(response)</span><br><span class="line">#因为它要去找“母鸡”。哈哈哈！（注：此为英文双关语，"chicken"是鸡的意思，也是胆小的意思；"cross the road"是过马路的意思，也是“破坏规则”的意思。</span><br></pre></td></tr></tbody></table></figure><p>每次与语言模型的交互都是一个独立的交互，这意味着我们必须提供所有相关的消息，以便模型在当前对话中进行引用。<mark>如果想让模型引用或 “记住” 对话的早期部分，则必须在模型的输入中提供早期的交流。我们将其称为上下文。<mark></mark></mark></p><h2 id="1-聊天机器人"><a href="#1-聊天机器人" class="headerlink" title="1.聊天机器人"></a>1.聊天机器人</h2><p>现在，我们构建一个 “订餐机器人”，我们需要它自动收集用户信息，接受比萨饼店的订单。</p><p>下面这个函数将收集我们的用户消息，以便我们可以避免手动输入，就像我们在刚刚上面做的那样。这个函数将从我们下面构建的用户界面中收集提示，然后将其附加到一个名为上下文的列表中，并在每次调用模型时使用该上下文。模型的响应也会被添加到上下文中，所以模型消息和用户消息都被添加到上下文中，因此上下文逐渐变长。这样，模型就有了需要的信息来确定下一步要做什么。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def collect_messages(_):</span><br><span class="line">    prompt = inp.value_input</span><br><span class="line">    inp.value = ''</span><br><span class="line">    context.append({'role':'user', 'content':f"{prompt}"})</span><br><span class="line">    response = get_completion_from_messages(context) </span><br><span class="line">    context.append({'role':'assistant', 'content':f"{response}"})</span><br><span class="line">    panels.append(</span><br><span class="line">        pn.Row('User:', pn.pane.Markdown(prompt, width=600)))</span><br><span class="line">    panels.append(</span><br><span class="line">        pn.Row('Assistant:', pn.pane.Markdown(response, width=600, style={'background-color': '#F6F6F6'})))</span><br><span class="line"> </span><br><span class="line">    return pn.Column(*panels)</span><br></pre></td></tr></tbody></table></figure><p>现在，我们将设置并运行这个 UI 来显示订单机器人。初始的上下文包含了包含菜单的系统消息。请注意，上下文会随着时间的推移而不断增长。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install panel</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># 中文</span><br><span class="line">import panel as pn  # GUI</span><br><span class="line">pn.extension()</span><br><span class="line"></span><br><span class="line">panels = [] # collect display </span><br><span class="line"></span><br><span class="line">context = [{'role':'system', 'content':"""</span><br><span class="line">你是订餐机器人，为披萨餐厅自动收集订单信息。</span><br><span class="line">你要首先问候顾客。然后等待用户回复收集订单信息。收集完信息需确认顾客是否还需要添加其他内容。</span><br><span class="line">最后需要询问是否自取或外送，如果是外送，你要询问地址。</span><br><span class="line">最后告诉顾客订单总金额，并送上祝福。</span><br><span class="line"></span><br><span class="line">请确保明确所有选项、附加项和尺寸，以便从菜单中识别出该项唯一的内容。</span><br><span class="line">你的回应应该以简短、非常随意和友好的风格呈现。</span><br><span class="line"></span><br><span class="line">菜单包括：</span><br><span class="line"></span><br><span class="line">菜品：</span><br><span class="line">意式辣香肠披萨（大、中、小） 12.95、10.00、7.00</span><br><span class="line">芝士披萨（大、中、小） 10.95、9.25、6.50</span><br><span class="line">茄子披萨（大、中、小） 11.95、9.75、6.75</span><br><span class="line">薯条（大、小） 4.50、3.50</span><br><span class="line">希腊沙拉 7.25</span><br><span class="line"></span><br><span class="line">配料：</span><br><span class="line">奶酪 2.00</span><br><span class="line">蘑菇 1.50</span><br><span class="line">香肠 3.00</span><br><span class="line">加拿大熏肉 3.50</span><br><span class="line">AI酱 1.50</span><br><span class="line">辣椒 1.00</span><br><span class="line"></span><br><span class="line">饮料：</span><br><span class="line">可乐（大、中、小） 3.00、2.00、1.00</span><br><span class="line">雪碧（大、中、小） 3.00、2.00、1.00</span><br><span class="line">瓶装水 5.00</span><br><span class="line">"""} ]  # accumulate messages</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inp = pn.widgets.TextInput(value="Hi", placeholder='Enter text here…')</span><br><span class="line">button_conversation = pn.widgets.Button(name="Chat!")</span><br><span class="line"></span><br><span class="line">interactive_conversation = pn.bind(collect_messages, button_conversation)</span><br><span class="line"></span><br><span class="line">dashboard = pn.Column(</span><br><span class="line">    inp,</span><br><span class="line">    pn.Row(button_conversation),</span><br><span class="line">    pn.panel(interactive_conversation, loading_indicator=True, height=300),</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br></pre></td></tr></tbody></table></figure><p>现在我们可以要求模型创建一个 JSON 摘要发送给订单系统。</p><p>所以我们现在追加另一个系统消息，它是另一条prompt，我们说创建一个刚刚订单的 JSON 摘要，列出每个项目的价格，字段应包括1）披萨，包括尺寸，2）配料列表，3）饮料列表，4）辅菜列表，包括尺寸，最后是总价格。这里也可以在这里使用用户消息，不一定是系统消息。</p><p>请注意，这里我们使用了一个较低的temperature，因为对于这些类型的任务，我们希望输出相对可预测。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">messages =  context.copy()</span><br><span class="line">messages.append(</span><br><span class="line">{'role':'system', 'content':'创建上一个食品订单的 json 摘要。\</span><br><span class="line">逐项列出每件商品的价格，字段应该是 1) 披萨，包括大小 2) 配料列表 3) 饮料列表，包括大小 4) 配菜列表包括大小 5) 总价'},    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = get_completion_from_messages(messages, temperature=0)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>输出:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504200013220.png" alt="image-20230504200013220"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Prompt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《软件测试的艺术》原书第3版的3.3节笔记-用于代码检查的错误列表</title>
      <link href="/2023/06/24/%E7%94%A8%E4%BA%8E%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5%E7%9A%84%E9%94%99%E8%AF%AF%E5%88%97%E8%A1%A8/"/>
      <url>/2023/06/24/%E7%94%A8%E4%BA%8E%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5%E7%9A%84%E9%94%99%E8%AF%AF%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="用于代码检查的错误列表"><a href="#用于代码检查的错误列表" class="headerlink" title="用于代码检查的错误列表"></a>用于代码检查的错误列表</h1><p>《软件测试的艺术》原书第3版的3.3节笔记。代码检查过程的一个重要部分就是<strong>对照一份错误列表，来检查程序是否存在常见错误。</strong>在写代码的时候还是要小心考虑是否自己的代码也有错误列表中描述的问题。</p><h1 id="表格总结"><a href="#表格总结" class="headerlink" title="表格总结"></a>表格总结</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_17" alt="img"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_18" alt="img"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_19" alt="img"></p><h4 id="3-3-1-数据引用错误"><a href="#3-3-1-数据引用错误" class="headerlink" title="3.3.1 数据引用错误"></a>3.3.1 数据引用错误</h4><p>1.是否有引用的变量未赋值或未初始化？</p><p>2.对于所有的数组引用，是否每一个下标的值都在相应维规定的界限之内？3.对于所有的数组引用，是否每一个下标的值都是整数？</p><p>4.对于所有的通过指针或引用变量的引用，当前引用的内存单元是否分配？</p><p>5.如果一个内存区域具有不同属性的别名，当通过别名进行引用时，内存区域中的数据值是否具有正确的属性？</p><p>6.变量值的类型或属性是否与编译器所预期的一致？</p><p>7.在使用的计算机上，当内存分配的单元小于内存可寻址的单元大小时，是否存在直接或间接的寻址错误？</p><p>8.当使用指针或引用变量时，被引用的内存的属性是否与编译器所预期的一致？</p><p>9.假如一个数据结构在多个过程或子程序中被引用，那么每个过程或子程序对该结构的定义是否都相同？</p><p>10.如果字符串有索引，当对数组进行索引操作或下标引用，字符串的边界取值是否有“仅差一个”（off-by-one）的错误？</p><p>11.对于面向对象的语言，是否所有的继承需求都在实现类中得到了满足？</p><h4 id="3-3-2-数据声明错误"><a href="#3-3-2-数据声明错误" class="headerlink" title="3.3.2 数据声明错误"></a>3.3.2 数据声明错误</h4><p>1.是否所有的变量都进行了明确的声明？</p><p>2.如果变量所有的属性在声明中没有明确说明，那么默认的属性能否被正确理解？</p><p>3.如果变量在声明语句中被初始化，那么它的初始化是否正确？</p><p>4.是否每个变量都被赋予了正确的长度和数据类型？5.变量的初始化是否与其存储空间的类型一致？</p><p>6.是否存在着相似名称的变量（如VOLT和VOLTS）？</p><h4 id="3-3-3-运算错误"><a href="#3-3-3-运算错误" class="headerlink" title="3.3.3 运算错误"></a>3.3.3 运算错误</h4><p>1.是否存在不一致的数据类型（如非算术类型）的变量间的运算？2.是否有混合模式的运算？例如，将浮点变量与一个整型变量做加法运算。</p><p>3.是否有相同数据类型、不同字长变量间的运算？</p><p>4.赋值语句的目标变量的数据类型是否小于右边表达式的数据类型或结果？</p><p>5.在表达式的运算中是否存在表达式向上或向下溢出的情况？也就是说，最终的结果看起来是个有效值，但中间结果对于编程语言的数据类型可能过大或过小。</p><p>6.除法运算中的除数是否可能为0？</p><p>7.如果计算机表达变量的基本方式是基于二进制的，那么运算结果是否不精确？也就是说，在一个二进制计算机上，10×0.1很少会等于1.0。</p><p>8.在特定场合，变量的值是否超出了有意义的范围？</p><p>9.对于包含一个以上操作符的表达式，赋值顺序和操作符的优先顺序是否正确？</p><p>10.整数的运算是否有使用不当的情况，尤其是除法？举例来说，如果i是一个整型变量，表达式2*i/2<mark>i是否成立，取决于i是奇数还是偶数，或是先运算乘法，还是先运算除法。</mark></p><h4 id="3-3-4-比较错误"><a href="#3-3-4-比较错误" class="headerlink" title="3.3.4 比较错误"></a>3.3.4 比较错误</h4><p>1.是否有不同数据类型的变量之间的比较运算，例如，将字符串与地址、日期或数字相比较？</p><p>2.是否有混合模式的比较运算，或不同长度的变量间的比较运算？如果有，应确保程序能正确理解转换规则。</p><p>3.比较运算符是否正确？程序员经常混淆“至多”、“至少”、“大于”、“不小于”、“小于”和“等于”等比较关系。</p><p>4.每个布尔表达式所叙述的内容是否都正确？在编写涉及“与”、“或”或“非”的表达式时，程序员经常犯错。</p><p>5.布尔运算符的操作数是否是布尔类型的？比较运算符和布尔运算符是否错误地混在了一起？</p><p>6.在二进制的计算机上，是否有用二进制表示的小数或浮点数的比较运算？</p><p>8.编译器计算布尔表达式的方式是否会对程序产生影响？</p><h4 id="3-3-5-控制流程错误"><a href="#3-3-5-控制流程错误" class="headerlink" title="3.3.5 控制流程错误"></a>3.3.5 控制流程错误</h4><p>1.如果程序包含多条分支路径，比如有计算GO TO语句，索引变量的值是否会大于可能的分支数量</p><p>2.是否所有的循环最终都终止了？应设计一个非正式的证据或论据来证明每一个循环都会终止。</p><p>3.程序、模块或子程序是否最终都终止了？</p><p>4.由于实际情况没有满足循环的入口条件，循环体是否有可能从未执行过？如果确实发生这种情况，这里是否是一处疏漏？</p><p>5.如果循环同时由迭代变量和一个布尔条件所控制（如一个搜索循环），如果循环越界（fall-through）了，后果会如何？</p><p>6.是否存在“仅差一个”的错误，如迭代数量恰恰多一次或少一次？</p><p>7.如果编程语言中有语句组或代码块的概念（例如do-while或{……}），是否每一组语句都有一个明确的while语句，并且do语句也与其相应的语句组对应？</p><p>8.是否存在不能穷尽的判断？举例来说，如果一个输入参数的预期值是1，2或3，当参数值不为1或2时，在逻辑上是否假设了参数必定为3？</p><h4 id="3-3-6-接口错误"><a href="#3-3-6-接口错误" class="headerlink" title="3.3.6 接口错误"></a>3.3.6 接口错误</h4><ol><li>被调用模块接收到的形参（parameter）数量是否等于调用模块发送的实参（argument）数量？另外，顺序是否正确？</li></ol><p>2.实参的属性（如数据类型和大小）是否与相应形参的属性相匹配？</p><p>3.实参的量纲是否与对应形参的量纲相匹配？举例来说，是否形参以度为单位而实参以弧度为单位？</p><p>4.此模块传递给彼模块的实参数量，是否等于彼模块期望的形参数量？</p><p>5.此模块传递给彼模块的实参的属性，是否与彼模块相应形参的属性相匹配？</p><p>6.此模块传递给彼模块的实参的量纲，是否与彼模块相应形参的量纲相匹配？</p><p>7.如果调用了内置函数，实参的数量、属性、顺序是否正确？</p><p>8.如果某个模块或类有多个入口点，是否引用了与当前入口点无关的形参？</p><p>9.是否有子程序改变了某个原本仅为输入值的形参？</p><p>10.如果存在全局变量，在所有引用它们的模块中，它们的定义和属性是否相同？</p><p>11.常数是否以实参形式传递过？</p><h4 id="3-3-7-输入-x2F-输出错误"><a href="#3-3-7-输入-x2F-输出错误" class="headerlink" title="3.3.7 输入/输出错误"></a>3.3.7 输入/输出错误</h4><p>1.如果对文件明确声明过，其属性是否正确？</p><p>2.打开文件的语句中各项属性的设置是否正确？</p><p>3.格式规范是否与I/O语句中的信息相吻合？举例来说，在FORTRAN语言中，是否每个FORMAT语句都与相应的READ或WRITE语句相一致（就各项的数量和属性而言）？</p><p>4.是否有足够的可用内存空间，来保留程序将读取的文件？</p><p>5.是否所有的文件在使用之前都打开了？</p><p>6.是否所有的文件在使用之后都关闭了？</p><p>7.是否判断文件结束的条件，并正确处理？</p><p>8.对I/O出错情况处理是否正确？</p><p>9.任何打印或显示的文本信息中是否存在拼写或语法错误？</p><p>10.程序是否正确处理了类似于“File Not Found”这样的错误？</p><h4 id="3-3-8-其他检查"><a href="#3-3-8-其他检查" class="headerlink" title="3.3.8 其他检查"></a>3.3.8 其他检查</h4><p>1.如果编译器建立了一个标识符交叉引用列表，那么对该列表进行检查，查看是否有变量从未引用过，或仅被引用过一次。</p><p>2.如果编译器建立了一个属性列表，那么对每个变量的属性进行检查，确保没有赋予过不希望的默认属性值。</p><p>3.如果程序编译通过了，但计算机提供了一个或多个“警告”或“提示”信息，应对此逐一进行认真检查。“警告”信息指出编译器对程序某些操作的正确性有所怀疑；所有这些疑问都应进行检查。“提示”信息可能会罗列出没有声明的变量，或者是不利于代码优化的用法。</p><p>4.程序或模块是否具有足够的鲁棒性？也就是说，它是否对其输入的合法性进行了检查？</p><p>5.程序是否遗漏了某个功能？</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/18/hello-world/"/>
      <url>/2023/06/18/hello-world/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
