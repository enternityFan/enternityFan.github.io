<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>活着读后感</title>
      <link href="/2025/04/05/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"/>
      <url>/2025/04/05/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>想起来高中的时候曾经看过五遍活着。因为最近好久没有一口气看完一本书了，并且今天晚上又闲来无事，就想到了再次看一遍活着。这次看确实和以前看有了不同的感触。<br>      我在上大学的时候没有再看过活着，因为一来高中的时候已经看过很多遍，二来觉得这本书非常的沉重，让人感到悲伤，所以不忍心去看。如今早已经忘了之前高中看的时候是怎样的感觉，可能只是简单的去理解了，人是为了活着而活着，不是为了活着以外的其他事情而活着。<br>       在这次看的时候，虽然过程中富贵，一个个亲人的离世仍然让人感到悲伤。但是我好像有意识到了自己悲伤的点在哪里，那就是家珍，友庆，凤霞，春生，偏头女婿二喜，还有福贵在当兵的时候遇到的那个老兵老全，老佣工长根，他们都是有血有肉的人，他们都表现出来了自己的一些善良一些丰富的情感。比如说家珍一直对福贵的不离不弃。虽然是城里大小姐的出身，在富贵落魄之后仍然陪伴着她，长根在富贵家破产之后，心里仍想着他的少爷福贵能不能干得了田里的重活儿。我想这应该是我们在读到家珍最后要离世时悲伤情绪到来的主要原因，家珍是一个非常好的人，所以我们为此而悲伤，并不是说家珍的离开会让福贵更加的孤独而悲伤。<br>      所以我们也为凤霞和有庆的懂事而悲伤，我们觉得偏头女婿是一个非常好的女婿，但是仍然以一种荒诞的形式去世，感到悲伤。还有苦根，春生等。<br>    在这次重看活着让我更多的是看到了其中的一些温情，并且明白了自己悲伤的原因，另一方面除了悲伤也感受到了其中的一些或许可以说是幸福一种高兴感，是当福贵被抓壮丁两年回来之后与亲人相逢的那种喜悦，也是有庆跑步跑的非常棒的喜悦，或者说是当福贵把凤霞送给别人家庭，到最后又给领回来时的喜悦，全家就算饿死也不愿再把凤霞送出。也有家珍被他父亲接走后又重新回来的喜悦。。。偏头女婿还没有进家门就对富贵的家进行修整的喜悦，并且为了凤霞坏了结婚后一个月才能回娘家看看的规矩。其中的离别后的重逢让我感到他们亲情的珍贵，让我也看到了一份真挚感情应有的样子。<br>    还有一点那就是可能会有更多的世事无常的感觉，确实如果不是福贵把家产给赔光光了，那么在那个时期被枪毙的就不是龙二，而是富贵。如果有庆真的不上学了，那么他后来也不会因为被抽血而死。仿佛命运有只大手操控着人走向他们该到的路途。。。<br>    最后一点就是当只剩下福贵和他的外孙苦根的时候，福贵本来想给苦根买2分钱的糖，后来想了想他决定买5分钱的糖给苦根，我觉得这个细节让我很有启发，确实，我们的未来是非常的不可预测的，为什么不好好的把握当下？去珍惜和爱护眼前的人呢？<br>    或许当我们经历一些困难时刻的时候才会感觉到这些亲情，友情，爱情的珍贵之处。正是因为他们的珍贵，所以让我们在读这本书的时候感到了更多的悲伤。像是很多无价的情感，随着书中的角色的去世，而被隐藏了起来。。。<br>    2024.04.04清明节，周四晚21.52，随手写于深圳市南山区。</p><h1 id="📚余华·活着-书摘1"><a href="#📚余华·活着-书摘1" class="headerlink" title="📚余华·活着 书摘1"></a>📚余华·活着 书摘1</h1><ul><li>人的体验和欲望还有想象和理解，会取消所有不同的界限，会让一个人从他人的经历里感受到自己的命运，就像是在不同的镜子里看到的都是自己的形象。</li></ul><ul><li><p>一位真正的作家永远只为内心写作，只有内心才会真实地告诉他，他的自私、他的高尚是多么突出。内心让他真实地了解自己，一旦了解了自己也就了解了世界。很多年前我就明白了这个原则，可是要捍卫这个原则必须付出艰辛的劳动和长时期的痛苦，因为内心并非时时刻刻都是敞开的，它更多的时候倒是封闭起来，于是只有写作、不停地写作才能使内心敞开，才能使自己置身于发现之中，就像日出的光芒照亮了黑暗，灵感这时候才会突然来到。</p></li><li><p>作家要表达与之朝夕相处的现实，他常常会感到难以承受，蜂拥而来的真实几乎都在诉说着丑恶和阴险，怪就怪在这里，为什么丑恶的事物总是在身边，而美好的事物却远在海角。</p></li><li><p>这里所说的高尚不是那种单纯的美好，而是对一切事物理解之后的超然，对善和恶一视同仁，用同情的目光看待世界。</p></li><li><p>女人到了出嫁的时候，是什么都看着舒服，什么都听着高兴。</p></li><li><p>一个人命再大，要是自己想死，那就怎么也活不了。</p></li><li><p>人啊，活着时受了再多的苦，到了快死的时候也会想个法子来宽慰自己。</p></li><li><p>“这辈子也快过完了，你对我这么好，我也心满意足，我为你生了一双儿女，也算是报答你了，下辈子我们还要在一起过。”家珍说到下辈子还要做我的女人，我的眼泪就掉了出来，掉到了她脸上。</p></li><li><p>做人还是平常点好，争这个争那个，争来争去赔了自己的命。像我这样，说起来是越混越没出息，可寿命长，我认识的人一个挨着一个死去，我还活着。</p></li></ul></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 书摘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左程云算法复习</title>
      <link href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="概念澄清"><a href="#概念澄清" class="headerlink" title="概念澄清"></a>概念澄清</h1><ul><li>子串：[start…end],连续的。</li><li>子序列：也是从左到右拿的元素，但是可以不连续。</li><li>子数组：一个或连续多个数组中的元素组成一个子数组。</li></ul><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul><li>链表题如果需要dummy的话使用unique_ptr不内存泄露。其他情况也<strong>考虑使用智能指针不内存泄露。</strong></li><li>左程云：优化一个问题从两个方面，一个是数据状况，一个是问题本身，我们通过观察到问题本身的一些性质，来和某些数据结构建立了流程，这就是优化，数据结构的意义。<strong>感悟：写算法题最主要的是培养一种敏感度，培养出一种观测力，唉，怪不得我算法水平还这么烂，因为我很喜欢看标签，我自己看不出这个联系，所以笔试过程还是捞。</strong></li><li>左程云：指针能和范围产生单调性，那一定有优化，要么双指针，要么滑动窗口，要么别的。</li><li>子串，子数组的问题，就想，开头是i的时候答案是啥，或者结尾是i的时候答案是啥。</li><li>C/C++笔试的时候，给的时间是1-2s,可以推出来差不多常数操作是10 ^ 8到10 ^ 9左右，当N=10 ^ 6，那说明算法复杂度肯定不会是O(N^2)拿下的。</li></ul><h1 id="典型解法"><a href="#典型解法" class="headerlink" title="典型解法"></a>典型解法</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><ul><li>int mid = l + ((r - l) &gt;&gt; 1);  这种写法比除法速度快，更重要的是防止溢出。</li><li>N * 2 + 1可以写为: ((N &lt;&lt; 1 ) | 1)</li></ul><h3 id="1-有序数组找某个数是否存在"><a href="#1-有序数组找某个数是否存在" class="headerlink" title="1.有序数组找某个数是否存在"></a>1.有序数组找某个数是否存在</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int l =0;</span><br><span class="line">int r = nums.size() -1;</span><br><span class="line">while( l &lt;= r){</span><br><span class="line">    int mid = l + ((r - l) &gt;&gt; 1);</span><br><span class="line">    if(nums[mid] == target){</span><br><span class="line">        ans = mid;</span><br><span class="line">        break;</span><br><span class="line">    }else if (nums[mid] &gt; target){</span><br><span class="line">        r = mid - 1;</span><br><span class="line">    }else{</span><br><span class="line">        l = mid + 1;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==:  <a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></p><h3 id="2-在有序数组中，找-gt-x3D-某个数最左侧位置"><a href="#2-在有序数组中，找-gt-x3D-某个数最左侧位置" class="headerlink" title="2.在有序数组中，找>=某个数最左侧位置"></a>2.在有序数组中，找&gt;=某个数最左侧位置</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r = grid.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>( l &lt;= r){</span><br><span class="line">    <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(grid[mid] &gt;=target){</span><br><span class="line">        flag = mid;</span><br><span class="line">        r = mid<span class="number">-1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/">1351. 统计有序矩阵中的负数</a></p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h3 id="3-在有序数组中，找-lt-x3D-某个数最右侧位置"><a href="#3-在有序数组中，找-lt-x3D-某个数最右侧位置" class="headerlink" title="3.在有序数组中，找<=某个数最右侧位置"></a>3.在有序数组中，找&lt;=某个数最右侧位置</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r = grid.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>( l &lt;= r){</span><br><span class="line">    <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(grid[mid] &lt;=target){</span><br><span class="line">        flag = mid;</span><br><span class="line">        </span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        r = mid<span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h3 id="4-局部最小值问题"><a href="#4-局部最小值问题" class="headerlink" title="4.局部最小值问题"></a>4.局部最小值问题</h3><p>保证左侧边界是下降趋势，右侧边界是上升趋势，否则低估值就在左右边界，不然的话就一定在中间位置。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240603091539293.png" alt="image-20240603091539293"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (nums.size() == 1 || nums[0] &lt; nums[1])return 0;</span><br><span class="line">if (nums[nums.size() - 1] &lt; nums[nums.size() - 2])return nums.size() - 1;</span><br><span class="line"></span><br><span class="line">int l =1;</span><br><span class="line">int r = nums.size() - 2;</span><br><span class="line">int mid = 0;</span><br><span class="line">while ( l &lt; r ){</span><br><span class="line">mid = l + ((r - l) &gt;&gt;1);</span><br><span class="line">if (nums[mid] &gt; nums[mid - 1]){</span><br><span class="line">// 上升趋势，左边必有</span><br><span class="line">right = mid - 1;</span><br><span class="line">}else if (nums[mid] &gt; nums[mid + 1]){</span><br><span class="line">// 下降趋势，右边必有</span><br><span class="line">left = mid + 1;</span><br><span class="line">}else{</span><br><span class="line">return mid;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">return left;</span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p>局部最大：<a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="1-异或运算"><a href="#1-异或运算" class="headerlink" title="1.异或运算"></a>1.异或运算</h3><ul><li>0 ^ N == N   N ^ N == 0</li><li>异或运算满足交换律和结合律</li></ul><h4 id="1）不用额外变量交换两个数"><a href="#1）不用额外变量交换两个数" class="headerlink" title="1）不用额外变量交换两个数"></a>1）不用额外变量交换两个数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>,b = <span class="number">5</span>;</span><br><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="2-个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#2-个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="2) 个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>2) 个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> eor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++){</span><br><span class="line">    eor ^= arr[i];</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; eor;</span><br></pre></td></tr></tbody></table></figure><h4 id="3）提取出二进制最右侧的1"><a href="#3）提取出二进制最右侧的1" class="headerlink" title="3）提取出二进制最右侧的1"></a>3）提取出二进制最右侧的1</h4><p>int rightOne = eor &amp; (~eor + 1);</p><h4 id="4-有两种数出现奇数次-，其他都偶数次"><a href="#4-有两种数出现奇数次-，其他都偶数次" class="headerlink" title="4) 有两种数出现奇数次,，其他都偶数次:"></a>4) 有两种数出现奇数次,，其他都偶数次:</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int eor = 0;</span><br><span class="line">for(int i=0;i&lt;nums.size();i++){</span><br><span class="line">    eor ^= arr[i];</span><br><span class="line">}</span><br><span class="line">// eor = a ^ b ,eor必然一个位置是1</span><br><span class="line">int rightOne = eor &amp; (~eor + 1);</span><br><span class="line">int onlyOne = 0;</span><br><span class="line">for(int i=0;i&lt;nums.size();i++){</span><br><span class="line">if ((nums[i] &amp; rightOne) != 0){</span><br><span class="line">onlyOne ^= nums[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">int a = onlyOne;// rightOne为1的出现奇数次的数。</span><br><span class="line">int b = eor^ a;</span><br></pre></td></tr></tbody></table></figure><h4 id="5）二进制中1的个数"><a href="#5）二进制中1的个数" class="headerlink" title="5）二进制中1的个数"></a>5）二进制中1的个数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (N!=<span class="number">0</span>){</span><br><span class="line">    <span class="type">int</span> rightOne = N &amp; ((~N) + <span class="number">1</span>);</span><br><span class="line">    cnt++;</span><br><span class="line">    N ^=rightOne;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="6）-判断num是否是2的某次方"><a href="#6）-判断num是否是2的某次方" class="headerlink" title="6） 判断num是否是2的某次方"></a>6） 判断num是否是2的某次方</h4><p><code>num &amp; (num - 1) == 0</code>则是2的某次方。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>注：</p><ul><li>注意换头的操作。</li><li>有环链表的第一个入环节点：快慢指针同时走，如果相交就是有环，然后快指针回到起点一格一格走，慢指针继续一格一格走，他俩终将在起点相遇。</li></ul><h3 id="1-单链表反转"><a href="#1-单链表反转" class="headerlink" title="1.单链表反转"></a>1.单链表反转</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">    ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head){</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/UHnkqh/">LCR 024. 反转链表</a></p><h3 id="2-双链表反转"><a href="#2-双链表反转" class="headerlink" title="2.双链表反转"></a>2.双链表反转</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ListNode* reverseList(ListNode* head) {</span><br><span class="line">    ListNode* prev = nullptr;</span><br><span class="line">    ListNode* next = nullptr;</span><br><span class="line">    while(head){</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        head-&gt;last = next;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    return prev;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="3-删除给定值"><a href="#3-删除给定值" class="headerlink" title="3.删除给定值"></a>3.删除给定值</h3><p>也存在换头的情况.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(!head)<span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> prev = newHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(head &amp;&amp; head-&gt;val == val){</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    newHead-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span>(cur){</span><br><span class="line">        <span class="keyword">auto</span> next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val == val){</span><br><span class="line">            prev-&gt;next = next;</span><br><span class="line">            </span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            prev = cur;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        cur = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></p><h3 id="3-中间节点"><a href="#3-中间节点" class="headerlink" title="3.中间节点"></a>3.中间节点</h3><p>。。。</p><h3 id="4-判断给定链表是否是回文结构"><a href="#4-判断给定链表是否是回文结构" class="headerlink" title="4.判断给定链表是否是回文结构"></a>4.判断给定链表是否是回文结构</h3><p>时间复杂度O(N)，空间复杂度O(N)的解法： 首先遍历一遍存入栈中，然后从栈中弹出，并且设置cur指针为head，进行逐个比较有不一样的返回false，否则返回true。</p><p>时间复杂度O(N)，空间复杂度O(N/2)的解法： 只存右半部的逆序在栈中。</p><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></p><h3 id="5-链表partition"><a href="#5-链表partition" class="headerlink" title="5.链表partition"></a>5.链表partition</h3><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><ul><li>笔试做法：链表放到数组里做partition。</li><li>面试做法：分为小、中、大三部分，再把各个部分之间串起来。只需要6个变量：小于区的头尾，等于区的头尾，大于区的头尾，并且还是稳定的。</li></ul><p><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></p><h3 id="6-138-随机链表的复制"><a href="#6-138-随机链表的复制" class="headerlink" title="6.138. 随机链表的复制"></a>6.<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></h3><h3 id="7-给定两个可能有环也可能无环的单链表，头节点head1和head2请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null要求】如果两个链表长度之和为N，时间复杂度请达到O-N-，额外空间复杂度-请达到O-1-。"><a href="#7-给定两个可能有环也可能无环的单链表，头节点head1和head2请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null要求】如果两个链表长度之和为N，时间复杂度请达到O-N-，额外空间复杂度-请达到O-1-。" class="headerlink" title="7.给定两个可能有环也可能无环的单链表，头节点head1和head2请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null要求】如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。"></a>7.给定两个可能有环也可能无环的单链表，头节点head1和head2请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null要求】如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。</h3><p>一个很坑的链表题。</p><p>思路：这个题很复杂，因为case较多:1.两个链表都没有环。2.两个链表都有环，这种情况很复杂，可能不想交，也可能入环的点是同一个，也可能入环的点是不同的3.一个有环，一个没有环。对于这种情况，<strong>是不可能相交的，脑补出来的相交的都是错的。。</strong></p><p>判断链表是否有环的最拉的做法： 用set来判断是否有环，或者用快慢指针。</p><h3 id="8-不给链表头结点，只给想要删除的节点做到把链表上这个节点删掉？"><a href="#8-不给链表头结点，只给想要删除的节点做到把链表上这个节点删掉？" class="headerlink" title="8.不给链表头结点，只给想要删除的节点做到把链表上这个节点删掉？"></a>8.不给链表头结点，只给想要删除的节点做到把链表上这个节点删掉？</h3><p>直接cur-&gt;val = cur-&gt;next-&gt;val给覆盖掉吧。。当然这种方法有问题，一来是伪删除，二来是最后一个节点删不了。 </p><p>所以如果面试官问这个问题的话，只是想考你知不知道这种删除方法有问题。</p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><ul><li>可以用双向链表，数组来实现。</li><li>图的宽度优先遍历是队列实现的，深度优先遍历是栈实现的。</li></ul><h3 id="1-返回最小值"><a href="#1-返回最小值" class="headerlink" title="1.返回最小值"></a>1.返回最小值</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MinStack {</span><br><span class="line">public:</span><br><span class="line">    MinStack() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    void push(int val) {</span><br><span class="line">        stack_.push_back(val);</span><br><span class="line">        if(min_stack_.empty()){</span><br><span class="line">            min_stack_.push_back(val);</span><br><span class="line">        }else if (min_stack_.back() &lt; val){</span><br><span class="line">            min_stack_.push_back(min_stack_.back());</span><br><span class="line">        }else{</span><br><span class="line">            min_stack_.push_back(val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    void pop() {</span><br><span class="line">        if(stack_.empty()){</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">        stack_.pop_back();</span><br><span class="line">        min_stack_.pop_back();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    int top() {</span><br><span class="line">        return stack_.back();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    int getMin() {</span><br><span class="line">        return min_stack_.back();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::vector&lt;int&gt; stack_;</span><br><span class="line">    std::vector&lt;int&gt; min_stack_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></p><h3 id="2-栈实现队列"><a href="#2-栈实现队列" class="headerlink" title="2.栈实现队列"></a>2.栈实现队列</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_to_pop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(pop_stack_.<span class="built_in">empty</span>()){</span><br><span class="line">            <span class="keyword">while</span>(!push_stack_.<span class="built_in">empty</span>()){</span><br><span class="line">                <span class="type">int</span> val = push_stack_.<span class="built_in">back</span>();</span><br><span class="line">                pop_stack_.<span class="built_in">push_back</span>(val);</span><br><span class="line">                push_stack_.<span class="built_in">pop_back</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        push_stack_.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="built_in">push_to_pop</span>();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(pop_stack_.<span class="built_in">empty</span>() &amp;&amp; push_stack_.<span class="built_in">empty</span>()){</span><br><span class="line">            <span class="comment">//错误处理</span></span><br><span class="line">            ;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">push_to_pop</span>();</span><br><span class="line">        <span class="type">int</span> val = pop_stack_.<span class="built_in">back</span>();</span><br><span class="line">        pop_stack_.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(pop_stack_.<span class="built_in">empty</span>() &amp;&amp; push_stack_.<span class="built_in">empty</span>()){</span><br><span class="line">            <span class="comment">//错误处理</span></span><br><span class="line">            ;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">push_to_pop</span>();</span><br><span class="line">        <span class="type">int</span> val = pop_stack_.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> pop_stack_.<span class="built_in">empty</span>() &amp;&amp; push_stack_.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; push_stack_{};</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; pop_stack_{};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></p><h3 id="3-队列实现栈"><a href="#3-队列实现栈" class="headerlink" title="3.队列实现栈"></a>3.队列实现栈</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        helper_.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!queue_.<span class="built_in">empty</span>()){</span><br><span class="line">            helper_.<span class="built_in">push</span>(queue_.<span class="built_in">front</span>());</span><br><span class="line">            queue_.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">swap</span>(queue_,helper_);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> r = queue_.<span class="built_in">front</span>();</span><br><span class="line">        queue_.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> r = queue_.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> queue_.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; queue_{};</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; helper_{};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>递归行为的实现复杂度如何分析？ <strong>Master公式。</strong>  左程云网课2.算法 链表结构、栈、队列、递归行为、哈希表的2小时4分钟。</li></ul><h3 id="1-递归求arr中的最大值"><a href="#1-递归求arr中的最大值" class="headerlink" title="1.递归求arr中的最大值"></a>1.递归求arr中的最大值</h3><p>arr的范围是[L…..R],首先把arr分为[L…mid]和[mid…R]，然后就可以求左边的最大值，和右边的最大值，最后再max，时间复杂度O(N):</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp;arr ,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(L == R){</span><br><span class="line">       <span class="keyword">return</span> arr[L];</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> mid = L + ((R - L ) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">process</span>(arr,L,mid);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">process</span>(arr,mid + <span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(leftMax,rightMax);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul><li>哈希表的增删改查在使用时都是O(1)</li></ul><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240629102143048.png" alt="image-20240629102143048"></p><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul><li>url使用不同的哈希函数求值并取模m，在位图中置1，此时url被加入到了黑名单，如果此时新的url来了，那么继续上面的过程，来判断一下是否位图都为1，如果是，说明url被加入到了黑名单，当然可能会有失误的，不过误杀还行。</li><li>布隆过滤器希望知道预期失误率P，样本量N，m是位图的大小。N是一定了，很明显，m越大，P越小。</li><li></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240605083420334.png" alt="image-20240605083420334"></p><p>递归实现归并排序:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort1</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>() || arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">process</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>( L == R){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> mid = L + ((R - L ) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">process</span>(arr,L,mid);</span><br><span class="line">    <span class="built_in">process</span>(arr,mid+<span class="number">1</span>,R);</span><br><span class="line">    <span class="built_in">merge</span>(arr,L,mid,R);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> mid,<span class="type">int</span> R)</span></span>{</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">help</span><span class="params">(R-L +<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p1 = L;</span><br><span class="line">    <span class="type">int</span> p2 = M +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= M &amp;&amp; p2 &lt;= R){</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2]?:arr[p1++]:arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M){</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;=R){</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; help.<span class="built_in">size</span>();i++){</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>非递归版实现归并排序</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort2</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>() || arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//mergeSize为merge的窗口</span></span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; N){</span><br><span class="line">        <span class="type">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N){</span><br><span class="line">            <span class="type">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(M &gt;= N){</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">int</span> R = <span class="built_in">min</span>(M + mergeSize,N - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">merge</span>(arr,L,M,R);</span><br><span class="line">            L = R + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>){</span><br><span class="line">            <span class="comment">//防止溢出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        merSize &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> mid,<span class="type">int</span> R)</span></span>{</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">help</span><span class="params">(R-L +<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p1 = L;</span><br><span class="line">    <span class="type">int</span> p2 = M +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= M &amp;&amp; p2 &lt;= R){</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2]?:arr[p1++]:arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M){</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;=R){</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; help.<span class="built_in">size</span>();i++){</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="数组小和"><a href="#数组小和" class="headerlink" title="数组小和"></a>数组小和</h4><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240605085755176.png" alt="image-20240605085755176"></p><p>求解的核心，在merge操作时，当发现左侧指针的值比右侧的小时，产生从右组指针到右组底个小和，当左组数和右数组的数相等的时候，拷贝右组的数，不产生小和。当左数组的数大于有数组的时候，拷贝右组的数不产生小和。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">smallSum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>{</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>() || arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr,<span class="number">0</span>,arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>( L == R){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> mid = L + ((R - L ) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr,L,mid) + <span class="built_in">process</span>(arr,mid+<span class="number">1</span>,R) + <span class="built_in">merge</span>(arr,L,mid,R);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> L,<span class="type">int</span> mid,<span class="type">int</span> R)</span></span>{</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">help</span><span class="params">(R-L +<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> p1 = L;</span><br><span class="line">    <span class="type">int</span> p2 = M +<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= M &amp;&amp; p2 &lt;= R){</span><br><span class="line">        res += arr[p1] &lt; arr[p2]?:(r - p2 + <span class="number">1</span>) * arr[p1]:<span class="number">0</span>;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2]?:arr[p1++]:arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M){</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;=R){</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; help.<span class="built_in">size</span>();i++){</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h3><h4 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h4><p>给定一个数组arr，和一个整数num。请把小于等于num的数放在数组的左边,等于num在中间，大于num的数放在数组的右边。要求额外空间O(1),时间复杂度O(N)。</p><p><strong>思路</strong>：记录一个小于等于区，从-1开始，如果当前数和小于等于区的下一个数交换，然后小于等于区向右扩，否则直接i++</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>==力扣原题==</p><p><a href="https://leetcode.cn/problems/partition-array-according-to-given-pivot/">2161. 根据给定数字划分数组</a></p><h2 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h2><ul><li>堆就是用数组实现的完全二叉树。</li><li>完全二叉树中如果每棵子树的最大值都在顶部就是大根堆，如果每课子树的最小值都在顶部就是小根堆。</li><li>找第k大的数，就用小根堆，第k小的数，就用大根堆。</li></ul><h3 id="1-已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。"><a href="#1-已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。" class="headerlink" title="1.已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。"></a>1.已知一个几乎有序的数组。几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。请选择一个合适的排序策略，对这个数组进行排序。</h3><p>小根堆。每k个一组的做。</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><ul><li>对于长度为N的字符串数组，生成前缀树的时间复杂度是O(N)</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1.遍历"></a>1.遍历</h3><ol><li>先序、中序、后序。递归与非递归版，非递归版栈实现。</li><li>任何一个节点都有机会去他的左树转一圈回到他收集一次信息，然后再在他的右树转一圈回到他收集一次信息，还能第三次回到他把左右两次信息做个整合，这是树形dp的基础:</li></ol><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240612085535693.png" alt="image-20240612085535693"></p><ol start="3"><li>宽度优先遍历，就是使用队列。</li><li>二叉树的序列化和反序列化，在反序列化时通过队列来进行实现。</li><li>二叉树的按层序列化。</li></ol><h3 id="2-二叉树的递归套路"><a href="#2-二叉树的递归套路" class="headerlink" title="2.二叉树的递归套路"></a>2.二叉树的递归套路</h3><ol><li>打印整颗二叉树。</li><li>给一个有指向上面的指针，后继节点是指中序遍历得到的数组的下一个节点。暴力的思路就是可以找到头结点，通过一直往上指，然后找到头结点后玩一下中序遍历，这个时间复杂度是O(N)的。有一种O(k)的解法，k指节点本身和后继节点的位置：假设X有右树，那么他后继节点一定是右树的最左节点。 如果X没有右树，那看他是不是父节点的左节点，如果是的话，那他的后继就是他的父节点，如果是父节点的右节点，<strong>那么他的是左孩子的祖父节点就是他的后继节点。</strong>或者可以改说为 某个节点是他左子节点的右节点的后继节点。</li><li>给二叉树头结点，然后返回二叉树种的最大的二叉搜索子树的头结点，或者说返回最大二叉搜索子树的大小。</li><li>给二叉树头结点，返回最大的任意两节点的距离。</li><li>派对的最大快乐值。</li><li>给二叉树头结点，判断二叉树是不是满二叉树。</li><li>a,b节点的最低公共祖先。</li></ol><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><ul><li>最自然智慧的算法</li><li>用一种局部最功利的标准，总是作出在当前看来是最好的选择。</li><li>难点在于证明局部最功利的标准可以得到全局最优解。</li><li>贪心算法多练，没啥公式。</li><li>贪心需要分析业务，根据业务逻辑找到不同的贪心策略，对于能举出反例的策略直接跳过，不能举出反例的策略要证明有效性。</li><li>贪心很常用堆和排序。</li></ul><p><a href="https://leetcode.cn/problems/ipo/">502. IPO</a> 收益问题。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ul><li>查询时间复杂度O(1)</li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul><li>图的难点在于数据结构，比如可以通过邻接表法和邻接矩阵法，我们去熟悉一个数据结构就行了。我们把图都理解为有向图。</li><li>队列实现宽度优先遍历，与树不同的是需要准备一个set，因为一个节点可能多次来到。在出栈的时候打印。</li><li>栈实现深度优先遍历，同时也需要一个set来判断节点是否到来过。在进栈的时候打印。</li><li>拓扑排序，最小生成树。Dijkstra</li></ul><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><ul><li>经典的汉诺塔问题。</li><li>用递归方法来逆序一个栈。</li></ul><h2 id="递归到动态规划"><a href="#递归到动态规划" class="headerlink" title="递归到动态规划"></a>递归到动态规划</h2><ol><li>从左到右的尝试模型</li><li>范围上的尝试模型</li><li></li></ol><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><ul><li>时间复杂度O(N)</li><li>对于含重复值的情况，可以用一个vector来维护每一个值相等的情况。</li><li>发现题目具有单调性的话，可以使用单调栈来做。</li></ul><h2 id="滑动窗口内的最大值和最小值的更新"><a href="#滑动窗口内的最大值和最小值的更新" class="headerlink" title="滑动窗口内的最大值和最小值的更新"></a>滑动窗口内的最大值和最小值的更新</h2><ul><li>L…R是窗口的大小（L &lt;= R)，R++是新数进，L++表示出去了一个数。</li><li>滑动窗口一直维护最大值可以用双端队列来实现，双端队列存索引。R++时从尾部添加队列，并且保证[R]在队列中，他前面没有比他小的，否则把比他小的弹出。L++时从头弹过期的。    【<strong>其实稍加修改就是单调栈了</strong>】</li></ul><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>假设一个固定大小为W的窗口，依次划过arr，返回每一次滑出状况的最大值，例如，arr =[4,3,5,4,3.3,6,7],W=3，返回:[5,5,5.4,6.7]</p><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p>给定一个整型数组arr，和一个整数num，某个arr中的子数组sub，如果想达标，必须满足sub中最大值-sub中最小值&lt;=num,返回arr中达标子数组的数量</p><ul><li>思路：做两个窗口，一个维护窗口最大值，一个维护窗口最小值，然后向右拓展R，拓展到终于不达标，然后来找以[L..]为开头的子数组数量有多少个，求完后把L++，继续扩R。</li></ul><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>给定一个只包含正整数的数组arr，arr中任何一个子数组sub一定都可以算出(sub累加和)*(sub中的最小值)是什么，那么所有子数组中，这个值最大是多少?</p><ul><li>首先可以遍历一遍arr来得到前缀和数租，然后再找以i为子数组最小值的情况下sub累加和*[i]。</li><li>用单调栈即可。</li></ul><h2 id="数组三连问题"><a href="#数组三连问题" class="headerlink" title="数组三连问题"></a>数组三连问题</h2><h3 id="1-arr全是整数，求最长的子数组和等于给定sum的长度。"><a href="#1-arr全是整数，求最长的子数组和等于给定sum的长度。" class="headerlink" title="1.arr全是整数，求最长的子数组和等于给定sum的长度。"></a>1.arr全是整数，求最长的子数组和等于给定sum的长度。</h3><p>有单调性，可以用滑动窗口来求。 （就是随着子数组范围的增加，子数组的和是增加的。</p><h3 id="2-arr有正，有负，有0-，求最长的子数组和等于给定sum的长度。"><a href="#2-arr有正，有负，有0-，求最长的子数组和等于给定sum的长度。" class="headerlink" title="2.arr有正，有负，有0 ，求最长的子数组和等于给定sum的长度。"></a>2.arr有正，有负，有0 ，求最长的子数组和等于给定sum的长度。</h3><p>这个时候没有单调性了就。。</p><p>附加题：在一个数组中，想知道哪个子数组里含有一的数量和含有二的数量是一样多的，这种子数组叫做达标子数组，然后想知道达标子数组中哪个是最长的。</p><p>附加题的解题思路：我们可以把非1,2的变为0，把2变为负一，那这就是求最长的子数组和等于0的问题了！牛逼。</p><h2 id="技巧类的算法"><a href="#技巧类的算法" class="headerlink" title="技巧类的算法"></a>技巧类的算法</h2><h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><ul><li>eg: 10^n 计算复杂度为log(n)</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int qpow(int a, int n){</span><br><span class="line">    int ans = 1;</span><br><span class="line">    while(n){</span><br><span class="line">        if(n&amp;1)        //如果n的当前末位为1</span><br><span class="line">            ans *= a;  //ans乘上当前的a</span><br><span class="line">        a *= a;        //a自乘</span><br><span class="line">        n &gt;&gt;= 1;       //n往右移一位</span><br><span class="line">    }</span><br><span class="line">    return ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h3><h3 id="等概率算法"><a href="#等概率算法" class="headerlink" title="等概率算法"></a>等概率算法</h3><p>有一个等概率返回1-7的f(x)，请实现一个g(x)返回等概率的1-10.</p><ul><li>简单的方法：f(x)一返回7就让他重新，对于1-6，则奇数返回1，偶数返回0，然后实现了一个辅助函数h(x)可以产生0,1的二进制，然后用h(x)来生成g(x),可能此时的范围是0 -15,那么对于10到15的话，就让他重新仍就好了。</li><li></li></ul><h3 id="类似斐波那契数列的递归"><a href="#类似斐波那契数列的递归" class="headerlink" title="类似斐波那契数列的递归"></a>类似斐波那契数列的递归</h3><ul><li>对于形如F(N) = C1F(n-1) + C2F(n-2) + …CzF(n-k)的函数，C1，C2,…Cz为常数，他的时间复杂度为O(logN).</li></ul><h3 id="打表法"><a href="#打表法" class="headerlink" title="打表法"></a>打表法</h3><ul><li>面试题输入参数类型简单并且只有一个实参，返回的类型也简单并且只有一个，用暴力的方法把输入参数对应的返回值打印出来看看，进而找规律。</li></ul><h3 id="矩阵处理技巧"><a href="#矩阵处理技巧" class="headerlink" title="矩阵处理技巧"></a>矩阵处理技巧</h3><ul><li>zagzig打印矩阵。</li><li></li></ul><h1 id="经典代码"><a href="#经典代码" class="headerlink" title="经典代码"></a>经典代码</h1><h2 id="二叉树-1"><a href="#二叉树-1" class="headerlink" title="二叉树"></a>二叉树</h2><p>遍历的经典代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    void process(TreeNode* node,vector&lt;int&gt;&amp; path){</span><br><span class="line">        if(!node)return;</span><br><span class="line">        if(!node-&gt;left &amp;&amp; !node-&gt;right){</span><br><span class="line">            path.push_back(node-&gt;val);</span><br><span class="line">            paths.push_back(path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        path.push_back(node-&gt;val);</span><br><span class="line">        process(node-&gt;left,path);</span><br><span class="line">        process(node-&gt;right,path);</span><br><span class="line">        path.pop_back();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; paths;</span><br></pre></td></tr></tbody></table></figure><p>层序遍历经典:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; ans{};</span><br><span class="line">if(!root)return ans;</span><br><span class="line"></span><br><span class="line">queue&lt;TreeNode*&gt; queue;</span><br><span class="line">queue.push(root);</span><br><span class="line">auto curEnd = root;</span><br><span class="line">TreeNode* nextEnd = nullptr;</span><br><span class="line">vector&lt;int&gt; tmp;</span><br><span class="line">while(!queue.empty()){</span><br><span class="line">    TreeNode* cur = queue.front();</span><br><span class="line">    queue.pop();</span><br><span class="line">    tmp.push_back(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">    if(cur-&gt;left){</span><br><span class="line">        queue.push(cur-&gt;left);</span><br><span class="line">        nextEnd = cur-&gt;left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if(cur-&gt;right){</span><br><span class="line">        queue.push(cur-&gt;right);</span><br><span class="line">        nextEnd = cur-&gt;right;</span><br><span class="line">    }</span><br><span class="line">    if(cur == curEnd){</span><br><span class="line">        ans.push_back(tmp);</span><br><span class="line">        curEnd = nextEnd;</span><br><span class="line">        tmp.clear();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最大公约数:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b) {</span><br><span class="line">    if (b == 0) {</span><br><span class="line">        return a;</span><br><span class="line">    } else {</span><br><span class="line">        return gcd(b, a % b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>反转链表:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ListNode* reverseList(ListNode* head) {</span><br><span class="line">    ListNode* prev = nullptr;</span><br><span class="line">    ListNode* next = nullptr;</span><br><span class="line">    while(head){</span><br><span class="line">        next = head-&gt;next;</span><br><span class="line">        head-&gt;next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    return prev;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 获得i左边和右边比他大的元素</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; nextGreater(nums2.size(), vector&lt;int&gt;(2, -1));</span><br><span class="line">vector&lt;int&gt; stack{}, res{};</span><br><span class="line">for (int i = 0; i &lt; nums2.size(); i++)</span><br><span class="line">{</span><br><span class="line">    num12num2[nums2[i]] = i;</span><br><span class="line">    while (!stack.empty() &amp;&amp; nums2[stack.back()] &lt; nums2[i])</span><br><span class="line">    {</span><br><span class="line">        int popIndex = stack.back();</span><br><span class="line">        stack.pop_back();</span><br><span class="line">        int leftGreaterIndex = stack.empty() ? -1 : stack.back();</span><br><span class="line">        nextGreater[popIndex][0] = leftGreaterIndex;</span><br><span class="line">        nextGreater[popIndex][1] = i;</span><br><span class="line">    }</span><br><span class="line">    stack.push_back(i);</span><br><span class="line">}</span><br><span class="line">while (!stack.empty())</span><br><span class="line">{</span><br><span class="line">    int popIndex = stack.back();</span><br><span class="line">    stack.pop_back();</span><br><span class="line">    int leftGreaterIndex = stack.empty() ? -1 : stack.back();</span><br><span class="line">    nextGreater[popIndex][0] = leftGreaterIndex;</span><br><span class="line">    nextGreater[popIndex][1] = -1;</span><br><span class="line">}</span><br><span class="line">// for (int i = 0; i &lt; nextGreater.size(); i++)</span><br><span class="line">// {</span><br><span class="line">//     cout &lt;&lt; nextGreater[i][0] &lt;&lt; " " &lt;&lt; nextGreater[i][1] &lt;&lt; endl;</span><br><span class="line">// }</span><br></pre></td></tr></tbody></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>leetcode207.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>{</span><br><span class="line">    <span class="comment">// prerequisites中每个元素为[a,b],其中要学a需要先学b</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pre : prerequisites) {</span><br><span class="line">        graph[pre[<span class="number">1</span>]].<span class="built_in">push_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        indegree[pre[<span class="number">0</span>]]++;</span><br><span class="line">    }</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">// 入度为0的节点入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="type">int</span> course = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[course]) {</span><br><span class="line">            indegree[neighbor]--;</span><br><span class="line">            <span class="keyword">if</span> (indegree[neighbor] == <span class="number">0</span>) {</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="前缀树-1"><a href="#前缀树-1" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class Trie</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    Trie()</span><br><span class="line">    {</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void insert(string word)</span><br><span class="line">    {</span><br><span class="line">        auto cur = root;</span><br><span class="line">        for (int i = 0; i &lt; word.size(); i++)</span><br><span class="line">        {</span><br><span class="line">            int index = word[i] - 'a';</span><br><span class="line">            if (cur-&gt;children[index] == nullptr)</span><br><span class="line">            {</span><br><span class="line">                cur-&gt;children[index] = new TrieNode();</span><br><span class="line">            }</span><br><span class="line">            cur = cur-&gt;children[index];</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;isEnd = true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bool search(string word)</span><br><span class="line">    {</span><br><span class="line">        auto cur = root;</span><br><span class="line">        for (int i = 0; i &lt; word.size(); i++)</span><br><span class="line">        {</span><br><span class="line">            int index = word[i] - 'a';</span><br><span class="line">            if (cur-&gt;children[index] == nullptr)</span><br><span class="line">            {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">            cur = cur-&gt;children[index];</span><br><span class="line">        }</span><br><span class="line">        return cur-&gt;isEnd;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bool startsWith(string prefix)</span><br><span class="line">    {</span><br><span class="line">        auto cur = root;</span><br><span class="line">        for (int i = 0; i &lt; prefix.size(); i++)</span><br><span class="line">        {</span><br><span class="line">            int index = prefix[i] - 'a';</span><br><span class="line">            if (cur-&gt;children[index] == nullptr)</span><br><span class="line">            {</span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">            cur = cur-&gt;children[index];</span><br><span class="line">        }</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    struct TrieNode</span><br><span class="line">    {</span><br><span class="line">        TrieNode *children[26];</span><br><span class="line">        bool isEnd;</span><br><span class="line">        TrieNode()</span><br><span class="line">        {</span><br><span class="line">            for (int i = 0; i &lt; 26; i++)</span><br><span class="line">            {</span><br><span class="line">                children[i] = nullptr;</span><br><span class="line">            }</span><br><span class="line">            isEnd = false;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    TrieNode *root{nullptr};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="其他题"><a href="#其他题" class="headerlink" title="其他题"></a>其他题</h1><h2 id="达标字符串"><a href="#达标字符串" class="headerlink" title="达标字符串"></a>达标字符串</h2><p>给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串如果某个字符串,任何0字符的左边都有1紧挨着,认为这个字符串达标返回有多少达标的字符串</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左程云经典面试题</title>
      <link href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点"><a href="#给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点" class="headerlink" title="给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点"></a>给定一个有序数组arr，从左到右依次表示X轴上从左往右点的位置给定一个正整数K，返回如果有一根长度为K的绳子，最多能盖住几个点</h1><p>绳子的边缘点碰到X轴上的点，也算盖住</p><p>解题思路：二分，我们对绳子的右端点固定住，假如说右端点放在了103的位置，那么对于绳子的左端点，通过二分法对[L….102]去二分，来找到103 - K的位置。这是一个N*logN的方法，不是最优。</p><p>解题思路2：窗口法，因为有单调性。这是o(N)的方法。</p><h1 id="题目二：判断括号是否有效配对"><a href="#题目二：判断括号是否有效配对" class="headerlink" title="题目二：判断括号是否有效配对"></a>题目二：判断括号是否有效配对</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240701091323668.png" alt="image-20240701091323668"></p><p>对于问题1：只用一个变量也可以行的，遇到左括号cnt++，遇到右括号cnt–；如果cnt&lt;0过，返回false；如果遍历完了cnt!=0,返回false，否则返回true。</p><p>对于问题2：和问题1差不多，在1的基础上，如果cnt=-1了，就对need++，同时cnt重新恢复为0，最后返回need+cnt。need说明了需要多少个左括号，cnt说明了需要多少个右括号。</p><h1 id="题目三-最长的括号有效子串的长度（稍微难需要细节把握）"><a href="#题目三-最长的括号有效子串的长度（稍微难需要细节把握）" class="headerlink" title="题目三 最长的括号有效子串的长度（稍微难需要细节把握）"></a>题目三 最长的括号有效子串的长度（稍微难需要细节把握）</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240702084121504.png" alt="image-20240702084121504"></p><p>解题思路： 设计一个dp，如果s[i]是左括号，dp[i] = 0,因为不会以左括号为有效的括号结尾。另外，dp[0]也一定是0，因为0位置少和他配对的。如果s[i]是右括号，那么因为dp[i-1]说明了必须以i-1结尾的多长，那么i-1 - dp[i - 1] 如果是左括号，dp[i] = dp[i-1] + 2,同时，我们还需要再往前看一步，看看dp[i - 1 -dp[i-1]-1] 是否不为0 ，如果不为0我们就也给他加上去。 </p><h4 id="附加题：有效括号最大嵌套基层。"><a href="#附加题：有效括号最大嵌套基层。" class="headerlink" title="附加题：有效括号最大嵌套基层。"></a>附加题：有效括号最大嵌套基层。</h4><p>题目已经保证了是个有效的括号串，很简单，遇到左括号cnt++，遇到右括号cnt–，cnt的最大值就是答案。</p><h1 id="题目四-最少需要涂染几个正方形"><a href="#题目四-最少需要涂染几个正方形" class="headerlink" title="题目四 最少需要涂染几个正方形"></a>题目四 最少需要涂染几个正方形</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240702090337603.png" alt="image-20240702090337603"></p><p>解题思路： 枚举每一个分界线，然后最后找最少的就好了。对于每一个分界线，去找左边G的数量和右边R的数量，这就是需要变的。分界线通过两个数组L,R来做，L是从左往右遍历，R是从右往左遍历。</p><h1 id="题目五-全1的最大正方形的边长"><a href="#题目五-全1的最大正方形的边长" class="headerlink" title="题目五 全1的最大正方形的边长"></a>题目五 全1的最大正方形的边长</h1><p>最快也是O(n^3),因为利用了预处理数组来进行了优化。</p><h1 id="题目六-任意i-j-k可以构造arr-i-arr-k-x3D-2-arr-j"><a href="#题目六-任意i-j-k可以构造arr-i-arr-k-x3D-2-arr-j" class="headerlink" title="题目六 任意i,j,k可以构造arr[i] + arr[k] != 2 * arr[j]"></a>题目六 任意i,j,k可以构造arr[i] + arr[k] != 2 * arr[j]</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240703092135088.png" alt="image-20240703092135088"></p><p>分治算法。 假如我们已经有了 a +c != 2b,那么我们可以对a,b,c进行奇数的映射，变为(2a-1) + (2c-1) != 2b-1;另外，我们对他进行偶数的变化，也是有效的: 2a + 2c !=2b;</p><p>这个题有点黑。。差不多会就是会了，不会就是不会了。</p><h1 id="题目七-二叉树的最大路径和三变种"><a href="#题目七-二叉树的最大路径和三变种" class="headerlink" title="题目七 二叉树的最大路径和三变种"></a>题目七 二叉树的最大路径和三变种</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240704090012200.png" alt="image-20240704090012200"></p><h1 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h1><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>难题，跳过了。</p><h2 id="题目三-最大的左部分最大值减右部分最大值的绝对值"><a href="#题目三-最大的左部分最大值减右部分最大值的绝对值" class="headerlink" title="题目三  最大的左部分最大值减右部分最大值的绝对值"></a>题目三  最大的左部分最大值减右部分最大值的绝对值</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240709084612428.png" alt="image-20240709084612428"></p><p>思路： 不管怎么划分，最后的结果一定是整个数组的max去减去左边的一个值或者减去右边的一个值，看整个数组的这个max被划分到了哪里了，其实再优化一下，就是 allmax - min([0],[n-1])</p><p>这个题其实有一个隐藏的单调性的，随着左边或者有右边的单调性增加，左边或者右边的最大值一定是大于等于[0]或者[n-1]的。</p><h2 id="题目四-最大的装水的容器"><a href="#题目四-最大的装水的容器" class="headerlink" title="题目四 最大的装水的容器"></a>题目四 最大的装水的容器</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240709085350113.png" alt="image-20240709085350113"></p><h2 id="题目五-二维的最大装水容器（hard）"><a href="#题目五-二维的最大装水容器（hard）" class="headerlink" title="题目五 二维的最大装水容器（hard）"></a>题目五 二维的最大装水容器（hard）</h2><p>小根堆去做的，这里pass</p><h2 id="题目六-累加和为target的所有不同的二元组-三元组"><a href="#题目六-累加和为target的所有不同的二元组-三元组" class="headerlink" title="题目六 累加和为target的所有不同的二元组||三元组"></a>题目六 累加和为target的所有不同的二元组||三元组</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240710084920155.png" alt="image-20240710084920155"></p><ul><li>解题思路：对于二元组，使用双指针就行了。</li></ul><h1 id="第三节"><a href="#第三节" class="headerlink" title="第三节"></a>第三节</h1><h2 id="题目一-最高报酬"><a href="#题目一-最高报酬" class="headerlink" title="题目一 最高报酬"></a>题目一 最高报酬</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240711082050217.png" alt="image-20240711082050217"></p><p>思路：难度从小到大排序，钱从大到小排序，那么对于相同难度，低报酬的，删除，对于高难度，却和低难度相同报酬的，也删除，然后把剔除后的数据放到有序表中，然后每个人就找比他难度小一点的就好了。</p><h2 id="题目二-零食放法（背包问题）"><a href="#题目二-零食放法（背包问题）" class="headerlink" title="题目二 零食放法（背包问题）"></a>题目二 零食放法（背包问题）</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240711085349054.png" alt="image-20240711085349054"></p><p>思路：首先是从左到右的尝试模型，对于每一位，都有要或者不要两种选择。</p><h2 id="题目三-最小路径累加和（空间压缩技巧）"><a href="#题目三-最小路径累加和（空间压缩技巧）" class="headerlink" title="题目三 最小路径累加和（空间压缩技巧）"></a>题目三 最小路径累加和（空间压缩技巧）</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240711090922211.png" alt="image-20240711090922211"></p><p>空间压缩技巧：列多行少，可以直接用辅助数组从上往下；行多列少，那就直接用辅助数组从左到右。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小彭老师网课</title>
      <link href="/2024/05/30/%E5%B0%8F%E5%BD%AD%E8%80%81%E5%B8%88%E7%BD%91%E8%AF%BE/"/>
      <url>/2024/05/30/%E5%B0%8F%E5%BD%AD%E8%80%81%E5%B8%88%E7%BD%91%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="【C-20】编译期检测所有未定义行为和内存泄漏，不借助任何外部工具"><a href="#【C-20】编译期检测所有未定义行为和内存泄漏，不借助任何外部工具" class="headerlink" title="【C++20】编译期检测所有未定义行为和内存泄漏，不借助任何外部工具"></a>【C++20】编译期检测所有未定义行为和内存泄漏，不借助任何外部工具</h1><ul><li><strong>使用未初始化的变量就属于未定义行为。</strong></li><li><strong>c++规定，编译期不准触发未定义行为。</strong></li><li>通过添加constexpr来检测是否是未定义的:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530090920675.png" alt="image-20240530090920675"></p><ul><li>编译期的单元测试:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530091209538.png" alt="image-20240530091209538"></p><ul><li>常量表达式不能进行reinterpret_cast,<strong>可以看出多危险。。编译的时候都不通过</strong>:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530092052348.png" alt="image-20240530092052348"></p><ul><li>c++标准为了适配迭代器的end()，允许指针超过实际长度1个字节:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530092222842.png" alt="image-20240530092222842"></p><p>但是超多了就不行了:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530092314228.png" alt="image-20240530092314228"></p><ul><li>*end(a) 错误，不能访问end。</li><li>c风格的转换也是不行的,可以看出是被当做了指针。c也不允许乱转指针是因为x86是小端，为了让c跨平台的语言的保证，所以不允许。</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530092618417.png" alt="image-20240530092618417"></p><ul><li><p>加法溢出：、<img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530092650849.png" alt="image-20240530092650849"></p></li><li><p>int类型的溢出是UB的，但是unigned int类型的溢出是会回环的，是定义的行为。</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240531082211264.png" alt="image-20240531082211264"></p><ul><li>new[]和delete不匹配的未定义行为:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240531082318186.png" alt="image-20240531082318186"></p><ul><li>甚至还可以检测内存泄露:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240531082541109.png" alt="image-20240531082541109"></p><ul><li>空指针解引用也有问题。</li><li><strong>迭代器是现存现用的东西。</strong></li></ul><h1 id="【C-】局部变量初始化，推荐用哪种写法？最不容易错？"><a href="#【C-】局部变量初始化，推荐用哪种写法？最不容易错？" class="headerlink" title="【C++】局部变量初始化，推荐用哪种写法？最不容易错？"></a>【C++】局部变量初始化，推荐用哪种写法？最不容易错？</h1><ul><li>小彭老师推荐后置类型初始化，即利用auto声明，然后用变量类型赋值:<code>auto i = int(3);</code> 因为auto必须初始化，利用此特性使得不会忘记初始化。</li><li>利用三元运算符的类型提升的性质:<code>auto i = (0?a.size():0);</code></li><li>cpp20指定初始化:<code>struct X{int x;int y;};    X x = {.y = 10};</code></li></ul><h1 id="宏函数示例"><a href="#宏函数示例" class="headerlink" title="宏函数示例"></a>宏函数示例</h1><ul><li>==这一节学完后感觉宏函数还是很重要的，第一可以多平台策略，第二是反射的支持==.</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define PI(x) 3.14+x</span><br><span class="line"></span><br><span class="line">float pi = PI(1); // 相当于 float pi = 3.14 + 1</span><br><span class="line"></span><br><span class="line">#define PI2(x) #x</span><br><span class="line">const char * pi2 = PI2(3.14); // 相当于const char *pi2 = "3.14"; // 可以通过 gcc -E看出来</span><br></pre></td></tr></tbody></table></figure><p>#号相当于包了层字符串。</p><h2 id="宏函数替代switch"><a href="#宏函数替代switch" class="headerlink" title="宏函数替代switch"></a>宏函数替代switch</h2><p>有时候我们会写出来下面这样的Switch代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch(err) {</span><br><span class="line"> case NO_ERROR:return "NO_ERROR";</span><br><span class="line"> case VAL_ERROR:return "VAL_ERROR";</span><br><span class="line"> case INVALID_VALUE:return "INVALID_VALUE";</span><br><span class="line"> case INVALID_ENUM:return "INVALID_ENUM";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>上面的case我们可以看出，其实case的内容和return的内容是一样的，那么我们就可以用宏函数来减少这个重复</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch(err) {</span><br><span class="line">#define PER_ERROR(x) case x: return #x;</span><br><span class="line"> PER_ERROR(NO_ERROR)</span><br><span class="line"> PER_ERROR(VAL_ERROR)</span><br><span class="line"> PER_ERROR(INVALID_VALUE)</span><br><span class="line"> PER_ERROR(INVALID_ENUM)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假如说我们的这个case是有前缀的，但是返回值却是没有前缀的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switch(err) {</span><br><span class="line"> case AL_NO_ERROR:return "NO_ERROR";</span><br><span class="line"> case AL_VAL_ERROR:return "VAL_ERROR";</span><br><span class="line"> case AL_INVALID_VALUE:return "INVALID_VALUE";</span><br><span class="line"> case AL_INVALID_ENUM:return "INVALID_ENUM";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么我们那可以通过##来进行连接：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch(err) {</span><br><span class="line">#define PER_ERROR(x) case AL_##x: return #x;</span><br><span class="line"> PER_ERROR(NO_ERROR)</span><br><span class="line"> PER_ERROR(VAL_ERROR)</span><br><span class="line"> PER_ERROR(INVALID_VALUE)</span><br><span class="line"> PER_ERROR(INVALID_ENUM)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果宏有二次指向的话，我们就需要再定义一个宏函数来延迟求值</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch(err) {</span><br><span class="line">#define haha NO_ERROR</span><br><span class="line">#define CONCAT(x,y) x##y</span><br><span class="line">#define PER_ERROR(x) case CONCAT(AL_,x): return #x;</span><br><span class="line"> PER_ERROR(haha)</span><br><span class="line"> PER_ERROR(VAL_ERROR)</span><br><span class="line"> PER_ERROR(INVALID_VALUE)</span><br><span class="line"> PER_ERROR(INVALID_ENUM)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>比如说上面的这个例子，如果还用之前的代码直接AL##x进行拼接的话，那会得到一个AL_haha,而通过CONCAT可以避免这个问题。</p><h2 id="宏函数打印错误信息"><a href="#宏函数打印错误信息" class="headerlink" title="宏函数打印错误信息"></a>宏函数打印错误信息</h2><p>考虑下面的代码,假如说为了打印出错位置以及函数名，我们的printErrorMsg需要传入这三个参数，有些麻烦:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printErrorMsg(const char* filename,int line, const char* funcname){</span><br><span class="line">    cout &lt;&lt; filename &lt;&lt; ": " &lt;&lt; line &lt;&lt;": " &lt;&lt; funcname &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void printMsg(){</span><br><span class="line">    cout &lt;&lt;"hello!" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    printMsg();</span><br><span class="line">    printErrorMsg(__FILE__,__LINE__,"printMsg()");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这个时候我们就可以通过宏函数进行一个改版：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void printErrorMsg(const char* filename,int line, const char* funcname){</span><br><span class="line">    cout &lt;&lt; filename &lt;&lt; ": " &lt;&lt; line &lt;&lt;": " &lt;&lt; funcname &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void printMsg(){</span><br><span class="line">    cout &lt;&lt;"hello!" &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">#define CHECK_ERROR(x) x;printErrorMsg(__FILE__,__LINE__,#x);</span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    //printMsg();</span><br><span class="line">    //printErrorMsg(__FILE__,__LINE__,"printMsg()");</span><br><span class="line">    CHECK_ERROR(printMsg());</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>但是上面的方法很脆弱：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240531084553400.png" alt="image-20240531084553400"></p><p>可以看到这种情况就有问题的。为了解决上面的问题，可以用do while包一下宏函数,<strong>注意while(0)后不加分号就行。</strong>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CHECK_ERROR(x) do { (x);printErrorMsg(__FILE__,__LINE__,#x);}while(0)</span><br></pre></td></tr></tbody></table></figure><p>注意(x) 保证了x不会被跳过，如果写错为了CHECK_ERROR(func(123);break;);类似的话，不加括号有问题，为了美观可以用 \ 来分行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CHECK_ERROR(x) do { \</span><br><span class="line">(x);   \</span><br><span class="line">printErrorMsg(__FILE__,__LINE__,#x); \</span><br><span class="line">}while(0)</span><br></pre></td></tr></tbody></table></figure><p><strong>当我们传入的参数希望给他当值用的话，那么我们应该加()包围一下，来防止运算符优先级的问题:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ASSERT_GT(x,y) do { \</span><br><span class="line">if (!((x) &gt; (y))) { \</span><br><span class="line">std::cerr &lt;&lt; "Assert failed: " &lt;&lt; #x&lt;&lt; \</span><br><span class="line">        &lt;&lt; " (" &lt;&lt; (x) &lt;&lt; ")" &lt;&lt; " &gt; " &lt;&lt; #y &lt;&lt; "\n"; \</span><br><span class="line">        // 注意这里的x也要被()括号包一下。</span><br><span class="line">std::terminate(); \</span><br><span class="line">}</span><br><span class="line">} while(0)</span><br></pre></td></tr></tbody></table></figure><p>但是上面的代码仍有bug，可以用ASSERT_GT(i++,2)； 来测试一下，为了修复可以写为下面的形式，<strong>我们就可以防止重复求值了</strong>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define ASSERT_GT(x,y) do { \</span><br><span class="line">auto __x = (x); \</span><br><span class="line">auto __y = (y); \</span><br><span class="line">// typeof(x) = __x = (x); c写法，gnu拓展</span><br><span class="line"></span><br><span class="line">if (!((__x) &gt; (y))) { \</span><br><span class="line">std::cerr &lt;&lt; "Assert failed: " &lt;&lt; #x&lt;&lt; \</span><br><span class="line">        &lt;&lt; " (" &lt;&lt; (__x) &lt;&lt; ")" &lt;&lt; " &gt; " &lt;&lt; #y &lt;&lt; "\n"; \</span><br><span class="line">        // 注意这里的x也要被()括号包一下。</span><br><span class="line">std::terminate(); \</span><br><span class="line">}</span><br><span class="line">} while(0)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>OK,下面的MIN函数就是集合了上面的总结:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define MIN(x,y) ([&amp;] {\</span><br><span class="line">auto __x = (x); \</span><br><span class="line">auto __y = (y); \</span><br><span class="line">return __x &lt; __y ? __x: __y; \</span><br><span class="line">}())</span><br><span class="line">// 上面的是用的labmda做返回值</span><br><span class="line">#define MIN(x,y) ( {\</span><br><span class="line">auto __x = (x); \</span><br><span class="line">auto __y = (y); \</span><br><span class="line"> __x &lt; __y ? __x: __y; \</span><br><span class="line">})</span><br><span class="line">//上面的是用了gcc的特性，用括号包括后最后一行就作为了返回值。</span><br></pre></td></tr></tbody></table></figure><p>多个编译器下不同的宏指令的设置,下面的likely和unlikely是对cpp20的一种实现:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240531092033804.png" alt="image-20240531092033804"></p><p>在一些明确的场景下，程序员比CPU和编译器更了解哪个分支条件更有可能被满足。我们是否可将这一先验知识告知编译器和CPU, 提高分支预测的准确率，从而减少CPU流水线分支预测错误带来的性能损失呢？答案是可以！就是通过likely和unlikely。</p><p><strong>上面代码的!!是把任意类型给变为bool类型。</strong></p><p>变长参数：<strong>注意下面的__VA_OPT__是cpp20的新增的特性</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PRINT(x,...) do {\</span><br><span class="line">printf(x __VA_OPT__(,) __VA_ARGS__); \</span><br><span class="line">} while(0)</span><br></pre></td></tr></tbody></table></figure><p><code>__VA_OPT__(,)</code>表示当<code>__VA_ARGS__</code>不为空的时候，才会显示。</p><p>c语言会自动吧字符串连接起来:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto p = "hello" "world"; // p = "helloworld";</span><br></pre></td></tr></tbody></table></figure><p>宏编程小技巧，因为#x只能对宏进行加字符串，如果我们想把<code>__LINE__</code>这个整数转换为字符串，可以这样:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define STR2(x) #x</span><br><span class="line">#define STR(X) STR2(x)</span><br><span class="line">#define PRINT(x,...) do {\</span><br><span class="line">printf(__FILE_NAME__ ":" STR(__LINE__) ": "x __VA_OPT__(,) __VA_ARGS__); \</span><br><span class="line">} while(0)</span><br></pre></td></tr></tbody></table></figure><h2 id="宏函数Debug"><a href="#宏函数Debug" class="headerlink" title="宏函数Debug"></a>宏函数Debug</h2><p>gcc -E试一试，可以看到真正生成的代码。</p><h1 id="【C-】type-traits与SFINAE用法教学，检测是否有某成员函数"><a href="#【C-】type-traits与SFINAE用法教学，检测是否有某成员函数" class="headerlink" title="【C++】type_traits与SFINAE用法教学，检测是否有某成员函数"></a>【C++】type_traits与SFINAE用法教学，检测是否有某成员函数</h1><p>if constexpr: </p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T t)</span></span>{</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T,<span class="type">int</span>&gt;)</span></span>{</span><br><span class="line">      <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">return</span> t.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>去除cv限定符：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T <span class="type">const</span> &amp; t)</span></span>{</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(T)&gt;,<span class="type">int</span>&gt;)</span></span>{</span><br><span class="line">      <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">return</span> t.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>decltype必须和decay_t配合使用。</strong></p><p>未决名：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T <span class="type">const</span> &amp; t)</span></span>{</span><br><span class="line"><span class="keyword">using</span> X = <span class="keyword">typename</span> std::decay&lt;<span class="keyword">decltype</span>(t[<span class="number">0</span>])&gt;::type;</span><br><span class="line"><span class="keyword">typename</span> std::decay&lt;<span class="keyword">decltype</span>(t[<span class="number">0</span>])&gt;::type i; <span class="comment">//typename 告诉前面是类型</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(T)&gt;,<span class="type">int</span>&gt;)</span></span>{</span><br><span class="line">      <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">return</span> t.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>invoke函数，我们希望他可以对传入的是带参函数还是不带参函数进行一下区分:</p><p>std::declval<f>()可以进行凭空创建，假如说F没有构造函数也是可以的，因为他是不求值语境。</f></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">invoke</span><span class="params">(F f)</span></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"entered\n"</span>);</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_void_v&lt;<span class="keyword">decltype</span>(std::declval&lt;F&gt;()()))</span>&gt;)</span>{</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"levaed!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>或者我们用cpp20 的requires：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class F&gt;</span><br><span class="line">requires (std::is_void_v&lt;std::invoke_result_t&lt;F&gt;&gt;)</span><br><span class="line">auto invoke(F f){</span><br><span class="line"></span><br><span class="line">printf("entered\n");</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">template &lt;class F&gt;</span><br><span class="line">requires (!std::is_void_v&lt;std::invoke_result_t&lt;F&gt;&gt;)</span><br><span class="line">auto invoke(F f){</span><br><span class="line"></span><br><span class="line">auto ret = f();</span><br><span class="line">printf("levaed!\n");</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">}</span><br><span class="line">std::is_void_v&lt;std::invoke_result_t&lt;F&gt;&gt;和std::is_void_v&lt;decltype(f()))&gt;</span><br><span class="line">效果一致。</span><br></pre></td></tr></tbody></table></figure><p>但是c++之前使用enable_if实现的。。：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REQUIRES(x) std::enable_if_t<span class="string">&lt;(x),int&gt;</span> = 0;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="built_in">REQUIRES</span> (std::is_void_v&lt;std::<span class="type">invoke_result_t</span>&lt;F&gt;&gt;)</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">invoke</span><span class="params">(F f)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"entered\n"</span>);</span><br><span class="line"><span class="built_in">f</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>&gt;</span><br><span class="line"><span class="built_in">REQUIRES</span> (!std::is_void_v&lt;std::<span class="type">invoke_result_t</span>&lt;F&gt;&gt;)</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">invoke</span><span class="params">(F f)</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">f</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"levaed!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>判断是否有某个成员函数:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">struct mystu{</span><br><span class="line">void dismantle() {</span><br><span class="line">printf("rm -rf stu.db\n");</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line">struct mycls {</span><br><span class="line">void rebel(int i) {</span><br><span class="line">printf("rm -rf gench\n");</span><br><span class="line">}</span><br><span class="line">void rebel2() {</span><br><span class="line">printf("rm -rf gench\n");</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//cpp20</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void gench(T t){</span><br><span class="line">if constexpr (requires {t.dismantle();}){</span><br><span class="line">t.dismantle();</span><br><span class="line">}else if constexpr (requires (int i){ t.rebel(i)}) {</span><br><span class="line">t.rebel();</span><br><span class="line">}else{</span><br><span class="line">std::puts("no any method...");</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">//cpp14</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct has_dismantle {</span><br><span class="line">static constexpr bool value = false;</span><br><span class="line">};</span><br><span class="line">template &lt;&gt;</span><br><span class="line">struct has_dismantle&lt;myclass&gt; {</span><br><span class="line">static constexpr bool value = true;</span><br><span class="line">};</span><br><span class="line">template &lt;class T,class Dummy= void&gt;</span><br><span class="line">struct has_rebel2 {</span><br><span class="line">static constexpr bool value = false;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template &lt;&gt;</span><br><span class="line">struct has_rebel2&lt;T,std::void_t&lt;decltype(std::declval&lt;T&gt;().rebel2())&gt; {</span><br><span class="line">static constexpr bool value = true;</span><br><span class="line">};</span><br><span class="line">template &lt;class T,class Dummy= void&gt;</span><br><span class="line">struct has_rebel {</span><br><span class="line">static constexpr bool value = false;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">template &lt;&gt;</span><br><span class="line">struct has_rebel&lt;T,std::void_t&lt;decltype(std::declval&lt;T&gt;().rebel(declval(int)))&gt; {</span><br><span class="line">static constexpr bool value = true;</span><br><span class="line">};</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void gench(T t){</span><br><span class="line">if constexpr (typename has_dismantle&lt;T&gt;::value){</span><br><span class="line">t.dismantle();</span><br><span class="line">}else if constexpr (typename has_rebel2&lt;T&gt;::value) {</span><br><span class="line">t.rebel();</span><br><span class="line">}else{</span><br><span class="line">std::puts("no any method...");</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果没有if constexpr(编译器不支持cpp17)可以这个样子:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="built_in">REQUIRES</span>(has_dismantle&lt;T&gt;::value)&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gench</span><span class="params">(T t)</span></span>{</span><br><span class="line">t.<span class="built_in">dismantle</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="built_in">REQUIRES</span>(has_rebel&lt;T&gt;::value)&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gench</span><span class="params">(T t)</span></span>{</span><br><span class="line">t.<span class="built_in">dismantle</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="built_in">REQUIRES</span>(!has_rebel&lt;T&gt;::value &amp;&amp; !has_dismantle&lt;T&gt;::value)&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gench</span><span class="params">(T t)</span></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no any method supproted!\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="【C-】变长模板参数与折叠表达式教学，index-sequence与逗号运算符的巧妙结合，实现tuple系列实用traits与编译期for循环"><a href="#【C-】变长模板参数与折叠表达式教学，index-sequence与逗号运算符的巧妙结合，实现tuple系列实用traits与编译期for循环" class="headerlink" title="【C++】变长模板参数与折叠表达式教学，index_sequence与逗号运算符的巧妙结合，实现tuple系列实用traits与编译期for循环"></a>【C++】变长模板参数与折叠表达式教学，index_sequence与逗号运算符的巧妙结合，实现tuple系列实用traits与编译期for循环</h1><p>边长参数模板:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">temlate &lt;<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(Ts... ts)</span></span>{</span><br><span class="line"><span class="comment">//sizeof...(Ts);</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> + ... + ts);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><p>在c++17之前是利用递归实现的:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline auto func(){</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">template &lt;class T0,class ...Ts&gt;</span><br><span class="line">auto func(T0 t0,Ts ...ts){</span><br><span class="line">printnl(t0);</span><br><span class="line">if constexpr (sizeof...(ts) != 0){</span><br><span class="line">printnl(", ");</span><br><span class="line">}</span><br><span class="line">func(ts...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>边长参数模板声明数组:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(Ts ...ts)</span></span>{</span><br><span class="line"><span class="keyword">using</span> T = std::<span class="type">common_type_t</span>&lt;Ts...&gt;;</span><br><span class="line"><span class="keyword">return</span> std::array&lt;T,<span class="keyword">sizeof</span>...(Ts)&gt;{ts...};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>common_type的实现，不能用+号，应该用三目运算符来进行提升：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">common_type</span> {</span><br><span class="line"><span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="number">0</span> ? <span class="built_in">T1</span>() : <span class="built_in">T2</span>());</span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span>{</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span> : Animal{</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="keyword">using</span> what = <span class="keyword">typename</span> common_type&lt;Cat,Animal&gt;::type;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>多个参数的comon_type:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">common_type_two</span> {</span><br><span class="line"><span class="keyword">using</span> type = <span class="keyword">decltype</span>(<span class="number">0</span> ? <span class="keyword">decltype</span>&lt;T1&gt;() : <span class="keyword">decltype</span>&lt;T2&gt;());</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">common_type</span>&lt;T0&gt; {</span><br><span class="line"><span class="keyword">using</span> type = T0;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T0</span>,<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">common_type</span>&lt;T0,T1,Ts...&gt; {</span><br><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> common_type_two&lt;T0,<span class="keyword">typename</span> common_type&lt;T1,Ts...&gt;::type&gt;::type; </span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>也可以用函数来实现:</p><p>下面代码的==dummy<t0> t0,dummy<ts>… Ts==处用到了cpp20的特性，<strong>Cat不可以移动，管dummy什么事？</strong>通过这种方式，使得即使Cat被删除了移动构造函数，仍然可以成功的使用这个函数。</ts></t0></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dummy</span>{</span><br><span class="line"><span class="comment">//cpp20 consteval</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">consteval</span> T <span class="title">declval</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">declval</span>&lt;T&gt;();</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">templatet &lt;<span class="keyword">class</span> <span class="title class_">T0</span>,<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get_common_type</span><span class="params">(dummy&lt;T0&gt; t0,dummy&lt;Ts&gt;... Ts)</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(<span class="keyword">sizeof</span>...(Ts) == <span class="number">0</span>)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> t0;</span><br><span class="line">} <span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>? t0 : <span class="built_in">get_common_type</span>(ts...);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> {};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cat</span>: Animal{</span><br><span class="line"><span class="built_in">Cat</span>(&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> what = <span class="keyword">decltype</span>(<span class="built_in">get_common_type</span>(dummy&lt;Cat&gt;{},dummy&lt;Animal&gt;{}));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>变长模板参数但是却保证了类型一致</strong>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ts</span>&gt;</span><br><span class="line"><span class="comment">//第一个true是为了使得func()没有参数时仍可以调用。</span></span><br><span class="line"><span class="comment">//如果希望条件宽松一点把is_same_v改为is_convertable_v;</span></span><br><span class="line"><span class="built_in">requires</span> ((<span class="literal">true</span> &amp;&amp; ... &amp;&amp; std::is_same_v&lt;Ts,<span class="type">int</span>&gt;))</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(Ts ...ts)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>is_same_any的实现:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_same_any</span>{</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">value</span><span class="params">(<span class="literal">false</span> || ... || std::is_same_v(T,Ts))</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_convertiable_any</span>{</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">value</span><span class="params">(<span class="literal">false</span> || ... || std::is_convertiable_v(T,Ts))</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>tuple_size的实现:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T0</span>,<span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;std::tuple&lt;T0,Ts...&gt;&gt;{</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> value = tuple_size&lt;std::tuple&lt;Ts...&gt;&gt;::value +<span class="number">1</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>模板模板参数简化代码：考虑下面场景，我们想知道tuple和variant的common_type:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">class</span> <span class="title class_">Tmpl</span>,<span class="keyword">class</span> <span class="title class_">Tup</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_apply</span>{</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">class</span> <span class="title class_">Tmpl</span>,<span class="keyword">class</span> <span class="title class_">Ts</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_apply</span>&lt;Tmpl,std::tuple&lt;Ts...&gt;&gt;:Tmpl&lt;Ts...&gt; {</span><br><span class="line"><span class="keyword">using</span> type = Tmpl&lt;Ts...&gt;;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span>&lt;<span class="keyword">class</span>... Ts&gt; <span class="keyword">class</span> <span class="title class_">Tmpl</span>,<span class="keyword">class</span> <span class="title class_">Ts</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_apply</span>&lt;Tmpl,std::variant&lt;Ts...&gt;&gt;:Tmpl&lt;Ts...&gt; {</span><br><span class="line"><span class="keyword">using</span> type = Tmpl&lt;Ts...&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> what = tuple_apply&lt;common_type,Var&gt;::type;</span><br><span class="line"><span class="keyword">using</span> what3 = tuple_apply&lt;std::tuple,Var&gt;::type; <span class="comment">// 注意，我们甚至用tuple传入都行的。</span></span><br><span class="line"><span class="keyword">using</span> what2 = common_type&lt;<span class="type">int</span>,<span class="type">float</span>,<span class="type">double</span>&gt;::type;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>利用common_type_wrapper再进行化简参数:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">common_type_wrapper</span> {</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rebind</span> {</span><br><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> common_type&lt;Ts...&gt;type;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">variant_wrapper</span> {</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rebind</span>{</span><br><span class="line"><span class="keyword">using</span> type = std::variant&lt;Ts...&gt;;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Tmpl</span>,<span class="keyword">class</span> <span class="title class_">Tup</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_apply</span>{</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Tmpl</span>,<span class="keyword">class</span> <span class="title class_">Ts</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_apply</span>&lt;Tmpl,std::tuple&lt;Ts...&gt;&gt;:Tmpl&lt;Ts...&gt; {</span><br><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> Tmpl::<span class="keyword">template</span> rebind&lt;Ts...&gt;::type;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">Tmpl</span>,<span class="keyword">class</span> <span class="title class_">Ts</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_apply</span>&lt;Tmpl,std::variant&lt;Ts...&gt;&gt;:Tmpl&lt;Ts...&gt; {</span><br><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> Tmpl::<span class="keyword">template</span> rebind&lt;Ts...&gt;::type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> what = tuple_apply&lt;common_type_wrapper,Var&gt;::type;</span><br><span class="line"><span class="keyword">using</span> what3 = tuple_apply&lt;variant_wrapper,Var&gt;::type; <span class="comment">// 注意，我们甚至用tuple传入都行的。</span></span><br><span class="line"><span class="keyword">using</span> what2 = common_type&lt;<span class="type">int</span>,<span class="type">float</span>,<span class="type">double</span>&gt;::type;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>实现一个tuple_map,可以传入一个vector_wrapper，进行映射。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Tmpl,class Tup&gt;</span><br><span class="line">struct tuple_map {</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">template &lt;class Tmpl,class ...Ts&gt;</span><br><span class="line">struct tuple_map&lt;Tmpl,std::tuple&lt;Ts...&gt;&gt;{</span><br><span class="line">using type = std::tuple&lt;typename Tmpl::template rebind&lt;Ts&gt;::type...&gt;;</span><br><span class="line">};</span><br><span class="line">struct vector_wrapper {</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct rebind{</span><br><span class="line">using type = std:;vector&lt;T&gt;;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using Tup = std::tuple&lt;int,float,double);</span><br><span class="line">using what5 = tuple_map&lt;vector_wrapper,Tup&gt;::type;</span><br><span class="line"></span><br><span class="line">//what5 = std::tuple&lt;std:;vector&lt;int&gt;,std:;vector&lt;float&gt;,std:;vector&lt;double&gt;&gt;;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>还可以花一点，搞个array_wrappepr，==这个其实叫做柯里化==:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Tmpl,class Tup&gt;</span><br><span class="line">struct tuple_map {</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">template &lt;class Tmpl,class ...Ts&gt;</span><br><span class="line">struct tuple_map&lt;Tmpl,std::tuple&lt;Ts...&gt;&gt;{</span><br><span class="line">using type = std::tuple&lt;typename Tmpl::template rebind&lt;Ts&gt;::type...&gt;;</span><br><span class="line">};</span><br><span class="line">template &lt;size_t N&gt;</span><br><span class="line">struct array_wrapper {</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">struct rebind{</span><br><span class="line">using type = std:;array&lt;T,N&gt;;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using Tup = std::tuple&lt;int,float,double);</span><br><span class="line">using what5 = tuple_map&lt;array_wrapper&lt;3&gt;,Tup&gt;::type;</span><br><span class="line"></span><br><span class="line">//what5 = std::tuple&lt;std:;array&lt;int,3&gt;,std:;array&lt;float,3&gt;,std:;array&lt;double,3&gt;&gt;;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>实现一个tuple_cat和tuple_push_front:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...T1s,class ...T2s&gt;</span><br><span class="line">struct tuple_cat{</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">template &lt;class ...T1s,class ...T2s&gt;</span><br><span class="line">struct tuple_cat&lt;std::tuple&lt;T1s...&gt;,std::tuple&lt;T2s...&gt;&gt;{</span><br><span class="line">using type = std::tuple&lt;T1s...,T2s...);</span><br><span class="line">};</span><br><span class="line">template &lt;class T1,class ...T2s&gt;</span><br><span class="line">struct tuple_push_front{</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">template &lt;class T1,class ...T2s&gt;</span><br><span class="line">struct tuple_push_front&lt;T1,std::tuple&lt;T2s...&gt;&gt;{</span><br><span class="line">using type = std::tuple&lt;T1,T2s...);</span><br><span class="line">};</span><br><span class="line">using Tup = std::tuple&lt;int,float,double);</span><br><span class="line">using Tup2 = std::tuple&lt;int,float,double);</span><br><span class="line"></span><br><span class="line">//what6 = std::tuple&lt;int,flaot,double,int,float,double&gt;</span><br><span class="line">using what6 = tuple_cat&lt;Tup,Tup2&gt;::type;</span><br><span class="line">using what7 = tuple_push_front&lt;char*,Tup&gt;::type;</span><br><span class="line">//what7 = std::tuple&lt;char*,int,float,double&gt;</span><br></pre></td></tr></tbody></table></figure><p>tuple获取第一个类型和获取第I个元素的类型：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Ts</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_get_first</span> {</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T0</span>, <span class="keyword">class</span>... Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_get_first</span>&lt;std::tuple&lt;T0,Ts...&gt; {</span><br><span class="line"><span class="keyword">using</span> type = T0;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I,<span class="keyword">class</span> <span class="title class_">Tup</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_element</span> {</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="comment">//递归结束</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T0</span>,<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>,std::tuple&lt;T0,Ts...&gt;&gt; {</span><br><span class="line"><span class="keyword">using</span> type = T0;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N,<span class="keyword">class</span> <span class="title class_">T0</span>,<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;N,std::tuple&lt;T0,Ts...&gt;&gt; {</span><br><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> tuple_element&lt;N<span class="number">-1</span>,std::tuple&lt;Ts...&gt;::type;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Tup = std::tuple&lt;<span class="type">int</span>,<span class="type">float</span>,<span class="type">double</span>);</span><br><span class="line"><span class="keyword">using</span> what = tuple_get_first&lt;Tup&gt;::type; <span class="comment">// what = int.</span></span><br><span class="line"><span class="keyword">using</span> what2 = tuple_element&lt;<span class="number">3</span>,Tup&gt;::type; <span class="comment">// what = double.</span></span><br></pre></td></tr></tbody></table></figure><p>判断是否tuple的类型都是整数:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Tup</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_is_all_integral</span> {</span><br><span class="line">    </span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_is_all_integral</span>&lt;std::tuple&lt;&gt;&gt; {</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T0</span>,<span class="keyword">class</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_is_all_integral</span>&lt;std::tuple&lt;T0,Ts...&gt;&gt;{</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = std::is_integral_v&lt;T0&gt; &amp;&amp; tuple_is_all_integral&lt;std::tuple&lt;Ts...&gt;&gt;::value;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Tup = std::tuple&lt;<span class="type">int</span>,<span class="type">float</span>,<span class="type">double</span>);</span><br><span class="line"><span class="keyword">using</span> what = tuple_is_all_integral&lt;Tup&gt;::type; <span class="comment">// what = false</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编译器for循环:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">template &lt;size_t Beg,size_t End,class Lambda&gt;</span><br><span class="line">void static_for(Lambda lambda){</span><br><span class="line">if constexpr (Beg &lt; End){</span><br><span class="line">int_constant&lt;Beg&gt; i;</span><br><span class="line">lambda(i);</span><br><span class="line">static_for&lt;Beg + 1,End&gt;(lambda);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">// 非递归版的实现</span><br><span class="line">template &lt;size_t ...Is,class Lambda&gt;</span><br><span class="line">void _static_for_impl(Lambda lambda,std::index_sequence&lt;Is...&gt;){</span><br><span class="line">(lambda(Is),...);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template &lt;size_t N,class Lambda&gt;</span><br><span class="line">void static_for(Lambda lambda){</span><br><span class="line">_static_for_impl(lambda,std::make_index_sequence&lt;N&gt;());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// int_constant的作用和上面的dummy作用很像。</span><br><span class="line">template &lt;int X&gt;</span><br><span class="line">struct int_constant {</span><br><span class="line">static constexpr int value = X;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(){</span><br><span class="line">std::tuple&lt;int,float,double,char&gt; tup{};</span><br><span class="line">//cpp20才支持lambda带尖括号</span><br><span class="line">static_for&lt;1,5&gt; ([&amp;] (auto i) {</span><br><span class="line">print(std::get&lt;i.value&gt;(tup));</span><br><span class="line">});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="【C-x2F-C-】什么情况下需要封装get-x2F-set"><a href="#【C-x2F-C-】什么情况下需要封装get-x2F-set" class="headerlink" title="【C/C++】什么情况下需要封装get/set"></a>【C/C++】什么情况下需要封装get/set</h1><p>面向对象封装的意义在于维护“不变量”。get/set就是保证在设置一个成员的同时，另一个与之有依赖的成员也能更新，相当于对set操作做了个hook。如果你的结构体完全是平凡类型，每个成员都能随意单独取值，设值，互不干扰。那就没必要设置getter/setter了，直接public暴露出来即可。 还顺便介绍了构造函数参数非常多时的解决方案：builder模式，以及C++20的指定初始化语法。 也介绍了接口臃肿的解决方案：接口多继承。多继承含有成员的普通类是错误的，糟糕的设计。但是接口完全可以多重继承，即使是禁止类多继承的Java也支持接口的多继承。同一个类当然可以支持多种接口，比如iostream就同时支持istream和ostream接口。 最后，也介绍了当一个参数需要可选的多个接口时的解决方案：定义共同的基类然后dynamic_cast，还提出了dynamic_cast的替代方案：toDerived()，在《以撒的结合》中就用了这种方案，例如Entity是实体类，可以通过Entity:toPlayer()获取玩家子类，如果不是玩家类则返回null。最后，还实现了经典的访问者模式，解决dynamic_cast和toDerived()流派不符合开闭原则的问题，这下对味了。</p><ul><li><strong>对一个类的好的设计，是说你对它的任何操作，都不会让他进入非法状态，他有中间状态和合法状态两种，</strong></li></ul><h1 id="【C-】类型擦除-工厂模式，告别-if-else"><a href="#【C-】类型擦除-工厂模式，告别-if-else" class="headerlink" title="【C++】类型擦除 + 工厂模式，告别 if-else"></a>【C++】类型擦除 + 工厂模式，告别 if-else</h1><p>variant有缺点，那就是他的大小是variant的本身的4个字节加上其中最大的类型的大小。</p><p>宏定义后尽量赶紧丢掉，防止在头文件中和其他的重名等情况:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240717082843329.png" alt="image-20240717082843329"></p><h1 id="【全网最全】28种C-未定义行为，完全介绍（附检测方法教学）"><a href="#【全网最全】28种C-未定义行为，完全介绍（附检测方法教学）" class="headerlink" title="【全网最全】28种C++未定义行为，完全介绍（附检测方法教学）"></a>【全网最全】28种C++未定义行为，完全介绍（附检测方法教学）</h1><ul><li><p>空指针调用成员函数是未定义行为，虽然可以成功运行，本质原因是this指针不能为空:</p></li><li><p>有符号数的溢出是未定义行为，因为不保证回环，对于无符号数的溢出是有回环的，经典的例子:<code>for(int seed = 1;seed !=0;seed++)</code>因为是int，所以不回环，编译器甚至可能优化为<code>while(1);</code></p></li><li><p>有的未定义行为在某个编译器上才能复刻出来，另外一方面可能还要是release的模式才可以复刻。</p></li><li><p>调用移动后的对象在语言层面是是合法的，但是在标准库层面上是不合法的。</p></li><li><p>不要依赖未定义行为，通常会产生崩溃，但是也可能被优化产生奇怪的现象。</p></li></ul><h1 id="【C-11】自己封装RAII类，有哪些坑点？带你了解移动语义的真相"><a href="#【C-11】自己封装RAII类，有哪些坑点？带你了解移动语义的真相" class="headerlink" title="【C++11】自己封装RAII类，有哪些坑点？带你了解移动语义的真相"></a>【C++11】自己封装RAII类，有哪些坑点？带你了解移动语义的真相</h1><ul><li>右引用可以理解他的唯一作用就是来做移动构造函数。</li><li>移动构造函数没有什么特别的，他移动不移动主要是看自己在函数体内部怎么实现的。</li></ul><h1 id="【C-11】内存序究竟是什么，彻底参悟C-内存模型"><a href="#【C-11】内存序究竟是什么，彻底参悟C-内存模型" class="headerlink" title="【C++11】内存序究竟是什么，彻底参悟C++内存模型"></a>【C++11】内存序究竟是什么，彻底参悟C++内存模型</h1><ul><li>cpu、缓存、内存序的优化，都可能导致乱序。</li><li>对于x86来说，用seq_cst就行了，而对于弱内存序的ARM,RISC-V来说很有用，x86只会影响编译优化。</li><li>CPU所有的优化都是保证单线程上的结果不会错，所以可能不同行的指令会被打乱。而X86的话，他虽然也会乱序计算，但是输出的时候，有个out buffer,在这里他会重新进行排序。</li><li>seq_cst相当于插入了内存屏障。</li><li>release和acquire相当于是单向的屏障，一个保证了之前，一个保证了之后。</li><li><strong>除了CAS的写法，原子变量出现两遍是大忌的</strong>，下图中flag = 1和while之间可能是会其他线程打断的：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240722082322000.png" alt="image-20240722082322000"></p><h1 id="【C-标准库】自己动手实现vector容器"><a href="#【C-标准库】自己动手实现vector容器" class="headerlink" title="【C++标准库】自己动手实现vector容器"></a>【C++标准库】自己动手实现vector容器</h1><ul><li>编写一个类的时候，可以声明这个类为 const A a; 那么就会检查A实现的size()之类的函数是否被声明为const了。学到了。</li></ul><h1 id="【现代C-】如何写出易于维护的代码？类型就是最好的注释！"><a href="#【现代C-】如何写出易于维护的代码？类型就是最好的注释！" class="headerlink" title="【现代C++】如何写出易于维护的代码？类型就是最好的注释！"></a>【现代C++】如何写出易于维护的代码？类型就是最好的注释！</h1><ul><li>好的API的设计不会给人留下犯错的机会！</li><li>不要返回指针，太多歧义了。</li><li>空值语义最好返回std::optional。</li><li>什么是好的API设计？<strong>不需要看文档就能理解的API就是好的API设计</strong>。</li><li>optional包括引用: <code>std::optional&lt;std::reference_wrapper&lt;BookInfo&gt;&gt;</code>;</li><li>拥有n个的所有权:vector; 拥有1个的所有权:unique_ptr;</li><li>没有n个的所有权:span<t>;没有1个的所有权:reference_wrapper,T&amp;</t></li><li>共享n个所有权:shared_ptr&lt;T[]&gt;,共享1个所有权shared_ptr<t></t></li><li>c++的chrono的时间系统的API设计很值得参考。</li><li>封装强枚举来阻止埋下BUG隐患（极端做法）: enum class Age : int {};</li><li>对于string、double等类型不能封装为强枚举类型，我们可以用模板元编程来实现；CRTP模式:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240723085936766.png" alt="image-20240723085936766"></p><ul><li>对于需要资源管理的，如文件描述符句柄需要close，那么我们可以使用shared_ptr指定释放函数来进行管理。</li></ul><h1 id="【C-】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理【C-】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理"><a href="#【C-】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理【C-】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理" class="headerlink" title="【C++】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理【C++】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理"></a>【C++】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理【C++】速通面向对象设计模式（1）：策略、工厂、迭代器、适配器、享元、代理</h1></body></html>]]></content>
      
      
      <categories>
          
          <category> 网课学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cppcon视频观看笔记</title>
      <link href="/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="STL105"><a href="#STL105" class="headerlink" title="STL105"></a>STL105</h1><h2 id="为什么要了解STL105个算法？还要很好的了解？"><a href="#为什么要了解STL105个算法？还要很好的了解？" class="headerlink" title="为什么要了解STL105个算法？还要很好的了解？"></a>为什么要了解STL105个算法？还要很好的了解？</h2><ol><li>可以让代码表达的更好。</li><li>一般抽象级别更高。</li><li>有时非常壮观。</li><li>避免常见的错误，比如说off-by-one,empty loops,naive complexity.</li><li>被很多人使用，他们是c+++标准，并且一般和complier关系不大。</li></ol><h2 id="heaps"><a href="#heaps" class="headerlink" title="heaps"></a>heaps</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">make_heap(begin(v), end(v));</span><br><span class="line">display(v);</span><br><span class="line"></span><br><span class="line">v.push_back(10);</span><br><span class="line">push_heap(begin(v), end(v));</span><br><span class="line">display(v);</span><br><span class="line">pop_heap(begin(v), end(v)); // 此时并不会删除，而是给他放到了最后。</span><br><span class="line">display(v);</span><br><span class="line">// 注意，使用sort_heap()函数会使序列失去堆的属性。</span><br><span class="line">sort_heap(begin(v), end(v));</span><br><span class="line">display(v);</span><br></pre></td></tr></tbody></table></figure><h2 id="sorting"><a href="#sorting" class="headerlink" title="sorting"></a>sorting</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void display(vector&lt;int&gt; &amp;v)</span><br><span class="line">{</span><br><span class="line">    for (auto i = 0; i &lt; v.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; " ";</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    vector&lt;int&gt; v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">    display(v);</span><br><span class="line">    // 部分排序</span><br><span class="line">    partial_sort(v.begin(), v.begin() + 5, v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    // 对第n个进行排序，用于将序列中的第 n 个元素（按升序或降序排列）</span><br><span class="line">    // 放置在其在完全排序后应该处于的位置，而不必对整个序列进行排序。</span><br><span class="line">    nth_element(v.begin(), v.begin() + 3, v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    sort_heap(v.begin(), v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    printf("======================\n");</span><br><span class="line">    v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">    display(v);</span><br><span class="line">    //用于在给定范围内执行原地归并操作，即将两个已经</span><br><span class="line">    //有序的序列合并成一个有序序列，将结果存储在原始范围内。</span><br><span class="line">    inplace_merge(v.begin(), v.begin() + 3, v.end());</span><br><span class="line">    display(v);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="partitioning"><a href="#partitioning" class="headerlink" title="partitioning"></a>partitioning</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void display(vector&lt;int&gt; &amp;v)</span><br><span class="line">{</span><br><span class="line">    for (auto i = 0; i &lt; v.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; " ";</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    vector&lt;int&gt; v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">    display(v);</span><br><span class="line">    // 当你需要将一个序列划分成满足某个条件的元素和</span><br><span class="line">    // 不满足该条件的元素两部分时，std::partition 是一个很有用的算法。</span><br><span class="line">    //  将偶数放在前面，奇数放在后面</span><br><span class="line">    std::partition(v.begin(), v.end(), [](int n)</span><br><span class="line">                   { return n % 2 == 0; });</span><br><span class="line">    display(v);</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    // 循环的给rotate到后面</span><br><span class="line">    rotate(v.begin(), v.begin() + 3, v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    // 使用默认的随机数引擎来打乱向量中的元素</span><br><span class="line">    std::random_device rd;                             // 获取随机设备</span><br><span class="line">    std::mt19937 gen(rd());                            // 使用随机设备生成种子</span><br><span class="line">    std::shuffle(v.begin(), v.end(), gen); // 打乱向量中的元素</span><br><span class="line">    display(v);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240510091252496.png" alt="image-20240510091252496"></p><h1 id="Templates-in-C-Nicolai-Josuttis-cppcon2022"><a href="#Templates-in-C-Nicolai-Josuttis-cppcon2022" class="headerlink" title="Templates in C++ Nicolai Josuttis (cppcon2022)"></a>Templates in C++ Nicolai Josuttis (cppcon2022)</h1><p>在模板中，总是存在一些隐式的要求，例如说下面是一个非常典型的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 下面内容隐含了T支持比较，二是支持拷贝赋值。</span><br><span class="line">auto mymax(const auto &amp;a, const auto &amp;b)</span><br><span class="line">{</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是对于下面的这个例子来说，就更加的不容易看出来了,下面的print函数其实隐含了对 &lt;&lt;的要求，所以对于右边的Stack&lt;pair&lt;int,double&gt;&gt;来说，<strong>其实如果不调用print也是没有太大问题的</strong>：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512165230165.png" alt="image-20240512165230165"></p><p>构造函数模板参数自动推导(cpp17):</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v{0,8,15}; // cpp11</span><br><span class="line">std::vector v{0,8,15} // cpp 17</span><br></pre></td></tr></tbody></table></figure><p>对于上面的第二行代码，在实例化时会经历overload resolution的几个阶段来找到最终匹配的构造函数，这个过程编译器做的其实很快的。:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512170140531.png" alt="image-20240512170140531"></p><p>这个功能有的时候会出现问题，如下面的这个case:</p><p>对于v4,可能我们并不是想这样用的，得到了错误的推断，那么这个时候，鼓励最好使用v5.</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512170252545.png" alt="image-20240512170252545"></p><p>so,==<strong>Dont use CTAD unless deduction is obvious</strong>==</p><p>CTAD比如说下面的场景就很有用:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512170252545.png"></p><p>std::array&lt;&gt;is aTemplified Aggregate:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,size_t SZ&gt;</span><br><span class="line">struct array{</span><br><span class="line">T elems[SZ];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>NTTP Types:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512174526924.png" alt="image-20240512174526924"></p><p>下面是编译时if constexpr的一个妙用:<br><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512175344469.png" alt="image-20240512175344469"></p><h1 id="Back-To-Basics-Standard-Library-Containers-RAINER-GRIMM"><a href="#Back-To-Basics-Standard-Library-Containers-RAINER-GRIMM" class="headerlink" title="Back To Basics Standard Library Containers RAINER GRIMM"></a>Back To Basics Standard Library Containers RAINER GRIMM</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512175652691.png" alt="image-20240512175652691"></p><h2 id="Container的接口"><a href="#Container的接口" class="headerlink" title="Container的接口"></a>Container的接口</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180007321.png" alt="image-20240512180007321"></p><p>一般来说，我们应该把string看做是vector<char>。</char></p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180135151.png" alt="image-20240512180135151"></p><h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180154634.png" alt="image-20240512180154634"></p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>empty()</p><p>size()</p><p>max_size()</p><h3 id="Assignment-and-swap"><a href="#Assignment-and-swap" class="headerlink" title="Assignment and swap"></a>Assignment and swap</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180346509.png" alt="image-20240512180346509"></p><h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180418451.png" alt="image-20240512180418451"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>支持range-base for</li><li>list有特殊的成员函数对指针的操作</li><li>forward_list只用于极个别特殊的case</li></ul><h2 id="Sequence-Containers"><a href="#Sequence-Containers" class="headerlink" title="Sequence Containers"></a>Sequence Containers</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180618281.png" alt="image-20240512180618281"></p><h1 id="Object-Oriented-Programming-Amir-Kirsh"><a href="#Object-Oriented-Programming-Amir-Kirsh" class="headerlink" title="Object Oriented Programming Amir Kirsh"></a>Object Oriented Programming Amir Kirsh</h1><p>在面向对象编程中，<strong>我们要以数据为中心</strong>，所有的成员函数，所有的操作符，说白了也都是围绕着数据进行的。</p><ul><li>成员函数不占用类的大小。</li><li>类的大小包括所有的数据成员，可能会有虚函数指针，也可能包含padding的部分。</li><li>Ctor init list的使用场景1.高效、正确，但是在某些场景下你必须这样做：1.包含了没有提供默认构造函数和no initializaion on declaration的，2.含常数据成员和引用数据成员的，因为他们必须初始化，4.基类没有默认构造的。</li><li>A&amp; A::operator=(A a)可以吗？可以，这东西可以处理复制和移动，额，写笔记的时候我现在是不细究的，这玩意可以免去一些编码的麻烦，但是效率低，不推荐。</li><li>单参数推荐用explicit，并且如果构造函数他正在获取对象的完整状态，最好用显式构造。</li><li>临时对象在语句的末尾死亡。</li><li><strong>零原则：如果类不需要任何管理资源的方式是最好的。</strong>也就意味着不需要dtor,copy ctor,assignment operator,defaults do the job, defaults for move operations.为了实现它，使用恰当的管理数据的方法,如string,std的containers,unique_ptr,shared_ptr.</li><li>“<strong>三原则：如果你需要一个析构函数，那么首先就是把copy ctor和assigment operator给block掉</strong>“。一定要立即删除，就算是觉得以后可能会用，那么就先写todo。主要是这俩东西可能会导致两个对象指向同一个资源。</li><li><strong>五原则</strong>：如果实现了5个中的任何一个，<strong>那一定要保证移动语义相关的也要被实现。</strong></li><li><strong>在性能面前，要考虑我们需要的是数据的结构，还是结构的数据。</strong></li><li>状态模式可以用来避免一些丑陋的集成，很好使，当我们的类的继承关系变得丑陋的话，<strong>那可以考虑用状态模式进行重构，这是一个很重要的模式</strong>：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512202444348.png" alt="image-20240512202444348"></p><ul><li>stragegy模式也很好。</li><li></li></ul><p>下面是一个较好的总结：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512202731901.png" alt="image-20240512202731901"></p><p>OO的低层的设计原则：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512201942460.png" alt="image-20240512201942460"></p><p>继承的设计原则:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512202822916.png" alt="image-20240512202822916"></p><p>代替继承的一些手段:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512203203496.png" alt="image-20240512203203496"></p><h1 id="Master-C-Value-Categories-With-Standard-Tools-Inbal-Levi"><a href="#Master-C-Value-Categories-With-Standard-Tools-Inbal-Levi" class="headerlink" title="Master C++ Value Categories With Standard Tools - Inbal Levi"></a>Master C++ Value Categories With Standard Tools - Inbal Levi</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512204151842.png" alt="image-20240512204151842"></p><p>我用compiler测也是这样:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512204709444.png" alt="image-20240512204709444"></p><p>对于d4调用两次ctor，是因为由于 <code>getData(42)</code> 返回的是 <code>const Data</code> 类型的临时对象，它不能被直接移动，因为右值引用不能绑定到 <code>const</code> 对象。所以编译器会忽略 <code>std::move</code>，而调用复制构造函数来创建 <code>d4</code>，<strong>chatgpt牛逼。</strong></p><ul><li>我们可以使用move来显示的把对象变为“灰色”，但是有些条件也可以隐式的把对象变为灰色。（灰色意味着编译器知道它可以直接从对象里进行“偷”。</li><li><strong>值类别是一个表达式的性质</strong>，在不同的上下文中可能有不同的值类别。</li><li>左值的常引用可以延长生命周期。</li><li>右值引用也可以延长临时对象的生命周期。</li><li></li></ul><p>什么是值类别：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512205657063.png" alt="image-20240512205657063"></p><p>下面是一个有意思的例子</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512210307119.png" alt="image-20240512210307119"></p><p>下面是一个值类型的总结：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512210731715.png" alt="image-20240512210731715"></p><p>常见的初始化时的绑定规则:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512211334313.png" alt="image-20240512211334313"></p><p>function call的绑定规则：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512212021801.png" alt="image-20240512212021801"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512212044319.png" alt="image-20240512212044319"></p><h2 id="Tools-for-handling-value-categories"><a href="#Tools-for-handling-value-categories" class="headerlink" title="Tools for handling value categories"></a>Tools for handling value categories</h2><p>以下几种，据说Deducing this是一个很好的特性：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512212440507.png" alt="image-20240512212440507"></p><h1 id="Declarations-in-C-BenSaks"><a href="#Declarations-in-C-BenSaks" class="headerlink" title="Declarations in C++ BenSaks"></a>Declarations in C++ BenSaks</h1><p>一个计算机程序必备实体，和涉及这些实体的行为，在c++中，一个实体可以是函数，命名空间，物体，模板，类型，值。c++程序可以声明指定实体的名称,声明的名称可以具有关联的属性如，类型，范围，储存持续时间，链接：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514081528990.png" alt="image-20240514081528990"></p><ul><li>所有的定义都是声明，但不是所有的声明，都是定义。</li><li>非定义声明将名称引入程序，表明了：这个存在，但不是这。</li><li>每一个声明说明符都要么是一个类型说明符，要么是非类型说明符，非类型说明符是指extern,static,virtual，friend。</li><li><strong>const是一个类型说明符，很像long 或者说 unsigned,修饰同一个声明中的其他的类型说明符。*const和*有相同的操作符优先级。</strong></li><li>一个声明是由声明id(declarator-id)组成的，可能会被操作符包围，比如说*,&amp;,&amp;&amp;,[],().</li><li>在声明的操作符中，我们有以下的优先级,所以对于<code>*X[N]</code>来说，他是一个指针数组，因为[]的优先级更高。:</li><li><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514082428594.png" alt="image-20240514082428594"></li></ul><p><code>*f(int)</code>代表是一个接受int，返回*的一个函数，<code>(*f)int</code>代表是一个函数指针，接收int返回somthing，他们的区别是因为()改变的优先级。</p><ul><li><p>constexpr的表现更像一个non-type specifier,比如说<code>constexpr unsigned long int *x[N]</code>这里的constexpr其实修饰的是x。</p></li><li><p><strong>Two-phase transition：</strong>在编译模板的时候，第一阶段，由于不知道类型T到底是什么，编译器不能检测出所有的错误，但是它仍然尽可能的去对错误进行探测，第二阶段，当这个模板函数被调用的时候，如<code>foo(i)</code>,编译器会推导出T的实际类型，或者说这里被显式指定了，然后将推导的类型替换为T，并执行完整的语法和语义分析。<strong>第二阶段可能会执行多次，因为模板可能会被多个不同类型进行实例化。</strong></p></li><li><p>如果T::size_type是一个type，并且T::nppos是一个type，<code>T::size_type *i(T::npos)</code>比如说对于这个case，我们其实是想生命一个i，用T::npos进行初始化，但是呢，由于上面所提到的规则，最终他会被当做是一个接受T::npos类型，返回T::size_type * 类型的函数i.</p></li><li><p>如果T::size_type不是一个type，并且T::nppos不是一个type，那么编译器可能会把<code>T::size_type *i(T::npos)</code>当做一个乘法表达式。</p></li><li><p>如果T::size_type是一个type，T::npos是一个常数，object，或者function，那么<code>T::size_type *i(T::npos)</code>会被当做对象定义。</p></li><li><p>出现在模板中的名称,其含义必取决于一个或多个横板参数的叫做dependent name.对于这种情况，我们需要在前面再加上typenam关键字修饰。</p></li><li><p>下面这个case中，T&amp;&amp;是一个右值引用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void dispath(T&amp;&amp; arg){</span><br><span class="line">T&amp;&amp; temp = f(arg); // 这个temp是个右值引用，而arg是一个forwarding reference.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="Cpp-Value-Semantics-Klaus-lglberger"><a href="#Cpp-Value-Semantics-Klaus-lglberger" class="headerlink" title="Cpp Value Semantics - Klaus lglberger"></a>Cpp Value Semantics - Klaus lglberger</h1><p>下面这种编程风格有一些缺点,注意下面图里的classic应该是翻译为传统的。:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514091840291.png" alt="image-20240514091840291"></p><p>现在确实有更好的解决方式，通常用基于值语义的解决方案，比如说<strong>std::variant</strong>,<strong>我们应该积极的去拥抱，variant。</strong>比如说，上面我们就可以直接<code>using shape = std::variant&lt;Circle,Square&gt;;</code>这种方式的优点:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514092313762.png" alt="image-20240514092313762"></p><ul><li>Modern Visitor Style就是用值语义去做，这会让代码更容易去理解（代码量少），让代码更容易去写，让代码更正确。让代码更快，比<strong>引用语义</strong>更好。</li><li>引用语义是通过span来实现的，如果长时间使用是可能有风险的：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240515083440242.png" alt="image-20240515083440242"></p><ul><li>C+应该认真考虑值语义。比如说optional,any,function,expected,STL库的设计等。</li><li>用optional做返回值有下面这些好处，首先是没有所有权的问题，语义的问题，异常开销，很高效简单。</li><li>这个talk最主要的是，值语义比引用语义更好。</li></ul><h1 id="C-API-Design-Jason-Turner"><a href="#C-API-Design-Jason-Turner" class="headerlink" title="C++ API Design Jason Turner"></a>C++ API Design Jason Turner</h1><p>这个topic的重点是：Make your API Hard To Use Wrong.</p><p>下面是一个简单的例子:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>; <span class="comment">// easy to use wrong.</span></span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>; <span class="comment">// hard to use wrong.</span></span><br></pre></td></tr></tbody></table></figure><ul><li>[[nodiscard]]应该被广泛使用，任何非mutating（getter/accessor/const)的函数都应该被设置为nodiscard。他可以传递一个message[[nodiscard(“XXX should never be discard”]].从cpp20开始也可以被用于构造函数。</li><li>noexcept通知用户（和编译器）该函数可能不会抛出异常。如果从该函数抛出异常，必须调用terminate。</li><li>下面是一种很好的工厂函数的写法:<code>[[nodiscard]]std::unique_ptr&lt;Widget&gt; make_weight(WidgetType type)</code>,不容易出错。</li><li>**never return  a raw pointer.**因为有很多问题，谁拥有这个指针？谁把它删除了？他是全局的单例吗？考虑使用<code>owning_ptr</code>或者<code>no_owning_ptr</code>,或者一些零成本的包装在指针外面做一些，如果你必须的话。</li><li><strong>设计一致的错误处理策略。</strong>并且要强烈避免外带的错误报告，如errno，因为这会破坏了多线程友好的环境。所以我们要尽量让错误不能忽略，而不是返回一个错误代码。不要用optional来指示错误条件，它没有传递错误的理由，可以考虑用std::expected(cpp23)</li><li>下面是一个综合了上面的一些建议，对fopen重写的一个示例:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520085151221.png" alt="image-20240520085151221"></p><ul><li><strong>避免容易交换的参数。</strong>首先，两个相同类型的参数容易被交换，其次，就是<strong>避免隐式类型转换，或者使用强类型。</strong>下面是一个有趣的示例，可以避免char*的隐式转换带来的问题，就是为其多写一个重载,<strong>如果您=删除模板，它将成为任何非精确模板的匹配项参数和防止隐式转换</strong>,或者就是我们主动的明确的进行删除某个类型的<code>void func(double data)=delete</code>:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520085658505.png" alt="image-20240520085658505"></p><ul><li>为了验证我们的API设计的是否健壮，<strong>可以使用fuzzer进行测试，他会随机的对API进行一些输入然后去测试。</strong></li></ul><h1 id="RAII-in-Cpp-Andre-Kostur"><a href="#RAII-in-Cpp-Andre-Kostur" class="headerlink" title="RAII in Cpp Andre Kostur"></a>RAII in Cpp Andre Kostur</h1><p>额。。没咋认真看，感觉有用的东西不多。</p><h1 id="Smart-Pointers-David-Olsen"><a href="#Smart-Pointers-David-Olsen" class="headerlink" title="Smart Pointers David Olsen"></a>Smart Pointers David Olsen</h1><ul><li>对于unique_ptr，如果想把所有权转移到另外一个独占指针，不要使用<code>a.reset(b.release())</code>的形式，而是应该使用移动语义：<code>a = str::move(b);</code></li><li>当我们要把所有权转移到函数中，通过传值的方式传入std::unique_ptr。当我们要把所有权从函数中传出时，通过return std::unique_ptr的方式。</li><li><strong>不要通过指针来创建unique_ptr，除非知道该指针的来向并且他需要一个owner。</strong></li><li>unique_ptr不解决悬空指针的问题:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520213948099.png" alt="image-20240520213948099"></p><ul><li><strong>shared_ptr的use_count线程不安全。噢噢噢因为当我们使用use_count的返回值的时候，可能多线程中已经改变了计数了，那么此时我们使用的返回值已经滞后了的。所以不应该在多线程的生产环境中使用。</strong></li><li>若要共享所有权，必须创建额外的共享PTR对象或从一个现有的共享PTR，而不是原始指针：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520215756656.png" alt="image-20240520215756656"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520215916734.png" alt="image-20240520215916734"></p><ul><li><strong>从不同的线程更新相同的控制块，是线程安全的:</strong></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520220032937.png" alt="image-20240520220032937"></p><ul><li>但是不同的线程更新管理的对象是线程不安全的:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520220231080.png" alt="image-20240520220231080"></p><ul><li>cpp17时shared_ptr才支持array类型，cpp20才支持make_shared类型。</li><li>如果不知道改用shared_ptr还是unique_ptr，那么最好用unique_ptr，因为后面就算要改shared_ptr也会容易很多。</li><li>weak_ptr可以用来做缓存，其通过保持了一个“引用”使得可以获得对对象的快速访问，同时也可以使得不去让对象一直存活（如果用shared_ptr的话就会一直活)。还有就是可以解决悬空引用的问题。</li><li>自定义删除器来自动调用fclose:<code>struct fclose_deleter(){ void operator()(FILE* fp){fclose(fp);}; using unique_FILE = std::unique_ptr&lt;FILE,fclose_deleter&gt;;}</code></li><li>别名构造函数，可以实现两个智能指针使用相同的控制块，但是有不同的对象指针：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520221439507.png" alt="image-20240520221439507"></p><ul><li>shared_from_this:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520221537834.png" alt="image-20240520221537834"></p><h1 id="Testing-Amir-Kirsh"><a href="#Testing-Amir-Kirsh" class="headerlink" title="Testing - Amir Kirsh"></a>Testing - Amir Kirsh</h1><ul><li>单元测试是对函数，类的测试，如果我们可以单独的测试每一个函数和类，那么也可以尽快的在系统准备就绪之前发现bug。单元测试是重点，<strong>因为此时还处于项目的早期。</strong></li><li>好的单元测试可维护性强，可读性强，可依赖性强。</li><li>这个会议还是讲了很多gtest的使用的，不过没咋认真听。。额。。</li></ul><h1 id="Debugging-in-C-Mike-Shah"><a href="#Debugging-in-C-Mike-Shah" class="headerlink" title="Debugging in C++ Mike Shah"></a>Debugging in C++ Mike Shah</h1><ul><li><p>常见的普通的策略:</p><ol><li>Scan and look:如果对软件很熟悉，可能可以直接find bug.另外就是依赖编译器进行扫描，编译选项加上<code>-Wall -Wextra</code>。</li><li>printf调试策略。</li><li>delta调试策略。可以快速的帮忙找到错误发生的大致位置，就算没有源码，比如说<code>square(5) == 25</code>这行代码有bug，那么我们可以快速的定位到是square，也就是说通过先前拥有的专业知识进行定位的。</li><li>printf调试策略的加强：利用语言特性进行加强，如宏定义、文本替换，预处理指令等。通过这种方式我们可以让程序干净一点，</li><li>linux可以研究一下ptrace。</li><li>gdb清空终端打印利用ctrl L实现，或者refresh命令也可以。</li><li>target record-full 可以回退debuging，需要是新的调试器才行。</li><li>我们可以通过whatis object_name来知道object的类型，并且通过info vtbl来查看虚函数表。</li></ol><h1 id="Move-Semantics-Andreas-Fertig"><a href="#Move-Semantics-Andreas-Fertig" class="headerlink" title="Move Semantics - Andreas Fertig"></a>Move Semantics - Andreas Fertig</h1><p>移动和复制的示例:</p><p><img src="C:\Users\14064\AppData\Roaming\Typora\typora-user-images\image-20240522090932085.png" alt="image-20240522090932085"></p><p>值域:<br><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240522091658478.png" alt="image-20240522091658478"></p><ul><li><p><strong>使用exchange来实现移动的操作(cpp17)，面试的时候就写这个代码，加分项</strong>:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240522092024609.png" alt="image-20240522092024609"></p><ul><li><strong>被move后的对象会处于有效但未知的状态。这是因为cpp实现的是non-destructive move.</strong></li><li>两个规则：一般来说我们遵循simple rule，剩下的10%的时间，我们遵循第二条:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240522092703163.png" alt="image-20240522092703163"></p></li></ul><h1 id="Memory-Model-from-C-11-to-C-23"><a href="#Memory-Model-from-C-11-to-C-23" class="headerlink" title="Memory Model from C++11 to C++23"></a>Memory Model from C++11 to C++23</h1></li></ul><h2 id="Memory-Barrier"><a href="#Memory-Barrier" class="headerlink" title="Memory Barrier"></a>Memory Barrier</h2><p>他会限制中间的东西不会移动出去，但是中间的东西还是可能会发生重排的:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524075921689.png" alt="image-20240524075921689"></p><h2 id="c-并发"><a href="#c-并发" class="headerlink" title="c++并发"></a>c++并发</h2><ul><li>在X86系统上，atomic的load只是load，没有额外的性能开销。对于其他的机子的话可能会有加锁，加屏障的开销。</li><li>在x86系统上，atomic存储使用xchg，这是全屏障，需要开销。</li><li>c++20  std::atomic&lt; std::shared_ptr &gt;&gt;</li><li>jthread</li></ul><h1 id="以上的视频大都是cppcon2022的back-to-basics-以下是2023的"><a href="#以上的视频大都是cppcon2022的back-to-basics-以下是2023的" class="headerlink" title="以上的视频大都是cppcon2022的back to basics 以下是2023的"></a>以上的视频大都是cppcon2022的back to basics 以下是2023的</h1><h1 id="Range-Algorithms-in-C-Klaus-lglberger"><a href="#Range-Algorithms-in-C-Klaus-lglberger" class="headerlink" title="(Range) Algorithms in C++ Klaus lglberger"></a>(Range) Algorithms in C++ Klaus lglberger</h1><p>min_element():</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524082539055.png" alt="image-20240524082539055"></p><p>在这里学到了一个tip就是可以在cppreference中看到这个STL函数实现的源码:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524082615205.png" alt="image-20240524082615205"></p><p>在c++20中，我们可以使用std::ranges::min_element()再对上面进行简化:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524082708699.png" alt="image-20240524082708699"></p><p>下面是用ranges::partition()进行优化的例子:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524083334451.png" alt="image-20240524083334451"></p><p>下面是关于accumulate的一个很好的例子:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524085021856.png" alt="image-20240524085021856"></p><p>这里提供double的话，就不会出错，如果提供的是0的话，由于vector中的元素类型的double，那么会有问题的对于accumulate，在模板推导的时候。</p><ul><li><strong>accumulate保证从左到右的进行累加。</strong></li></ul><h1 id="C-Concurrency-David-Olsen"><a href="#C-Concurrency-David-Olsen" class="headerlink" title="C++ Concurrency - David Olsen"></a>C++ Concurrency - David Olsen</h1><p>cpp并行算法：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524091558591.png" alt="image-20240524091558591"></p><ul><li>数据竞争是未定义行为。</li><li>不要调用互斥锁的unlock()、lock()、try_lock()，永远用lock_guard。</li><li>std::scoped_lock的构造函数会调用每一个锁的lock()，析构函数会调用每一个锁的unlock()。</li><li>unique_lock是想要在作用域中取消几次解锁使用的。</li><li>由于没有同步机制，对于下面的这个case，<strong>编译器可能会把子线程中的while改为无限循环！或者也可能直接跳过了while循环，不等flag=true的设置。</strong>compile的连接:<a href="https://godbolt.org/z/Gj8dsq9n6">https://godbolt.org/z/Gj8dsq9n6</a></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525092608796.png" alt="image-20240525092608796"></p><ul><li>少更新的示例，下图不是一个很好的方法，因为更新的太频繁了:</li><li><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525093131596.png" alt="image-20240525093131596"></li></ul><p>我们可以给他优化成下面的这种形式:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525093156389.png" alt="image-20240525093156389"></p><h1 id="Back-to-Basics-Functions-in-C-Mike-Shah"><a href="#Back-to-Basics-Functions-in-C-Mike-Shah" class="headerlink" title="Back to Basics- Functions in C++ Mike Shah"></a>Back to Basics- Functions in C++ Mike Shah</h1><ul><li>把函数定义封装到几个文件中的好处，比如说隐藏实现细节，潜在的加速编译，可以循环利用代码</li><li>传引用的好处:1.想修改传入的值。2.避免拷贝。3.比指针更加安全。 </li><li>高阶函数:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525102654605.png" alt="image-20240525102654605"></p><ul><li>函数表:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525102731519.png" alt="image-20240525102731519"></p><h1 id="Initialization-in-C-Ben-Saks"><a href="#Initialization-in-C-Ben-Saks" class="headerlink" title="Initialization in C++ Ben Saks"></a>Initialization in C++ Ben Saks</h1><p>==看这个会议让我明白了聚合体很大概率是为了初始化？==</p><ul><li><p>copy-initializaiton:  <code>int x = 3;int* p = &amp;x;</code>，以下是其他的一些发生的情景：</p></li><li><p>aggregate-initialization:<code>struct widget{int id;double price;};widget w1 = {1000,6.5};int values[3] = {1,2,3};</code></p></li><li><p>zero-initialization: <code>widget w2 = {100}; // equal {100,0,0}</code></p></li><li><p>direct-Initialization:为了让用户自定义类型和内置类型统一，cpp支持像构造函数一样初始化scalar types:<code>int x(5);</code>cpp20开始支持direct-initialization初始化聚合体:<code>demo_str ds1("hello",5);demo_str ds2(ds1);</code>,<strong>实际上，以上两种都被当做 了direct-initialization.但是下面的被当做了copy-initialization，虽然他和ds2(ds1)一样调用的都是拷贝构造函数:<code>demo_str ds3 = ds2;</code></strong></p></li><li></li><li><p>因为类不变量(class invariant)的存在，所以就有一个很重要的规则:<strong>如果一个类c有任何用户提供的构造函数，那么类c就不再是聚合的，并且不支持聚合初始化。</strong></p></li><li><p>(cpp03)聚合类的定义:1.没有用户提供的构造函数，没有私有或者保护的非静态数据成员，没有基类，没有虚函数。</p></li><li><p>(cpp03-cpp20)聚合类的定义：没有用户定义的构造函数或者继承的构造函数u，没有私有或保护的direct non-static data members，没有虚的、私有、保护继承的基类，没有虚函数。</p></li><li><p>vacuous initialization:<code>int x;// initializationed</code>虽然you生命了，但是没有初始化。。</p></li><li><p>value-initialization: <code>demo_str* pds = new demo_str();</code>这就是值初始化。值初始化取决于type T,如果是用户定义的类，那么就会调用默认构造函数，如果T是数组，那么就会值初始化他的所有元素，如果是简单的scalar，就会零初始化。不然的话，除了上面的情况，值初始化只在没有用户提供的构造函数的场景才有效，对于每一个数据成员T，会调用他的零初始化，然后默认初始化。</p></li><li><p>Roundabout Value-Initialization:在cpp17之前<code>C c = C();</code>如果C没有拷贝构造函数，这个value-initializaiton会失败。</p></li><li><p>cpp03的一些问题：1.没有统一的初始化，这就导致在模板函数的编写时可能有问题，第二个问题是可能存在的窄型转换。第三个问题是值初始化很困难：</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525113524233.png" alt="image-20240525113524233"></p><ul><li>==brace-inialization: modern cpp的所有类型都支持{}初始化==</li><li>copy-list-initialization的例子,但是如果我们定义了一个接受std::initializaer_list的构造函数，那么就没有下面的问题了:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525114128214.png" alt="image-20240525114128214"></p><ul><li>init_initialization的一些想法注意点:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525114859895.png" alt="image-20240525114859895"></p><p>* </p><h1 id="Debuggin-in-Cpp-Greg-Law"><a href="#Debuggin-in-Cpp-Greg-Law" class="headerlink" title="Debuggin in Cpp - Greg Law"></a>Debuggin in Cpp - Greg Law</h1><ul><li>几种bug的主要形式：逻辑错误、指针错误、错误处理、条件竞争、接口假设（我们对接口的功能进行了错误的假设）。</li></ul><h2 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h2><ul><li>write down:一般遇到错误，是我们觉得这个错误是不可能出现的，这个时候可能我们复盘了很多次都觉得没有问题，<strong>我们可以尝试把它写下来。因为写的速度很慢，就能让我们花费更多的时间，更细心的去复盘一下。</strong></li><li>when you smell smoke,act. 当你意识到问题了，那就要往下一直查下去。</li><li>Lots and lots of assertions. 多加断言。</li><li>**write a test case, or panic.**这句话直接就是绝杀。</li><li></li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p><img src="C:\Users\14064\AppData\Roaming\Typora\typora-user-images\image-20240527084810027.png" alt="image-20240527084810027"></p><ul><li>LLDB的话一般苹果用的多。。</li><li>pstack也很好用。</li></ul><h1 id="Testing-in-C-Phil-Nash"><a href="#Testing-in-C-Phil-Nash" class="headerlink" title="Testing in C++ -Phil Nash"></a>Testing in C++ -Phil Nash</h1><p>什么是测试？<strong>说白了就是输入，然后操作，然后和期望的输出对比。</strong>：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528084030018.png" alt="image-20240528084030018"></p><p>上面的加粗的字就是最底层的测试的意思，假如说我们做了下面的操作，这也属于是测试：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528084153038.png" alt="image-20240528084153038"></p><p>当然编译器也可以是的。。我们用编译器，输入了我们的代码，然后期望编译没有问题。。</p><ul><li>有三类测试最重要：单元测试、集成测试、系统测试。</li></ul><p>满足以下条件的不属于单元测试:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528084422804.png" alt="image-20240528084422804"></p><ul><li>单元测试的最佳实践:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528090806229.png" alt="image-20240528090806229"></p><ul><li>测试的最佳实践:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528091157873.png" alt="image-20240528091157873"></p><ul><li>测试常见的陷阱和挑战：Flakey tests、Slow tests、Brittle tests、Hard to write.</li></ul><h1 id="Iterators-in-C"><a href="#Iterators-in-C" class="headerlink" title="Iterators in C++"></a>Iterators in C++</h1><ul><li>cpp20新增了一个连续迭代器:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530083320028.png" alt="image-20240530083320028"></p><ul><li>STL的组合:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530083653577.png" alt="image-20240530083653577"></p><ul><li>iter 的陷阱：1.迭代器可能会失效（eg: push_back后，或者erase后。。）</li><li>使用inserters:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530084239568.png" alt="image-20240530084239568"></p><ul><li>Filter View的UB:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530085125485.png" alt="image-20240530085125485"></p><ul><li>下面是另外一个例子:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530085222404.png" alt="image-20240530085222404"></p><h1 id="Expert’s-advice"><a href="#Expert’s-advice" class="headerlink" title="Expert’s advice"></a>Expert’s advice</h1><p>“ifyou want to improve code quality in your organization, I would say, take all your coding guidelines and replace them with the one goal. . No Raw Loops. This will make the biggest change in code quality within your organization.(Sean Parent, C++ Seasoning, Going Native 2013)</p><ul><li>并发的定义：“Multiple logical threads of execution with unknown inter-task dependencies Daisy Hollman, “A Unifying Abstraction for Async,” CppCon 2019</li><li>并行的定义：Multiple logical threads of execution with no inter-task dependencies<br>Daisy Hollman, “A Unifying Abstraction for Async,” CppCon 2019</li></ul><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="ITM-Initialize-Then-Modify"><a href="#ITM-Initialize-Then-Modify" class="headerlink" title="ITM: (Initialize Then Modify)"></a>ITM: (Initialize Then Modify)</h2><p>下面的age就是这个例子:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524084429836.png" alt="image-20240524084429836"></p><h2 id="most-vexing-parse"><a href="#most-vexing-parse" class="headerlink" title="most vexing parse"></a>most vexing parse</h2><p>C++中的”Most Vexing Parse”（最令人烦恼的解析问题）是一种特殊的语法解析现象，它源于C++编译器在解析源代码时的一种歧义性。这个问题通常发生在尝试声明一个对象并初始化它时，但编译器却错误地将其解析为函数声明的情况。这种解析歧义通常会让程序员感到困惑，因为它并不直观，并且可能导致难以察觉的错误:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj();  // 这可能被解析为一个函数声明，而不是对象实例化</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 网课学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++Core Guidelines笔记</title>
      <link href="/2024/05/06/c++core%20guidelines%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/06/c++core%20guidelines%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><ul><li>DRY（dont repeat yourself) 不要重复自己，即不应该多次编写相同的代码。</li><li>KISS( keep it simple,stupid) 保持简单，让傻瓜都能理解。</li><li>NNN(No Naked New)不要裸的New的缩写，它意味着内存分配的结果应该交给一个管理者对象。</li><li>YAGNI(you aren’t gonna need it)你不会需要它原则，不要在代码中预先投入过多的精力以使其成为可重用的库，而是要先写出代码，使其有可能被复用。</li></ul><h1 id="chapter-2-理念"><a href="#chapter-2-理念" class="headerlink" title="chapter 2 理念"></a>chapter 2 理念</h1><ul><li>要注意未定义行为和实现定义行为。</li><li>代码赢表达意图。</li><li><strong>理想情况下，程序应该是静态类型安全的。</strong></li><li>编译期检查优先于运行期检查，编译期不能检查的应该在运行期检查，要尽早识别运行期错误。</li><li><strong>不可变数据优先于可变数据，常量在并发程序中有很大的优势。</strong></li><li>选择使用辅助工具。</li></ul><h1 id="chapter3-接口"><a href="#chapter3-接口" class="headerlink" title="chapter3 接口"></a>chapter3 接口</h1><ul><li>让接口易用，难以错误使用。</li><li>避免非const的全局变量，他们会在函数中注入隐藏的依赖，同时会破坏封装，所以我们也需要避免单例。</li><li>推荐用注入依赖的方式来消除隐藏依赖，典型方式是构造函数、设置函数成员或模板参数。p14页</li><li>不要用单个指针来传递数组，，可以利用std::span来包一层，避免UB。</li><li>为了库ABI稳定考虑使用PImpl惯用法。</li></ul><h1 id="Chapter4-函数"><a href="#Chapter4-函数" class="headerlink" title="Chapter4 函数"></a>Chapter4 函数</h1><ul><li><strong>如果函数有可能需要在编译期求值，就把它声明为constexpr</strong>，这是纯函数，也是线程安全的。</li><li>纯函数是指在给定相同参数时总返回相同结果的函数。</li><li>对于入参，拷贝开销低的类型按值传递<code>(sizeof(par) &lt;= 2 * sizeof(void*))</code>,否则以const引用的方式传递。</li><li>参数传递：所有权语义：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240506202243356.png" alt="image-20240506202243356"></p><ul><li>返回T* （仅仅）用于表示位置；</li><li>当不希望发生拷贝，也不需要表达“没有返回对象”时，应返回 T&amp;</li><li>不要返回T&amp;&amp; 也不要返回 std::move(本地变量)</li></ul><h1 id="Chapter5-类和类层次结构"><a href="#Chapter5-类和类层次结构" class="headerlink" title="Chapter5 类和类层次结构"></a>Chapter5 类和类层次结构</h1><ul><li>把相关的数据组织到结构(struct 或者class)中。</li><li>当类具有不变式时使用class，如果数据成员可以独立变化则使用struct。</li><li><strong>在类中体现出接口和实现之间的区别。</strong></li><li>如果一个函数不需要访问类的内部结构，就不应该是成员。</li><li><strong>值类型：如果一个类行为像值，就是值类型。</strong></li><li>规范类型是行为类似于int的类型，一般支持：默认构造、拷贝构造、拷贝赋值、移动构造、移动赋值、析构、交换操作，相等运算符。</li><li>半规范类型则和规范类型相比，不支持==和!=运算符。</li><li>优先使用具体类型，而不是类层次结构。</li><li>确保可拷贝的（值类型）类有默认构造函数。</li><li><strong>默认情况下，把单参数的构造函数和转换运算符声明为explicit。</strong></li><li><strong>在使用常量初始化时，优先选择类内初始化器，而不是构造函数的成员初始化，然后在构造函数里优先使用初始化而不是赋值。</strong></li><li>使用委托构造函数来表明类的所有构造函数的共同动作。</li><li>使用继承构造函数将构造函数导入不需要进一步显式初始化的派生类中。</li><li><strong>我们要保证自赋值安全，即x = x不应该改变x的值。</strong>对于STL容器、string、和内置类型，如int等，拷贝/移动赋值对于自赋值是安全的，自动生成的拷贝/移动赋值运算符对于自赋值也是安全的。使用自赋值安全的类型自动生成的拷贝/移动赋值运算符也是如此。所以，<strong>我们应该利用上面的特点，避免多余、高开销的自赋值检查，因为这会让性能变差。</strong></li><li>多态类是定义或继承了至少一个虚函数的类，拷贝一个多态类容易出现切片，要小心。</li><li>如果一个类在对象销毁时需要有明确的动作，就定义析构函数。</li><li><strong>如果类里有原始指针或引用，请考虑它是否有所有权。</strong></li><li><strong>如果类有具有所有权的指针成员，请定义析构函数，去负责销毁。</strong></li><li>基类的析构函数应该要么是public且virtual，要么是protected且非virtual，如果基类的析构函数是protected，那么就不能用积累的指针或者引用来销毁派生对象。</li><li><strong>一个类如果要成为规范类型的话，就必须支持swap函数，并且swap不应该失败，应被生命为noexcept</strong>。</li><li><strong>使==对操作符的类型对称，并使其noexcept</strong>，这一条有意思的，看下面示例,注意，由于下面示例用explicit避免了隐式转换，所以我们需要再多定义两个friend函数来实现:</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyInt{</span><br><span class="line">int num;</span><br><span class="line">public:</span><br><span class="line">explicit MyInt(int n):num(n){};</span><br><span class="line">friend bool operator == (const MyInt&amp; lhs,const MyInt&amp; rhs)noexcept {</span><br><span class="line">retrurn lhs.num == rhs.num;</span><br><span class="line">}</span><br><span class="line">friend bool operator == (int lhs,const MyInt&amp; rhs)noexcept {</span><br><span class="line">retrurn lhs == rhs.num;</span><br><span class="line">}</span><br><span class="line">friend bool operator == (const MyInt&amp; lhs,int rhs)noexcept {</span><br><span class="line">retrurn lhs.num == rhs;</span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyInt(5) == 5;//Ok</span><br><span class="line">5 == MyInt(5); //Ok</span><br></pre></td></tr></tbody></table></figure><ul><li><p>当心基类的==、！=、&lt;、&lt;=、&gt;、&gt;=。</p></li><li><p><strong>基类通常有两种用途：接口继承，实现继承。</strong>接口继承使用公共继承，把用户和实现分开，允许派生类增加或改变基类的功能而不影响基类的用户。实现继承经常使用私有继承，典型情况下派生类通过调整基类的功能来提供其功能，实现继承的一个典型例子是适配器模式。</p></li><li><p>仅使用类的层次结构啦表达具有内在层次结构的概念。</p></li><li><p>如果基类被当做接口使用，就把它变为抽象类。</p></li><li><p>当需要完全分离接口和实现时，以抽象类作为接口。</p></li><li><p><strong>若要对多态类进行深拷贝，应使用虚函数clone，而不是公开的拷贝构造/赋值，因为拷贝一个多态类可能会导致切片问题。</strong>为了解决这个问题，通过虚的clone函数让他根据实际类型进行复制并返回一个到新对象的有所有权的指针（unique_ptr)。在派生类里，通过使用所谓的协变返回类型来返回派生类型。</p><p><strong>协变返回类型</strong>：允许覆盖成员函数返回被覆盖成员函数的返回类型的派生类型。==这个协变返回类型还是很有意思的，可以看眼实现==</p></li><li><p>不要无缘无故把成员函数变为virtual，是需要代价的。</p></li><li><p>避免protected数据，如果把protected数据放在了基类里，就不能单独考虑派生类，因而破坏了封装。在进行protected要问三个问题：1.必须实现一个构造函数来初始化protected数据吗？  2.protected数据他们的实际价值是什么？  3.修改protected数据谁会受到影响？</p></li><li><p>确保所有的非const数据成员有相同的访问级别。</p></li><li><p>在设计类的层次结构时，要区分实现继承和接口继承。纯接口继承是指你的基类只有纯虚函数。</p></li><li><p><strong>不要为虚函数和它的覆盖函数提供不同的默认参数</strong>。</p></li><li><p><strong>永远不要把指向派生类对象数组的指针赋值给指向基类的指针。</strong></p></li><li><p>应当对带有常规含义的操作使用运算符，比如说比较操作、算数操作、对象访问、对象赋值、输入和输出操作。</p></li><li><p>对于对称的运算符，应采用非成员函数。</p></li><li><p>重载的操作应当大致等价，仅对大致等价的操作进行重载。</p></li><li><p>使用联合体来节约内存，但不要使用裸联合体，尽量使用带标签联合体，如std::variant.</p></li></ul><h1 id="chapter6-枚举"><a href="#chapter6-枚举" class="headerlink" title="chapter6 枚举"></a>chapter6 枚举</h1><ul><li>传统枚举的缺陷：没有作用域、会隐式转换为int、会污染全局命名空间、类型未知。</li><li>优先使用enum class，并且仅在必要时指定有作用域枚举的底层类型和枚举项的值。</li></ul><h1 id="chapter7-资源管理"><a href="#chapter7-资源管理" class="headerlink" title="chapter7 资源管理"></a>chapter7 资源管理</h1><p><strong>资源管理关键点是所有权。</strong></p><ul><li>原始指针(T*)以及原始引用(T&amp;) 不表示所有权。</li><li>在一条表达式语句中最多进行一次显式资源分配。</li><li>用unique_ptr或shared_ptr表示所有权。</li><li>除非需要共享所有权，否则能用unique_ptr就别用shared_ptr。</li><li>使用make_shared()创建shared_ptr和使用make_unique()创建unique_ptr。</li><li>用weak_ptr来打破shared_ptr形成的环。</li><li>函数参数的语义：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240507081541543.png" alt="image-20240507081541543"></p><ul><li>不要传递从指针别名中获得的指针或引用。</li><li><strong>按值接受智能指针作为函数参数以表达所有权语义；按引用接受智能指针以表达函数可能会重装智能指针。</strong></li></ul><h1 id="Chapter8-表达式和语句"><a href="#Chapter8-表达式和语句" class="headerlink" title="Chapter8 表达式和语句"></a>Chapter8 表达式和语句</h1><ul><li><p><strong>优先使用标准库，而不是其他库和“手工代码。</strong></p></li><li><p>始终初始化对象，优先使用{}初始化语法。</p></li><li><p><strong>使用lambda表达式进行复杂的初始化，尤其是对于const变量。</strong>如:</p></li><li><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const widget x = [&amp;]{</span><br><span class="line">widget val;</span><br><span class="line">for(auto i=2;i&lt;=N;++i){</span><br><span class="line">val += some_obj.do_something_with(i);</span><br><span class="line">}</span><br><span class="line">return val;</span><br><span class="line">}();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>保持指针的使用简单明了。</p></li><li><p><strong>避免有未定义的求职顺序表达式</strong>。如：v[i] = ++i; // UB</p></li><li><p>不要依赖函数参数的求值顺序。</p></li><li><p>要避免转型，如果必须转型，请使用具名转型，如: static_cast、const_cast、reinterpret_cast、dynamic_cast、std::move、std::forward。</p></li><li><p>不要用转型去除const。</p></li><li><p>除非有特殊原因，否则应使用有符号的整数，不要混合使用有符号和无符号算术。</p></li><li><p>请注意，上溢和下溢是未定义行为，通常在程序运行时以崩溃告终。</p></li></ul><h1 id="Chapter9-性能"><a href="#Chapter9-性能" class="headerlink" title="Chapter9 性能"></a>Chapter9 性能</h1><ul><li><strong>错误的优化：1.不要无故优化、2.不要过早进行优化、3.不要优化并非性能关键的东西。</strong></li><li><strong>错误的假设：1.不要假设复杂的代码一定比简单的快、2.不要假设低级代码一定比高级代码块、3.不要在没有测量的情况下对性能妄下断言。</strong></li><li>如果想知道哪段代码优化的更好，就必须研究生成的汇编指令。</li><li>我们的设计应该允许优化。</li><li>有很多方法可以帮助编译器生成更优化的代码：1.写本地代码，若使用就地调用的lambda表达式来调整sort的行为代码会更快，但是如果函数在另外一个翻译单元中，对优化器来说是一个硬边界。 2.写简单的代码，这样优化器会搜寻可以被优化的已知模式。  3.给予编译器额外的提示：如果函数不抛出异常就声明为noexcept,或者如果虚函数不应该被覆盖就声明为final，这对优化器来说也是很有意义的。</li><li><strong>将计算从运行期移至编译期</strong>。</li><li>以可预测的方式访问内存，这也是为什么vector快的原因。</li></ul><h1 id="Chapter10-并发"><a href="#Chapter10-并发" class="headerlink" title="Chapter10 并发"></a>Chapter10 并发</h1><ul><li>假设代码将作为多线程程序的一部分来运行。</li><li>避免数据竞争。<strong>如果程序有数据竞争，那么程序就有未定义行为</strong>。</li><li>尽量减少对可写数据的显式共享。</li><li>只要可行，就用工具对并发代码进行验证，ThreadSanitizer提供了全局信息，检测程序的执行是否存在数据竞争，CppMem能让你深入理解代码里的小片段。</li><li>将汇合thread看作一个有作用域的容器，将thread看作一个全局容器。</li><li>优先使用jthread，而不是thread。</li><li>不要对线程调用detach()</li><li>在线程之间传递少量数据时使用值传递，而不是引用或指针。</li><li>要在不相关的thread之间分享所有权，请使用shared_ptr。</li><li><strong>尽量减少上下文切换，尽量减少线程的创建和销毁。</strong></li><li>使用future从并发任务返回值，使用async()生成并发任务。</li><li>使用诺值和期值来同步线程，他们和条件变量有很多共同之处，一般来说也会更加安全。</li><li><strong>除非绝对需要，否则不要使用无锁编程。</strong></li><li>不要轻信硬件/编译器组合。</li></ul><h1 id="Chapter11-错误处理"><a href="#Chapter11-错误处理" class="headerlink" title="Chapter11 错误处理"></a>Chapter11 错误处理</h1><ul><li>异常安全的基本契约的四个层次: 1.不抛出保证。2.强异常安全。3.基本异常安全。4.无异常安全。</li><li>应使用专门设计的用户定义类型（而非内置类型）作为异常。这句话的意思是我们当然可以<code>throw 7</code>,但是最好<code>throw runtime_error</code>甚至从runtime_error派生出自己的异常，这样的话可以附加额外的信息。</li><li>在直接拥有对象时绝不抛出异常，会内存泄露。</li><li>如果不能抛出异常，则考虑快速失败或者系统的使用错误代码。</li></ul><h1 id="Chapter12-常量和不变性"><a href="#Chapter12-常量和不变性" class="headerlink" title="Chapter12 常量和不变性"></a>Chapter12 常量和不变性</h1><ul><li><strong>默认情况下，使对象不可变。</strong></li><li>默认情况下，成员函数应声明为const。</li><li>物理常量性：对象被声明为const，因此不能改变，它在内存中的表示方式是固定的。逻辑常量性：对象被声明为const，但可以被改变，它的逻辑值是固定的，但它在内存中的表示方式可能在运行期发生变化。</li></ul><h1 id="Chapter13-模板和泛型编程"><a href="#Chapter13-模板和泛型编程" class="headerlink" title="Chapter13 模板和泛型编程"></a>Chapter13 模板和泛型编程</h1><ul><li>使用模板来提高代码的抽象程度。</li><li>使用模板来表达适用于多种参数类型的算法。</li><li>避免使用有常见名称的高可见度无约束模板，这会引起ADL的意外情况。</li><li>如果模板不支持概念，可以使用enable_if来模拟。</li><li>如果模板的成员不依赖于模板参数，请将其从模板中移出。</li><li>…Args代表的是打包参数包，Args…代表的是解包参数包。</li><li>理论上，模板元编程是图灵完备的，因此可以解决任何计算问题。</li><li>类型特征库可以进行特征的处理，如进行类型检查，进行类型比较(eg:is_base_of)，进行类型修改(eg: remove_const),可以通过类型特征库来提高程序的正确性和性能优化。</li></ul><h1 id="Chapter14-C风格编程"><a href="#Chapter14-C风格编程" class="headerlink" title="Chapter14 C风格编程"></a>Chapter14 C风格编程</h1><ul><li>不要使用c风格。</li><li>extern “C” 链接说明符可以防止c++编译器重编这些名字。</li></ul><h1 id="Chapter15-源文件"><a href="#Chapter15-源文件" class="headerlink" title="Chapter15 源文件"></a>Chapter15 源文件</h1><ul><li>.h文件不可含有对象定义或非内联函数定义。</li><li>单一定义规则：ODR是One Definition Rule的缩写，就是说一个函数在任何翻译单元中不能有一个以上的定义。一个函数在程序中不能有一个以上的定义，有外部链接的内联函数可以在一个以上的翻译单元中被定义，这些定义必须满足一个要求：他们全部相同。</li><li>避免对隐含#include进来的名字的依赖，如未将<string>加入程序中，但是gcc5.4以上版本会在<iostream>中包含<string>，<strong>所以要确保引入该引入的头文件</strong>。</string></iostream></string></li><li><strong>不要在头文件的全局作用域中使用using namespace</strong></li><li>不要在头文件使用匿名命名空间，并且为所有的内部/不导出的实体使用匿名命名空间。</li></ul><h1 id="Chapter16-标准库"><a href="#Chapter16-标准库" class="headerlink" title="Chapter16 标准库"></a>Chapter16 标准库</h1><ul><li>优先采用vector，除非有别的理由用其他的容器，因为vector有最快的通用访问，最快的默认访问方式，最低的空间开销。</li><li><strong>避免使用endl,而是\n，因为endl会刷新缓冲区，速度比\n慢10-20%</strong></li></ul><h1 id="Chapter17-架构观念"><a href="#Chapter17-架构观念" class="headerlink" title="Chapter17 架构观念"></a>Chapter17 架构观念</h1><ul><li>从不稳定的代码中分离稳定的代码</li><li>将潜在可复用的部分表达为程序库，当你会重用某功能至少两次时，应该把它写成一个库。</li><li>程序库之间不应该有循环依赖。</li></ul><h1 id="Chapter18-伪规则和误解"><a href="#Chapter18-伪规则和误解" class="headerlink" title="Chapter18 伪规则和误解"></a>Chapter18 伪规则和误解</h1><ul><li>不要坚持认为声明都应当放在函数的最上面。</li><li>不要坚持在一个函数中只保留一条return语句。</li><li>不要避免使用异常。</li><li>不要坚持把每个类声明放在独立的源文件中。</li><li>不要采用两阶段初始化。</li><li>不要把所有清理操作放在函数末尾并使用goto exit。</li><li>不要使所有数据成员protected。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机摄影笔记</title>
      <link href="/2024/04/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/21/%E6%89%8B%E6%9C%BA%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="1-拍摄前擦拭一下镜头。"><a href="#1-拍摄前擦拭一下镜头。" class="headerlink" title="1.拍摄前擦拭一下镜头。"></a>1.拍摄前擦拭一下镜头。</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421214943514.png" alt="image-20240421214943514"></p><h2 id="2-拍摄花的时候可以只拍单只，然后对焦"><a href="#2-拍摄花的时候可以只拍单只，然后对焦" class="headerlink" title="2.拍摄花的时候可以只拍单只，然后对焦"></a>2.拍摄花的时候可以只拍单只，然后对焦</h2><p>比如说点击红点部分。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421215134910.png" alt="image-20240421215134910"></p><h2 id="3-逆光拍照时，拖动“小太阳”补光"><a href="#3-逆光拍照时，拖动“小太阳”补光" class="headerlink" title="3.逆光拍照时，拖动“小太阳”补光"></a>3.逆光拍照时，拖动“小太阳”补光</h2><p>比如说下面的场景，我们想要对“重庆园三个字补光”，<strong>拖动小太阳向上进行补光，向下可以来获得剪影，另外向下的话也可以提高对比度，更加的突出鲜明的颜色</strong>，一般来说点对焦就可以自动的平衡：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421220012822.png" alt="image-20240421220012822"></p><p>人像模式下可以调整光圈达到不同背景虚化效果。海边、或者夕阳很有用。</p><h2 id="3-手机的焦段的设置"><a href="#3-手机的焦段的设置" class="headerlink" title="3.手机的焦段的设置"></a>3.手机的焦段的设置</h2><p>0.5,1，2.5是焦段的变化，0.5是广角的镜头，会拍出来更多的景象。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421221629212.png" alt="image-20240421221629212"></p><h2 id="4-框架构图"><a href="#4-框架构图" class="headerlink" title="4.框架构图"></a>4.框架构图</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421222121181.png" alt="image-20240421222121181"></p><p>效果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421222221657.png" alt="image-20240421222221657"></p><p>长焦镜头增加场景，如下图，利用2.5拍照，并且在柳树前面拍，来让柳树作为前景:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421222344235.png" alt="image-20240421222344235"></p><p>下面又是一个广角的照片，注意这里的角度非常好，让建筑刚刚遮住太阳，漏出一点点星芒。他有一个非常好的特点就是畸变，可以把近处的景观拍的更大。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423075526860.png" alt="image-20240423075526860"></p><h2 id="5-人物模式"><a href="#5-人物模式" class="headerlink" title="5.人物模式"></a>5.人物模式</h2><p>在拍人物的时候，我们首先可以用2.5的焦段，这样的话可以让人物放在主体，然后点击人像，<strong>可以让周围的其他景象给虚化掉。</strong></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423075910109.png" alt="image-20240423075910109"></p><p>人像模式还可以调整光圈</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423080103229.png" alt="image-20240423080103229"></p><h2 id="6-手机拍出投影图片"><a href="#6-手机拍出投影图片" class="headerlink" title="6.手机拍出投影图片"></a>6.手机拍出投影图片</h2><p>拍摄墙上的光影：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423080441278.png" alt="image-20240423080441278"></p><p>或者我们换一种构图:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423080501431.png" alt="image-20240423080501431"></p><p>如果拍垂直的或者有正方形的物体，要注意在水平的位置上进行拍摄:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423080707295.png" alt="image-20240423080707295"></p><h2 id="7-手机全景模式"><a href="#7-手机全景模式" class="headerlink" title="7.手机全景模式"></a>7.手机全景模式</h2><p>比如说下面的这个场景，就要用全景模式才可以把大门给完全包围到:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083004198.png" alt="image-20240423083004198"></p><p>点击一下箭头可以改变全景的时候的移动的方向,，<strong>一般建议从亮的地方到暗的地方滑动</strong>:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083041381.png" alt="image-20240423083041381"></p><p>全景模式还可以从下到上的移动，通过这种方式来把所有的建筑都给装进去:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083210761.png" alt="image-20240423083210761"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083258975.png" alt="image-20240423083258975"></p><p>全景实现分身的效果:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083412599.png" alt="image-20240423083412599"></p><h2 id="8-前景的利用"><a href="#8-前景的利用" class="headerlink" title="8.前景的利用"></a>8.前景的利用</h2><p>前景一般是在拍照的过程中作为装饰性的一部分的内容。一般有三种形式:</p><ol><li>留意一些窗户，和门这些<strong>规则性的形状</strong> ，有时候他们可以做前景。</li></ol><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083644401.png" alt="image-20240423083644401"></p><p>下面是一个有问题的照片:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083739881.png" alt="image-20240423083739881"></p><p>下面的话就是用花来盖住天空的,，画面就更加的有层次了。:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423083836980.png" alt="image-20240423083836980"></p><p><strong>逆光的话，天空会很惨白，水面也是</strong>,比如说下面就是一个不好看的照片:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423084240013.png" alt="image-20240423084240013"></p><p>这个时候我们可以找下面的前景，图片下面的前景第一可以遮挡到地面不好看的东西，第二点是可以遮挡住整个画面中下面空白的部分，第三的话就是可以让整个画面更有层次感。</p><p>比如硕下面的照片比上面的好多了，首先压低不漏出太多的天空，第二点是用下面的前景来填充下面部分：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423084424983.png" alt="image-20240423084424983"></p><h2 id="9-湖水倒影的拍照"><a href="#9-湖水倒影的拍照" class="headerlink" title="9.湖水倒影的拍照"></a>9.湖水倒影的拍照</h2><p>如果在水的旁边我们是高于水的水平面的，这个时候拍出来的照片不是那么好看,<strong>因为此时实体的面积要比倒影的面积要大，就非常的不平衡</strong>:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423084814185.png" alt="image-20240423084814185"></p><p>这个时候我们要<strong>尽可能的压低拍照的水平高度，把手机压下来，并且可以倒过来进行拍照</strong>:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423084953483.png" alt="image-20240423084953483"></p><p>没有水的话可以自己造水，比如倒点矿泉水:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423085238605.png" alt="image-20240423085238605"></p><p>也可以横屏来拍，注意让镜头贴近地面:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423085334153.png" alt="image-20240423085334153"></p><h2 id="10-如何拍花"><a href="#10-如何拍花" class="headerlink" title="10.如何拍花"></a>10.如何拍花</h2><p>拍摄小花最好角度低点</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423085702855.png" alt="image-20240423085702855"></p><p><strong>其实上面的图不是特别的好还，因为是顺光拍摄的，最好逆光拍摄，然后调节一下小太阳，，花就看着非常的透了</strong>:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423085813717.png" alt="image-20240423085813717"></p><p>用蓝天做背景拍摄小花:首先找到最近对象距离，然后对焦一下并且长按对焦，这样就会自动曝光和自动对焦锁定，这个时候我们把手机扣过来，按音量键进行拍照:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423090050758.png" alt="image-20240423090050758"></p><p>这么拍有点押宝但是也是会拍出来好的照片的:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423090120321.png" alt="image-20240423090120321"></p><p>下面是一种暗调拍摄白玉兰的方法，拉低小太阳，<strong>同时选择一个深色的背景</strong>:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423090250101.png" alt="image-20240423090250101"></p><p>下面的话则是亮调的白玉兰的拍摄方法，以天空为背景，拉高小太阳:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423090405019.png" alt="image-20240423090405019"></p><p><strong>亮调白玉兰的拍摄过程最主要的其实是如何选择一个很好的层次和角度</strong>,比如说下面这个就很有层次感:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423090514618.png" alt="image-20240423090514618"></p><h2 id="11-如何在普通场景中找到视觉美点"><a href="#11-如何在普通场景中找到视觉美点" class="headerlink" title="11.如何在普通场景中找到视觉美点"></a>11.如何在普通场景中找到视觉美点</h2><p>在一个场景中，<strong>我们要优先考虑光影</strong>，因为光影是容易转瞬即逝的，拉低小太阳:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423090817693.png" alt="image-20240423090817693"></p><p>阳光洒在了小花上:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423090850839.png" alt="image-20240423090850839"></p><p>用广角拍摄天空：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423091039088.png" alt="image-20240423091039088"></p><p>拍楼梯:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240423091116164.png" alt="image-20240423091116164"></p><p><strong>下拉小太阳才是唯一的真神</strong>。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
            <tag> 书摘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言常见库示例</title>
      <link href="/2024/01/10/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2024/01/10/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="常见库"><a href="#常见库" class="headerlink" title="常见库"></a>常见库</h1><table><thead><tr><th>包名</th><th>用途</th><th>备注</th></tr></thead><tbody><tr><td>os包</td><td>os包以跨平台的方式，提供了一些与操作系统交互的函数和变量。比如程序的命令行参数可从os包的Args变量获取 ;os包外部使用oS.Args访问该变量。</td><td></td></tr><tr><td>net/http</td><td></td><td></td></tr><tr><td>io/ioutil</td><td></td><td></td></tr></tbody></table><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Fmt库"><a href="#Fmt库" class="headerlink" title="Fmt库"></a>Fmt库</h2><p>Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fmt.Print("在终端打印该信息。")</span><br><span class="line">name := "枯藤"</span><br><span class="line">fmt.Printf("我是：%s\n", name)</span><br><span class="line">fmt.Println("在终端打印单独一行显示")</span><br><span class="line"></span><br><span class="line">fmt.Fprintln(os.Stdout, "向标准输出写入内容")</span><br><span class="line">fileObj, err := os.OpenFile("./xx.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)</span><br><span class="line">if err != nil {</span><br><span class="line">    fmt.Println("打开文件出错，err:", err)</span><br><span class="line">    return</span><br><span class="line">}</span><br><span class="line">name := "枯藤"</span><br><span class="line">// 向打开的文件句柄中写入内容</span><br><span class="line">fmt.Fprintf(fileObj, "往文件中写如信息：%s", name)</span><br><span class="line"></span><br><span class="line">err := fmt.Errorf("这是一个错误")//根据format参数生成格式化字符串并返回一个包含该字符串的错误。</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">name    string</span><br><span class="line">age     int</span><br><span class="line">married bool</span><br><span class="line">)</span><br><span class="line">fmt.Scan(&amp;name, &amp;age, &amp;married) // 从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。</span><br><span class="line">fmt.Scanf("1:%s 2:%d 3:%t", &amp;name, &amp;age, &amp;married) // 根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。</span><br><span class="line">fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)</span><br></pre></td></tr></tbody></table></figure><h2 id="Time库"><a href="#Time库" class="headerlink" title="Time库"></a>Time库</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func timeDemo() {</span><br><span class="line">    now := time.Now() //获取当前时间</span><br><span class="line">    fmt.Printf("current time:%v\n", now)</span><br><span class="line"></span><br><span class="line">    year := now.Year()     //年</span><br><span class="line">    month := now.Month()   //月</span><br><span class="line">    day := now.Day()       //日</span><br><span class="line">    hour := now.Hour()     //小时</span><br><span class="line">    minute := now.Minute() //分钟</span><br><span class="line">    second := now.Second() //秒</span><br><span class="line">    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)</span><br><span class="line">}</span><br><span class="line">//下面是一个定时器，定时器本质上是channel</span><br><span class="line">func tickDemo() {</span><br><span class="line">    ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器</span><br><span class="line">    for i := range ticker {</span><br><span class="line">        fmt.Println(i)//每秒都会执行的任务</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">// 下面是关于格式化的示例函数</span><br><span class="line">func formatDemo() {</span><br><span class="line">    now := time.Now()</span><br><span class="line">    // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span><br><span class="line">    // 24小时制</span><br><span class="line">    fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))</span><br><span class="line">    // 12小时制</span><br><span class="line">    fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))</span><br><span class="line">    fmt.Println(now.Format("2006/01/02 15:04"))</span><br><span class="line">    fmt.Println(now.Format("15:04 2006/01/02"))</span><br><span class="line">    fmt.Println(now.Format("2006/01/02"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Flag库"><a href="#Flag库" class="headerlink" title="Flag库"></a>Flag库</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func main() {</span><br><span class="line">    //os.Args是一个[]string</span><br><span class="line">    //获取命令行参数的数量以及具体的值</span><br><span class="line">    if len(os.Args) &gt; 0 {</span><br><span class="line">        for index, arg := range os.Args {</span><br><span class="line">            fmt.Printf("args[%d]=%v\n", index, arg)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 定义命令行flag参数的方法1</span><br><span class="line">name := flag.String("name", "张三", "姓名")</span><br><span class="line">age := flag.Int("age", 18, "年龄")</span><br><span class="line">married := flag.Bool("married", false, "婚否")</span><br><span class="line">delay := flag.Duration("d", 0, "时间间隔")</span><br><span class="line"></span><br><span class="line">//定义命令行flag参数的方法2</span><br><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">var married bool</span><br><span class="line">var delay time.Duration</span><br><span class="line">flag.StringVar(&amp;name, "name", "张三", "姓名")</span><br><span class="line">flag.IntVar(&amp;age, "age", 18, "年龄")</span><br><span class="line">flag.BoolVar(&amp;married, "married", false, "婚否")</span><br><span class="line">flag.DurationVar(&amp;delay, "d", 0, "时间间隔")</span><br><span class="line"></span><br><span class="line">// 通过上述命令定义好后，可以进行解析命令行参数</span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Println(name, age, married, delay)</span><br><span class="line">//返回命令行参数后的其他参数</span><br><span class="line">fmt.Println(flag.Args())</span><br><span class="line">//返回命令行参数后的其他参数个数</span><br><span class="line">fmt.Println(flag.NArg())</span><br><span class="line">//返回使用的命令行参数个数</span><br><span class="line">fmt.Println(flag.NFlag())</span><br><span class="line"> $ ./flag_demo -name pprof --age 28 -married=false -d=1h30m //具体的使用</span><br></pre></td></tr></tbody></table></figure><h1 id="Os库"><a href="#Os库" class="headerlink" title="Os库"></a>Os库</h1><p>这个库主要用来操作IO的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 只读方式打开当前目录下的main.go文件</span><br><span class="line">file, err := os.Open("./main.go")</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Println("open file failed!, err:", err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">// 关闭文件</span><br><span class="line">file.Close()</span><br><span class="line"></span><br><span class="line">// 新建文件并写入内容</span><br><span class="line">file, err := os.Create("./xxx.txt")</span><br><span class="line">if err != nil {</span><br><span class="line">fmt.Println(err)</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">defer file.Close()</span><br><span class="line">for i := 0; i &lt; 5; i++ {</span><br><span class="line">file.WriteString("ab\n")</span><br><span class="line">file.Write([]byte("cd\n"))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Strconv库"><a href="#Strconv库" class="headerlink" title="Strconv库"></a>Strconv库</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s1 := "100"</span><br><span class="line">i1, err := strconv.Atoi(s1)// 字符串转整数</span><br><span class="line"></span><br><span class="line">i2 := 200</span><br><span class="line">s2 := strconv.Itoa(i2)// 整数转字符串</span><br><span class="line">b, err := strconv.ParseBool("true")</span><br><span class="line">f, err := strconv.ParseFloat("3.1415", 64)//(s string, bitSize int)</span><br><span class="line">i, err := strconv.ParseInt("-2", 10, 64)//(s string, base int, bitSize int)</span><br><span class="line">u, err := strconv.ParseUint("2", 10, 64)</span><br><span class="line"></span><br><span class="line">//Format系列喝Parse系列对应相反</span><br><span class="line">s1 := strconv.FormatBool(true)</span><br><span class="line">s2 := strconv.FormatFloat(3.1415, 'E', -1, 64)</span><br><span class="line">s3 := strconv.FormatInt(-2, 16)</span><br><span class="line">s4 := strconv.FormatUint(2, 16)</span><br></pre></td></tr></tbody></table></figure><h2 id="Template库"><a href="#Template库" class="headerlink" title="Template库"></a>Template库</h2><p>关于这个库我觉得对于写html的话会非常方便的，这里我也不写，就先给略掉了吧。</p><h2 id="net-x2F-http库"><a href="#net-x2F-http库" class="headerlink" title="net/http库"></a>net/http库</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get("http://5lmh.com/")</span><br><span class="line">...</span><br><span class="line">defer resp.Body.Close()//程序在使用完response后必须关闭回复的主体</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"></span><br><span class="line">resp, err := http.Post("http://5lmh.com/upload", "image/jpeg", &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm("http://5lmh.com/form",</span><br><span class="line">    url.Values{"key": {"Value"}, "id": {"123"}})</span><br></pre></td></tr></tbody></table></figure><h2 id="Context库"><a href="#Context库" class="headerlink" title="Context库"></a>Context库</h2><p>略。。</p><h1 id="其他常用库"><a href="#其他常用库" class="headerlink" title="其他常用库"></a>其他常用库</h1><h2 id="Gin库"><a href="#Gin库" class="headerlink" title="Gin库"></a>Gin库</h2><p>hello world:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> // 1.创建路由</span><br><span class="line">r := gin.Default()</span><br><span class="line">// 2.绑定路由规则，执行的函数</span><br><span class="line">// gin.Context，封装了request和response</span><br><span class="line">r.GET("/", func(c *gin.Context) {</span><br><span class="line">   c.String(http.StatusOK, "hello World!")</span><br><span class="line">})</span><br><span class="line">// 3.监听端口，默认在8080</span><br><span class="line">// Run("里面不指定端口号默认为8080") </span><br><span class="line">r.Run(":8000")</span><br></pre></td></tr></tbody></table></figure><p>通过Context的Param方法来获取API参数:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">r.GET("/user/:name/*action", func(c *gin.Context) {</span><br><span class="line">name := c.Param("name")</span><br><span class="line">action := c.Param("action")</span><br><span class="line">//截取/</span><br><span class="line">action = strings.Trim(action, "/")</span><br><span class="line">c.String(http.StatusOK, name+" is "+action)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>效果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240109212626579.png" alt="image-20240109212626579"></p><p>URL参数可以通过DefaultQuery()或Query()方法获取，DefaultQuery()若参数不村则，返回默认值，Query()若不存在，返回空串：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">r.GET("/user", func(c *gin.Context) {</span><br><span class="line">//指定默认值</span><br><span class="line">//http://localhost:8080/user 才会打印出来默认的值</span><br><span class="line">name := c.DefaultQuery("name", "枯藤")</span><br><span class="line">c.String(http.StatusOK, fmt.Sprintf("hello %s", name))</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240109212847556.png" alt="image-20240109212847556"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240109212857418.png" alt="image-20240109212857418"></p><ul><li><p>表单传输为post请求，http常见的传输格式为四种：</p><ul><li>application/json</li><li>application/x-www-form-urlencoded</li><li>application/xml</li><li>multipart/form-data</li></ul></li><li><p>表单参数可以通过PostForm()方法获取，该方法默认解析的是x-www-form-urlencoded或from-data格式的参数</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">r.POST("/form", func(c *gin.Context) {</span><br><span class="line">types := c.DefaultPostForm("type", "post")</span><br><span class="line">username := c.PostForm("username")</span><br><span class="line">password := c.PostForm("userpassword")</span><br><span class="line">// c.String(http.StatusOK, fmt.Sprintf("username:%s,password:%s,type:%s", username, password, types))</span><br><span class="line">c.String(http.StatusOK, fmt.Sprintf("username:%s,password:%s,type:%s", username, password, types))</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>routes group:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建路由</span><br><span class="line">// 默认使用了2个中间件Logger(), Recovery()</span><br><span class="line">r := gin.Default()</span><br><span class="line">// 路由组1 ，处理GET请求</span><br><span class="line">v1 := r.Group("/v1")</span><br><span class="line">// {} 是书写规范</span><br><span class="line">{</span><br><span class="line">v1.GET("/login", login)</span><br><span class="line">v1.GET("submit", submit)</span><br><span class="line">}</span><br><span class="line">v2 := r.Group("/v2")</span><br><span class="line">{</span><br><span class="line">v2.POST("/login", login)</span><br><span class="line">v2.POST("/submit", submit)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>json数据解析和绑定:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 定义接收数据的结构体</span><br><span class="line">type Login struct {</span><br><span class="line">   // binding:"required"修饰的字段，若接收为空值，则报错，是必须字段</span><br><span class="line">   User    string `form:"username" json:"user" uri:"user" xml:"user" binding:"required"`</span><br><span class="line">   Pssword string `form:"password" json:"password" uri:"password" xml:"password" binding:"required"`</span><br><span class="line">}</span><br><span class="line">r := gin.Default()</span><br><span class="line">// JSON绑定</span><br><span class="line">r.POST("loginJSON", func(c *gin.Context) {</span><br><span class="line">// 声明接收的变量</span><br><span class="line">var json Login</span><br><span class="line">// 将request的body中的数据，自动按照json格式解析到结构体</span><br><span class="line">if err := c.ShouldBindJSON(&amp;json); err != nil {</span><br><span class="line">// 返回错误信息</span><br><span class="line">// gin.H封装了生成json数据的工具</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">// 判断用户名密码是否正确</span><br><span class="line">if json.User != "root" || json.Pssword != "admin" {</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H{"status": "304"})</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">c.JSON(http.StatusOK, gin.H{"status": "200"})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>表单数据解析和绑定</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 定义接收数据的结构体</span><br><span class="line">type Login struct {</span><br><span class="line">    // binding:"required"修饰的字段，若接收为空值，则报错，是必须字段</span><br><span class="line">    User    string `form:"username" json:"user" uri:"user" xml:"user" binding:"required"`</span><br><span class="line">    Pssword string `form:"password" json:"password" uri:"password" xml:"password" binding:"required"`</span><br><span class="line">}</span><br><span class="line">r := gin.Default()</span><br><span class="line">// JSON绑定</span><br><span class="line">r.POST("/loginForm", func(c *gin.Context) {</span><br><span class="line">// 声明接收的变量</span><br><span class="line">var form Login</span><br><span class="line">// Bind()默认解析并绑定form格式</span><br><span class="line">// 根据请求头中content-type自动推断</span><br><span class="line">if err := c.Bind(&amp;form); err != nil {</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">// 判断用户名密码是否正确</span><br><span class="line">if form.User != "root" || form.Pssword != "admin" {</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H{"status": "304"})</span><br><span class="line">return</span><br><span class="line">}</span><br><span class="line">c.JSON(http.StatusOK, gin.H{"status": "200"})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>URI数据也是类似的，区别就算用ShouldBindUri这个方法。</p><p>gin实现重定向：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.GET("/index", func(c *gin.Context) {</span><br><span class="line">c.Redirect(http.StatusMovedPermanently, "http://www.5lmh.com")</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>gin做表单验证:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Person struct {</span><br><span class="line">    //不能为空并且大于10</span><br><span class="line">    Age      int       `form:"age" binding:"required,gt=10"`</span><br><span class="line">    Name     string    `form:"name" binding:"required"`</span><br><span class="line">    Birthday time.Time `form:"birthday" time_format:"2006-01-02" time_utc:"1"`</span><br><span class="line">}</span><br><span class="line">r := gin.Default()</span><br><span class="line">    r.GET("/5lmh", func(c *gin.Context) {</span><br><span class="line">        var person Person</span><br><span class="line">        if err := c.ShouldBind(&amp;person); err != nil {</span><br><span class="line">            c.String(500, fmt.Sprint(err))</span><br><span class="line">            return</span><br><span class="line">        }</span><br><span class="line">        c.String(200, fmt.Sprintf("%#v", person))</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure><p>全局中间件，所有的请求都会经过这个中间件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 定义中间</span><br><span class="line">func MiddleWare() gin.HandlerFunc {</span><br><span class="line">    return func(c *gin.Context) {</span><br><span class="line">        t := time.Now()</span><br><span class="line">        fmt.Println("中间件开始执行了")</span><br><span class="line">        // 设置变量到Context的key中，可以通过Get()取</span><br><span class="line">        c.Set("request", "中间件")</span><br><span class="line">        status := c.Writer.Status()</span><br><span class="line">        fmt.Println("中间件执行完毕", status)</span><br><span class="line">        t2 := time.Since(t)</span><br><span class="line">        fmt.Println("time:", t2)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    // 1.创建路由</span><br><span class="line">    // 默认使用了2个中间件Logger(), Recovery()</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    // 注册中间件</span><br><span class="line">    r.Use(MiddleWare())</span><br><span class="line">    // {}为了代码规范</span><br><span class="line">    {</span><br><span class="line">        r.GET("/ce", func(c *gin.Context) {</span><br><span class="line">            // 取值</span><br><span class="line">            req, _ := c.Get("request")</span><br><span class="line">            fmt.Println("request:", req)</span><br><span class="line">            // 页面接收</span><br><span class="line">            c.JSON(200, gin.H{"request": req})</span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    r.Run()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出效果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240109214301262.png" alt="image-20240109214301262"></p><p>局部中间件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">//局部中间键使用</span><br><span class="line">r.GET("/ce", MiddleWare(), func(c *gin.Context) {</span><br><span class="line">// 取值</span><br><span class="line">req, _ := c.Get("request")</span><br><span class="line">fmt.Println("request:", req)</span><br><span class="line">// 页面接收</span><br><span class="line">c.JSON(200, gin.H{"request": req})</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>使用cookie:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">r := gin.Default()</span><br><span class="line">// 服务端要给客户端cookie</span><br><span class="line">r.GET("cookie", func(c *gin.Context) {</span><br><span class="line">// 获取客户端是否携带cookie</span><br><span class="line">cookie, err := c.Cookie("key_cookie")</span><br><span class="line">if err != nil {</span><br><span class="line">cookie = "NotSet"</span><br><span class="line">// 给客户端设置cookie</span><br><span class="line">//  maxAge int, 单位为秒</span><br><span class="line">// path,cookie所在目录</span><br><span class="line">// domain string,域名</span><br><span class="line">//   secure 是否智能通过https访问</span><br><span class="line">// httpOnly bool  是否允许别人通过js获取自己的cookie</span><br><span class="line">c.SetCookie("key_cookie", "value_cookie", 60, "/",</span><br><span class="line">"localhost", false, true)</span><br><span class="line">}</span><br><span class="line">fmt.Printf("cookie的值是： %s\n", cookie)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h2 id="gRPC库"><a href="#gRPC库" class="headerlink" title="gRPC库"></a>gRPC库</h2><p>首先编写proto文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 版本号</span><br><span class="line">syntax = "proto3";</span><br><span class="line"></span><br><span class="line">// 指定包名</span><br><span class="line">package proto;</span><br><span class="line"></span><br><span class="line">// 定义结构体</span><br><span class="line">message UserRequest {</span><br><span class="line">    // 定义用户名</span><br><span class="line">    string name = 1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 响应结构体</span><br><span class="line">message UserResponse {</span><br><span class="line">    int32 id = 1;</span><br><span class="line">    string name = 2;</span><br><span class="line">    int32 age = 3;</span><br><span class="line">    // repeated修饰符是可变数组，go转切片</span><br><span class="line">    repeated string hobby = 4;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// service定义方法</span><br><span class="line">service UserInfoService {</span><br><span class="line">    rpc GetUserInfo (UserRequest) returns (UserResponse) {</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后根据proto生成对应的程序，接着编写服务器端:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">// 1.需要监听</span><br><span class="line">// 2.需要实例化gRPC服务端</span><br><span class="line">// 3.在gRPC商注册微服务</span><br><span class="line">// 4.启动服务端</span><br><span class="line">import (</span><br><span class="line">   "context"</span><br><span class="line">   "fmt"</span><br><span class="line">   pb "/gRPC/proto"  //注意这个路径</span><br><span class="line">   "google.golang.org/grpc"</span><br><span class="line">   "net"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义空接口</span><br><span class="line">type UserInfoService struct{}</span><br><span class="line"></span><br><span class="line">var u = UserInfoService{}</span><br><span class="line"></span><br><span class="line">// 实现方法</span><br><span class="line">func (s *UserInfoService) GetUserInfo(ctx context.Context, req *pb.UserRequest) (resp *pb.UserResponse, err error) {</span><br><span class="line">   // 通过用户名查询用户信息</span><br><span class="line">   name := req.Name</span><br><span class="line">   // 数据里查用户信息</span><br><span class="line">   if name == "zs" {</span><br><span class="line">      resp = &amp;pb.UserResponse{</span><br><span class="line">         Id:    1,</span><br><span class="line">         Name:  name,</span><br><span class="line">         Age:   22,</span><br><span class="line">         Hobby: []string{"Sing", "Run"},</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   return</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">   // 地址</span><br><span class="line">   addr := "127.0.0.1:8080"</span><br><span class="line">   // 1.监听</span><br><span class="line">   listener, err := net.Listen("tcp", addr)</span><br><span class="line">   if err != nil {</span><br><span class="line">      fmt.Printf("监听异常:%s\n", err)</span><br><span class="line">   }</span><br><span class="line">   fmt.Printf("监听端口：%s\n", addr)</span><br><span class="line">   // 2.实例化gRPC</span><br><span class="line">   s := grpc.NewServer()</span><br><span class="line">   // 3.在gRPC上注册微服务</span><br><span class="line">   pb.RegisterUserInfoServiceServer(s, &amp;u)</span><br><span class="line">   // 4.启动服务端</span><br><span class="line">   s.Serve(listener)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后编写一下客户端:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   "context"</span><br><span class="line">   "fmt"</span><br><span class="line">   pb "/gRPC/proto"   //注意这个路径</span><br><span class="line">   "google.golang.org/grpc"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 1.连接服务端</span><br><span class="line">// 2.实例gRPC客户端</span><br><span class="line">// 3.调用</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">   // 1.连接</span><br><span class="line">   conn, err := grpc.Dial("127.0.0.1:8080", grpc.WithInsecure())</span><br><span class="line">   if err != nil {</span><br><span class="line">      fmt.Printf("连接异常： %s\n", err)</span><br><span class="line">   }</span><br><span class="line">   defer conn.Close()</span><br><span class="line">   // 2. 实例化gRPC客户端</span><br><span class="line">   client := pb.NewUserInfoServiceClient(conn)</span><br><span class="line">   // 3.组装请求参数</span><br><span class="line">   req := new(pb.UserRequest)</span><br><span class="line">   req.Name = "zs"</span><br><span class="line">   // 4. 调用接口</span><br><span class="line">   response, err := client.GetUserInfo(context.Background(), req)</span><br><span class="line">   if err != nil {</span><br><span class="line">      fmt.Println("响应异常  %s\n", err)</span><br><span class="line">   }</span><br><span class="line">   fmt.Printf("响应结果： %v\n", response)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Gorm库"><a href="#Gorm库" class="headerlink" title="Gorm库"></a>Gorm库</h2><p>用来和数据库进行通信的库.</p></body></html>]]></content>
      
      
      <categories>
          
          <category> GoLang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go圣经》笔记</title>
      <link href="/2024/01/08/%E3%80%8AGo%E5%9C%A3%E7%BB%8F%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/08/%E3%80%8AGo%E5%9C%A3%E7%BB%8F%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="第一章：入门"><a href="#第一章：入门" class="headerlink" title="第一章：入门"></a>第一章：入门</h1><ul><li>map的迭代顺序是随机的。</li><li>函数和包级变量可以任意顺序声明，并不影响其调用。</li><li>Go语言不需要为switch的每一个case显式的写break</li></ul><h1 id="第二章：程序结构"><a href="#第二章：程序结构" class="headerlink" title="第二章：程序结构"></a>第二章：程序结构</h1><ul><li>在习惯上，Go语言程序员推荐使用 驼峰式 命名，当名字有几个单词组成的时优先使用大小写分隔，而不是优先用下划线分隔。因此，在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但是一般不会用quote rune to ASC和parse request line这样的命名。而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。</li><li>如果初始化表达式被省略，那么将用0值初始化该变量。数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型 (包括slice、指针、map、chan和函数) 变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</li><li>初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。</li><li>请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作。</li><li>对于聚合类型每个成员一比如结构体的每个字段、或者是数组的每个元素也都是对应<br>一个变量，因此可以被取地址。</li><li>在Go语言中，返回函数中局部变量的地址也是安全的。</li><li>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。每次调用new函数都是返回一个新的变量的地址。</li><li>那么Go语言的自动垃圾收集器基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局<br>部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访<br>问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结<br>果。因为一个变量的有效周期只取决于是否可达，因此<strong>一个循环迭代内部的局部变量的生命周期</strong><br><strong>可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</strong>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，这就使得函数内部定义的变量可以 <strong>逃逸</strong>出来，当然这样是消耗内存的。</li><li>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型。</li><li>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化。</li><li>不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域;它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用 ;是一个运行时的概念。</li></ul><h1 id="第三章-基础数据类型"><a href="#第三章-基础数据类型" class="headerlink" title="第三章 基础数据类型"></a>第三章 基础数据类型</h1><ul><li>Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</li></ul><h2 id="3-5-字符串"><a href="#3-5-字符串" class="headerlink" title="3.5 字符串"></a>3.5 字符串</h2><ol><li><p>len函数返回的是字符串中的字节的数目。</p></li><li><p>标准库中有四个包对字符串处理尤为重要: bytes、strings,strconv和unicode包·strings包<br>提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p></li></ol><p><strong>bytes包</strong>也提供了很多类似功能的函数，但是针对和字符串有着相同结构的/byte类型。因为字<br>符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效.<br><strong>strconv包</strong>提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相<br>   关的转换。</p><p><strong>unicode包</strong>提供了lsDigit、IsLetter、IsUpper和lsLower等类似功能，它们用于给字符分类。每<br>个函数有一个单一的rune类型的参数，然后返回一个布尔值·而像ToUpper和ToLower之类的<br>转换函数将用于rune字符的大小写转换·所有的这些函数都是遵循Unicode标准定义的字母、数字等规范。</p><p><strong>Strings包</strong>提供了例如Count、Index等函数。</p><h2 id="3-6-常量"><a href="#3-6-常量" class="headerlink" title="3.6 常量"></a>3.6 常量</h2><ol><li>Go语言的常量大多没有明确的基础类型，编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算;你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</li></ol><h1 id="第四章-复合数据类型"><a href="#第四章-复合数据类型" class="headerlink" title="第四章 复合数据类型"></a>第四章 复合数据类型</h1><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成<br>因为数组的长度是固定的，因此在GO语言中很少直接使用数组。和数组对应的类型是<br>Slice(切片)，它是可以增长和收缩动态序列，slice功能也更灵活。</p><h2 id="4-2-Slice切片"><a href="#4-2-Slice切片" class="headerlink" title="4.2 Slice切片"></a>4.2 Slice切片</h2><ol><li>slice底层确实是引用的一个数组，slice由指针，容量，长度三部分组成。</li><li>字符串的切片操作和[byte字节类型切片的切片操作是类似的。都写作x[m:n]，并且都<br>是返回一个原始字节系列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。</li><li>和数组不同的是，slice之间不能比较，不过可以通过bytes.Equal来判断两个字节型的切片是否相等，但对于其他类型的slice就必须自己展开一个个判断了。</li><li>零值的slice等于nil，nil值的slice并没有底层数组。1个nil值的slice的长度和容量都<br>是0，但是也有非nil值的slice的长度和容量也是0的，例如inh或make(int, 3)[3:]。</li><li>如果你需要测试一个slice是否是空的，使用len(s)== 0来判断，而不应该用s == nil来判断。</li><li>内置的append可以直接追加一个slice： <code>x = append(x,x...)</code></li></ol><h2 id="4-3-Map"><a href="#4-3-Map" class="headerlink" title="4.3 Map"></a>4.3 Map</h2><ol><li>Go中的map是一个哈希表的引用。</li><li>内置的make函数可以创建一个map: <code>ages := make(map[string]int)</code>,或者是用map字面值的方式进行创建<code>ages := make(map[string]int){“alice": 31,"charlie":34,}</code></li><li>不可以对map进行取地址的操作，会报错</li></ol><h2 id="4-3-Struct"><a href="#4-3-Struct" class="headerlink" title="4.3 Struct"></a>4.3 Struct</h2><ol><li>结构体成员的输入顺序有重要的意义，比如说在声明时写的是<code>Name,Address string</code>,那么如果交换了Name，Address的顺序就定义了不同的结构体类了。</li><li>名为S的结构体类型不能再有一个名为S的成员，但是可以有*S的成员。</li><li>空结构体写作struct{}，可以用做map的value为这个，然后来模拟set。</li><li>结构体的两种字面值:</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type p Point{ x,y int}</span><br><span class="line">p:= Point{1,2}// way 1，一般用于成员较少的情况下。</span><br><span class="line">p:= Point{</span><br><span class="line">x:1,</span><br><span class="line">y:2,</span><br><span class="line">}// way 2常见</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li>结构体可以作为函数的参数和返回值。如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。如果要在函数内部修改结构体成员的话，用指针传入是必须的 ;因为在GO语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</li><li><strong>如果结构体的每个成员都是能比较的，那么结构体就也是可以比较的。</strong></li><li>结构体嵌入与匿名成员：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type Point struct {</span><br><span class="line">    X, Y int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Circle struct {</span><br><span class="line">    Point</span><br><span class="line">    Radius int</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">type Wheel struct {</span><br><span class="line">    Circle</span><br><span class="line">    Spokes int</span><br><span class="line">}</span><br><span class="line">var w Wheel</span><br><span class="line">w.X = 8            // equivalent to w.Circle.Point.X = 8</span><br><span class="line">w.Y = 8            // equivalent to w.Circle.Point.Y = 8</span><br><span class="line">w.Radius = 5       // equivalent to w.Circle.Radius = 5</span><br><span class="line">w.Spokes = 20</span><br><span class="line">//但是结构体字面值并没有简短表示匿名成员的语法：</span><br><span class="line">w = Wheel{8, 8, 5, 20}                       // compile error: unknown fields</span><br><span class="line">w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields</span><br><span class="line">//正确做法如下：</span><br><span class="line">w = Wheel{Circle{Point{8, 8}, 5}, 20}</span><br><span class="line"></span><br><span class="line">w = Wheel{</span><br><span class="line">    Circle: Circle{</span><br><span class="line">        Point:  Point{X: 8, Y: 8},</span><br><span class="line">        Radius: 5,</span><br><span class="line">    },</span><br><span class="line">    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="4-5-Json"><a href="#4-5-Json" class="headerlink" title="4.5 Json"></a>4.5 Json</h2><ol><li>将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成,Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进.</li><li>json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进。</li><li>结构体成员Tag是和在编译阶段关联到该成员的元信息字符串：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Year  int  `json:"released"`</span><br><span class="line">Color bool `json:"color,omitempty"`//json开头键名对应的值用于控制encoding/json包的编码和解码的行为</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>json.Unmarshal函数可以完成逆解码的操作：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var titles []struct{ Title string }</span><br><span class="line">if err := json.Unmarshal(data, &amp;titles); err != nil {</span><br><span class="line">    log.Fatalf("JSON unmarshaling failed: %s", err)</span><br><span class="line">}</span><br><span class="line">fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"</span><br></pre></td></tr></tbody></table></figure><h1 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h1><ol><li><strong>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</strong></li><li>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。</li><li>Go语言的函数递归，以阶乘为例,大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出,Go语言使用可变栈，栈的大小按需增加（初始时很小）。这使得我们使用递归时不必考虑溢出和安全问题：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func factorial(n int) int {</span><br><span class="line">    // 基本情况：0的阶乘为1</span><br><span class="line">    if n == 0 {</span><br><span class="line">        return 1</span><br><span class="line">    }</span><br><span class="line">    // 递归调用：n的阶乘等于n乘以(n-1)的阶乘</span><br><span class="line">    return n * factorial(n-1)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>Go语言的函数可以有多个返回值，调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量，如果某个不被使用，可以用_来替代。</li><li>如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return：</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountWordsAndImages</span><span class="params">(url <span class="type">string</span>)</span></span> (words, images <span class="type">int</span>, err <span class="type">error</span>) {</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    doc, err := html.Parse(resp.Body)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        err = fmt.Errorf(<span class="string">"parsing HTML: %s"</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    words, images = countWordsAndImages(doc)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>错误处理策略:1）传播错误。2）重试错误。3）输出错误信息并结束程序。4）只需要输出错误信息就足够了，不需要中断程序的运行。5）直接忽略掉错误。</li><li>io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF。</li><li><strong>函数值可以与nil进行比较，而不可以互相进行比较。</strong></li><li>函数值字面量是一种表达式，它的值被称为匿名函数squares的例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中:</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// squares返回一个匿名函数。</span><br><span class="line">// 该匿名函数每次被调用时都会返回下一个数的平方。</span><br><span class="line">func squares() func() int {</span><br><span class="line">    var x int</span><br><span class="line">    return func() int {</span><br><span class="line">        x++</span><br><span class="line">        return x * x</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">func main() {</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) // "1"</span><br><span class="line">    fmt.Println(f()) // "4"</span><br><span class="line">    fmt.Println(f()) // "9"</span><br><span class="line">    fmt.Println(f()) // "16"</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="10"><li>可变参数,在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func sum(vals ...int) int {</span><br><span class="line">  total := 0</span><br><span class="line">  for _, val := range vals {</span><br><span class="line">    total += val</span><br><span class="line">  }</span><br><span class="line">  return total</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol start="11"><li>可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</li><li>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。</li><li>defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。</li><li>在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。</li><li>在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</li></ol><h1 id="第六章-方法"><a href="#第六章-方法" class="headerlink" title="第六章 方法"></a>第六章 方法</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type Point struct{ X, Y float64 } // traditional function func Distance(p, q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p.Y) }</span><br><span class="line"></span><br><span class="line">func (p *Point) ScaleBy(factor float64) {</span><br><span class="line">   p.X *= factor</span><br><span class="line">   p.Y *= factor</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ol><li><p><a href="https://gopl-zh.github.io/ch6/ch6-02.html#621-nil%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E5%90%88%E6%B3%95%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E7%B1%BB%E5%9E%8B">Nil也是一个合法的接收器类型</a>:<code>Value(nil).Get("item")</code></p></li><li><p>对于嵌入结构体，比如B嵌入到了A，那么A可以调用B的方法。</p></li><li><p>方法值和方法表达式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">distanceFromP := p.Distance // 方法值</span><br><span class="line"></span><br><span class="line">fmt.Println(distanceFromP(q)) // "5"</span><br><span class="line"></span><br><span class="line">distance := Point.Distance // 方法表达式</span><br><span class="line"></span><br><span class="line"> fmt.Println(distance(p, q)) // "5"</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。</p></li></ol><h1 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h1><ol><li><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。也就是说一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</p></li><li><p>interface{}空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。</p></li><li><p>接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值.</p></li><li><p><a href="https://gopl-zh.github.io/ch7/ch7-05.html#751--%E8%AD%A6%E5%91%8A%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%ABnil%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AFnil%E6%8E%A5%E5%8F%A3">一个包含nil指针的接口不是nil接口</a>,接口值==nil 的前提是类型和值都没有指定的情况下才成立。</p></li><li><p>每个Errors.New函数的调用都分配了一个独特的和其他错误不相同的实例。</p></li><li><p>类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。这里有两种可能。第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。</p></li><li><p>类型断言的作用：1）查询接口；2）识别错误类型。</p></li><li><p>类型分支：</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch x.(type) {</span><br><span class="line">case nil:       // ...</span><br><span class="line">case int, uint: // ...</span><br><span class="line">case bool:      // ...</span><br><span class="line">case string:    // ...</span><br><span class="line">default:        // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="第八章-Goroutines和Channels"><a href="#第八章-Goroutines和Channels" class="headerlink" title="第八章  Goroutines和Channels"></a>第八章  Goroutines和Channels</h1><ol><li>无缓存Channels有时候也被称为同步Channels。</li><li>试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制。</li><li>带缓存Channels可以解耦接收和发送的channel。</li><li>nil的channel有时候也是有一些用处的。因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。</li></ol><p>关键字：<strong>goroutines泄露</strong></p><h1 id="第9章-基于共享变量的并发"><a href="#第9章-基于共享变量的并发" class="headerlink" title="第9章　基于共享变量的并发"></a>第9章　基于共享变量的并发</h1><ol><li>RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些，所以一般来说受益很小。</li><li>如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。在多线程场景中，可以使用sync.Once来确保一次性初始化：</li></ol><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadIconsOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> icons <span class="keyword">map</span>[<span class="type">string</span>]image.Image</span><br><span class="line"><span class="comment">// Concurrency-safe.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Icon</span><span class="params">(name <span class="type">string</span>)</span></span> image.Image {</span><br><span class="line">    loadIconsOnce.Do(loadIcons)</span><br><span class="line">    <span class="keyword">return</span> icons[name]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>竞争检查器（the race detector）</strong>。只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。</li><li>一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。</li><li><strong>goroutine没有可以被程序员获取到的身份（id）的概念。</strong></li></ol><h1 id="第11章-测试"><a href="#第11章-测试" class="headerlink" title="第11章　测试"></a>第11章　测试</h1><p>第十章没太多内容，就跳过了。。</p><ol><li><p><strong>在包目录内，所有以<code>_test.go</code>为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。</strong></p></li><li><p>在<code>*_test.go</code>文件中，有三种类型的函数：测试函数、基准测试（benchmark）函数、示例函数。</p></li><li><p>一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。</p></li><li><p>基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。</p></li><li><p>示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。</p></li></ol><p>OK，Done，弄了很久了，一直懒得弄。。 最后两章有点进阶了，暂时略掉了。</p><h1 id="经典场景示例"><a href="#经典场景示例" class="headerlink" title="经典场景示例"></a>经典场景示例</h1><p>5.6.1 关键字：<strong>匿名函数中的循环变量快照问题</strong></p><p>8.4.4. 带缓存的Channels</p><p>关键字：<strong>goroutines泄露</strong></p><p>无缓存的channel保证了每个发送操作与相应的同步接收操作；对于带缓存channel在，和谐操作是解耦的。</p><p> 8.8 示例：并发的字典遍历</p><p>关键字：<strong>标签break</strong></p><h1 id="圣经圣语"><a href="#圣经圣语" class="headerlink" title="圣经圣语"></a>圣经圣语</h1><ul><li>对并发的直觉总是不能被信任的。</li><li>约97%的场景：过早的优化是万恶之源。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Go语言精进之路》笔记</title>
      <link href="/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="2-1-Go语言的先祖"><a href="#2-1-Go语言的先祖" class="headerlink" title="2.1 Go语言的先祖"></a>2.1 Go语言的先祖</h4><p>Go的基本语法参考了C语言，Go是“C家族语言”的一个分支；而Go的声明语法、包概念则受到了Pascal、Modula、Oberon的启发；一些并发的思想则来自受到Tony Hoare教授CSP理论[1]影响的编程语言，比如Newsqueak和Limbo。</p><h1 id="第3条-Go语言设计哲学"><a href="#第3条-Go语言设计哲学" class="headerlink" title="第3条 Go语言设计哲学"></a>第3条 Go语言设计哲学</h1><ul><li>==追求简单，少即是多==：Go设计者推崇“最小方式”思维，即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担。</li><li>==偏好组合，正交解耦==：在通过新类型实例调用方法时，方法的匹配取决于方法名字，而不是类型。这种组合方式，笔者称之为“垂直组合”，即通过类型嵌入，快速让一个新类型复用其他类型已经实现的能力，实现功能的垂直扩展。通过interface将程序各个部分组合在一起的方法，笔者称之为“水平组合”。</li><li>==原生并发，轻量高效==：Go语言采用轻量级协程并发模型，使得Go应用在面向多核硬件时更具可扩展性，goroutine占用的资源非常少，Go运行时默认为每个goroutine分配的栈空间仅2KB。goroutine调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。一个Go程序对于操作系统来说只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠Go自己完成，实现Go程序内goroutine之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些goroutine按照一定算法放到CPU上执行的程序就称为goroutine调度器（goroutine scheduler）。并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的。</li><li>==面向工程，“自带电池“==，自带电池，主要是指Go的标准库非常的丰富：<ul><li>构建和运行：go build/go run</li><li>依赖包查看与获取：go list/go get/go mod xx</li><li>编辑辅助格式化：go fmt/gofmt</li><li>文档查看：go doc/godoc</li><li>单元测试/基准测试/测试覆盖率：go test</li><li>代码静态分析：go vet</li><li>性能剖析与跟踪结果查看：go tool pprof/go tool trace</li><li>升级到新Go版本API的辅助工具：go tool fix</li><li>报告Go语言bug：go bug</li></ul></li><li>简单是Go语言贯穿语言设计和应用的主旨设计哲学。“高内聚、低耦合”是软件开发领域亘古不变的管理复杂性的准则。</li></ul><h1 id="第4条-使用Go语言原生编程思维来写Go代码"><a href="#第4条-使用Go语言原生编程思维来写Go代码" class="headerlink" title="第4条　使用Go语言原生编程思维来写Go代码"></a>第4条　使用Go语言原生编程思维来写Go代码</h1><ul><li>C语言相信程序员，提供了指针和指针运算，让C程序员天马行空地发挥，接近底层的直接内存操作让C程序拥有很高的性能；C++支持多范式（命令式、OO和泛型），虽不强迫程序员使用某个特定的范式，但推荐使用最新代表现代语言发展特色的泛型等高级范式；Python语言更是形成了Pythonic规则来指导Python程序员写出符合Python思维或惯用法的代码。</li></ul><h1 id="第5条-使用得到公认且广泛使用的项目结构"><a href="#第5条-使用得到公认且广泛使用的项目结构" class="headerlink" title="第5条　使用得到公认且广泛使用的项目结构"></a>第5条　使用得到公认且广泛使用的项目结构</h1><p>1）代码构建的脚本源文件放在src下面的顶层目录下。</p><p>2）src下的二级目录cmd下面存放着Go工具链相关的可执行文件（比如go、gofmt等）的主目录以及它们的main包源文件。</p><p>3）src下的二级目录pkg下面存放着上面cmd下各工具链程序依赖的包、Go运行时以及Go标准库的源文件。</p><h1 id="第6条-提交前使用gofmt格式化源码"><a href="#第6条-提交前使用gofmt格式化源码" class="headerlink" title="第6条　提交前使用gofmt格式化源码"></a>第6条　提交前使用gofmt格式化源码</h1><ol><li><p>使用gofmt -s选项简化代码</p></li><li><p>使用gofmt -r执行代码“微重构”</p></li></ol><p>下面是-r选项的用法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gofmt -r 'pattern -&gt; replacement' [other flags] [path ...]</span><br><span class="line">$gofmt -r 'a[3:len(a)] -&gt; a[3:]' -w chapter2/sources/gofmt_demo.go</span><br><span class="line">//上面gofmt -r命令执行的意图就是先将源码文件gofmt_demo.go中能与a[3:len(a)]匹配的代码替换为a[3:]，然后重新格式化。</span><br></pre></td></tr></tbody></table></figure><p>使用gofmt -l按格式要求输出满足条件的文件列表。</p><h3 id="第7条-使用Go命名惯例对标识符进行命名"><a href="#第7条-使用Go命名惯例对标识符进行命名" class="headerlink" title="第7条 使用Go命名惯例对标识符进行命名"></a>第7条 使用Go命名惯例对标识符进行命名</h3><ul><li>计算机科学中只有两件难事：缓存失效和命名。一个好笑话，如果你必须解释它，那就不好笑了。好的命名也类似。要想做好Go标识符的命名（包括对包的命名），至少要遵循两个原则：<strong>简单且一致；利用上下文辅助命名。</strong></li><li>对于Go中的包（package），一般建议以小写形式的单个单词命名。</li><li>包名应尽量与包导入路径（import path）的最后一个路径分段保持一致。</li><li><strong>Go语言官方要求标识符命名采用驼峰命名法</strong>（CamelCase），以变量名为例，如果变量名由一个以上的词组合构成，那么这些词之间紧密相连，不使用任何连接符（如下划线）。驼峰命名法有两种形式：一种是第一个词的首字母小写，后面每个词的首字母大写，叫作“小骆峰拼写法”（lowerCamelCase），这也是在Go中最常见的标识符命名法；而第一个词的首字母以及后面每个词的首字母都大写，叫作“大驼峰拼写法”（UpperCamelCase），又称“帕斯卡拼写法”（PascalCase）。由于首字母大写的标识符在Go语言中被视作包导出标识符，因此<strong>只有在涉及包导出的情况下才会用到大驼峰拼写法</strong>。不过如果缩略词的首字母是大写的，那么其他字母也要保持全部大写，比如HTTP（Hypertext Transfer Protocol）、CBC（Cipher Block Chaining）等。</li><li>带有类型信息的命名只是让变量看起来更长，并没有给开发者阅读代码带来任何好处。</li><li>保持变量声明与使用之间的距离越近越好，或者在第一次使用变量之前声明该变量。</li><li>在Go语言中，对于接口类型优先以单个单词命名。<strong>对于拥有唯一方法（method）或通过多个拥有唯一方法的接口组合而成的接口，Go语言的惯例是用“方法名+er”命名</strong>。</li></ul><h3 id="第8条-使用一致的变量声明形式"><a href="#第8条-使用一致的变量声明形式" class="headerlink" title="第8条 使用一致的变量声明形式"></a>第8条 使用一致的变量声明形式</h3><ul><li><p>Go语言沿袭了静态编译型语言的传统：使用变量之前需要先进行变量的声明</p></li><li><p>Go语言有两类变量。包级变量（package variable）：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。局部变量（local variable）：函数或方法体内声明的变量，仅在函数或方法体内可见。</p></li></ul><h4 id="8-1-包级变量的声明形式"><a href="#8-1-包级变量的声明形式" class="headerlink" title="8.1 包级变量的声明形式"></a>8.1 包级变量的声明形式</h4><ul><li><p>我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中；或者将延迟初始化的变量声明放在一个var块，而将声明并显式初始化的变量放在另一个var块中。笔者称之为“声明聚类”</p></li><li><p>变量声明最佳实践中还有一条：<strong>就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。</strong>就近原则实际上是变量的作用域最小化的一种实现手段。</p></li></ul><h4 id="8-2-局部变量的声明形式"><a href="#8-2-局部变量的声明形式" class="headerlink" title="8.2 局部变量的声明形式"></a>8.2 局部变量的声明形式</h4><ol><li><p>对于延迟初始化的局部变量声明，采用带有var关键字的声明形式</p></li><li><p>对于声明且显式初始化的局部变量，建议使用短变量声明形式</p></li><li><p>尽量在分支控制时应用短变量声明形式</p></li></ol><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_21" alt="img"></p><h1 id="第9条-使用无类型常量简化代码"><a href="#第9条-使用无类型常量简化代码" class="headerlink" title="第9条　使用无类型常量简化代码"></a>第9条　使用无类型常量简化代码</h1><ul><li>Go语言中的const整合了C语言中宏定义常量、const只读变量和枚举常量三种形式，并消除了每种形式的不足，使得Go常量成为类型安全且对编译器优化友好的语法元素。</li><li>有类型常量带来的烦恼：Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算，Go在处理不同类型的变量间的运算时不支持隐式的类型转换。Go的设计者认为，隐式转换带来的便利性不足以抵消其带来的诸多问题</li><li>Go的无类型常量恰恰就拥有像字面值这样的特性，该特性使得无类型常量在参与变量赋值和计算过程时无须显式类型转换，从而达到简化代码的目的</li><li>无类型常量是Go语言推荐的实践，它拥有和字面值一样的灵活特性，可以直接用于更多的表达式而不需要进行显式类型转换，从而简化了代码编写。</li></ul><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a  = <span class="number">5</span></span><br><span class="line">    pi = <span class="number">3.1415926</span></span><br><span class="line">    s  = <span class="string">"Hello, Gopher"</span></span><br><span class="line">    c  = <span class="string">'a'</span></span><br><span class="line">    b  = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="第10条-使用iota实现枚举常量"><a href="#第10条-使用iota实现枚举常量" class="headerlink" title="第10条 使用iota实现枚举常量"></a>第10条 使用iota实现枚举常量</h3><p>Go的const语法提供了“隐式重复前一个非空表达式”的机制</p><h1 id="第11条-尽量定义零值可用的类型"><a href="#第11条-尽量定义零值可用的类型" class="headerlink" title="第11条　尽量定义零值可用的类型"></a>第11条　尽量定义零值可用的类型</h1><ul><li><p>当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，<strong>Go会为变量或值提供默认值</strong>。</p></li><li><p>Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）:</p><ul><li>所有整型类型：0</li><li>浮点类型：0.0</li><li>布尔类型：false</li><li>字符串类型：””</li><li>指针、interface、切片（slice）、channel、map、function：nil</li></ul></li><li><p>Go的零值初始是递归的，<strong>即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</strong></p></li></ul><h4 id="11-2-零值可用"><a href="#11-2-零值可用" class="headerlink" title="11.2 零值可用"></a>11.2 零值可用</h4><p>==两个例子：1.零值的切片可以直接append；2.零值仍可以调用自身的方法；==</p><p><strong>零值可用的类型要注意尽量避免值复制</strong></p><h1 id="第12条-使用复合字面值作为初值构造器"><a href="#第12条-使用复合字面值作为初值构造器" class="headerlink" title="第12条 使用复合字面值作为初值构造器"></a>第12条 使用复合字面值作为初值构造器</h1><p>复合字面值由两部分组成：一部分是类型，比如上述示例代码中赋值操作符右侧的myStruct、[5]int、[]int和map[int]string；另一部分是由大括号{}包裹的字面值。</p><ul><li><p>结构体复合字面值:Go推荐使用field:value的复合字面值形式对struct类型变量进行值构造，这种值构造方式可以降低结构体类型使用者与结构体类型设计者之间的耦合，这也是Go语言的惯用法。</p></li><li><p>数组/切片复合字面值：数组/切片由于其固有的特性，采用index:value为其构造初值，主要应用在少数场合，比如为非连续（稀疏）元素构造初值</p></li><li><p>map复合字面值:对于数组/切片类型而言，当元素为复合类型时，可以省去元素复合字面量中的类型。</p></li></ul><p>总结：对于不同复合类型，我们要记住下面几点：使用field:value形式的复合字面值为结构体类型的变量赋初值；在为稀疏元素赋值或让编译器推导数组大小的时候，多使用index:value的形式为数组/切片类型变量赋初值；使用key:value形式的复合字面值为map类型的变量赋初值。（Go 1.5版本后，复合字面值中的key和value类型均可以省略不写。）</p><h1 id="第13条-了解切片实现原理并高效使用"><a href="#第13条-了解切片实现原理并高效使用" class="headerlink" title="第13条 了解切片实现原理并高效使用"></a>第13条 了解切片实现原理并高效使用</h1><ul><li><strong>在Go语言中传递数组是纯粹的值拷贝</strong>，对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗。<strong>切片之于数组就像是文件描述符之于文件。</strong>在Go语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色；而切片则走向“前台”，为底层的存储（数组）打开了一个访问的“窗口”。</li><li>我们可以称切片是数组的“描述符”</li><li>我们可以通过语法u[low: high]创建对已存在数组进行操作的切片，这被称为数组的切片化（slicing）：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u := [10]byte{11, 12, 13, 14, 15, 16, 17, 18, 19, 20}</span><br><span class="line">s := u[3:7]</span><br></pre></td></tr></tbody></table></figure><ul><li>**切片的高级特性,动态扩容:**新数组建立后，append会把旧数组中的数据复制到新数组中，之后新数组便成为切片的底层数组，旧数组后续会被垃圾回收掉。</li></ul><h1 id="第14条-了解map实现原理并高效使用"><a href="#第14条-了解map实现原理并高效使用" class="headerlink" title="第14条　了解map实现原理并高效使用"></a>第14条　了解map实现原理并高效使用</h1><ul><li>map对value的类型没有限制，但是对key的类型有严格要求：<strong>key的类型应该严格定义了作为“==”和“!=”两个操作符的操作数时的行为</strong>，因此函数、map、切片不能作为map的key类型。</li><li><strong>map类型不支持“零值可用”</strong>，未显式赋初值的map类型变量的零值为nil。对处于零值状态的map变量进行操作将会导致运行时panic,必须对map类型变量进行显式初始化后才能使用它。</li><li><strong>和切片一样，map也是引用类型，将map类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对map变量的修改在函数外部也是可见的。</strong></li><li>Go语言的一个最佳实践是总是使用“comma ok”惯用法读取map中的值。</li><li>即便要删除的数据在map中不存在，delete也不会导致panic。这是因为Go运行时在初始化map迭代器时对起始位置做了随机处理。</li><li>千万不要依赖遍历map所得到的元素次序。因为map的遍历是乱序的，可以通过向数组中存放key的方式然后遍历数组来得到有序的遍历结果。</li><li>1.9版本中引入了支持并发写安全的sync.Map类型，可以用来在并发读写的场景下替换掉map。</li><li>考虑到map可以自动扩容，map中数据元素的value位置可能在这一过程中发生变化，因此Go不允许获取map中value的地址</li></ul><p><strong>小结：</strong>不要依赖map的元素遍历顺序；map不是线程安全的，不支持并发写；不要尝试获取map中元素（value）的地址；尽量使用cap参数创建map，以提升map平均访问性能，减少频繁扩容带来的不必要损耗。</p><h1 id="第15条-了解string实现原理并高效使用"><a href="#第15条-了解string实现原理并高效使用" class="headerlink" title="第15条　了解string实现原理并高效使用"></a>第15条　了解string实现原理并高效使用</h1><ul><li><p><strong>（1）string类型的数据是不可变的：一旦声明了一个string类型的标识符，无论是常量还是变量，该标识符所指代的数据在整个程序的生命周期内便无法更改。</strong></p></li><li><p><strong>（2）零值可用：Go string类型支持“零值可用”的理念。Go字符串无须像C语言中那样考虑结尾’\0’字符，因此其零值为””，长度为0。</strong></p></li><li><p><strong>（3）获取长度的时间复杂度是O(1)级别。</strong></p></li><li><p><strong>（4）支持通过+/+=操作符进行字符串连接。</strong></p></li><li><p><strong>（5）支持各种比较关系操作符：==、!= 、&gt;=、&lt;=、&gt;和&lt;。</strong>如果长度相同，则要进一步判断数据指针是否指向同一块底层存储数据。如果相同，则两个字符串是等价的；如果不同，则还需进一步比对实际的数据内容。</p></li><li><p><strong>（6）对非ASCII字符提供原生支持。</strong></p></li><li><p><strong>（7）原生支持多行字符串。</strong>Go语言直接提供了通过反引号构造“所见即所得”的多行字符串的方法：</p></li></ul> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// chapter3/sources/string_multilines.go</span><br><span class="line"></span><br><span class="line">const s = `好雨知时节，当春乃发生。</span><br><span class="line">随风潜入夜，润物细无声。</span><br><span class="line">野径云俱黑，江船火独明。</span><br><span class="line">晓看红湿处，花重锦官城。`</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">$go run string_multilines.go</span><br><span class="line">好雨知时节，当春乃发生。</span><br><span class="line">随风潜入夜，润物细无声。</span><br><span class="line">野径云俱黑，江船火独明。</span><br><span class="line">晓看红湿处，花重锦官城。</span><br></pre></td></tr></tbody></table></figure><ul><li>直接将string类型通过函数/方法参数传入也不会有太多的损耗，因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</li><li>字符串相关的高效转换:无论是string转slice还是slice转string，转换都是要付出代价的，这些代价的根源在于string是不可变的，运行时要为转换后的类型分配新内存.</li><li>Go编译器对用在for-range循环中的string到[]byte的转换也有优化处理，它不会为[]byte进行额外的内存分配，而是直接使用string的底层数据。</li></ul><h1 id="第16条-理解Go语言的包导入"><a href="#第16条-理解Go语言的包导入" class="headerlink" title="第16条　理解Go语言的包导入"></a>第16条　理解Go语言的包导入</h1><ul><li>Go程序的构建简单来讲也是由编译（compile）和链接（link）两个阶段组成的。</li><li>在使用第三方包的时候，在第三方包源码存在且对应的.a已安装的情况下，编译器链接的仍是根据第三方包最新源码编译出的.a文件，而不是之前已经安装到$GOPATH/pkg/darwin_amd64下的目标文件。</li><li>所谓的使用第三方包源码，实际上是链接了以该最新包源码编译的、存放在临时目录下的包的.a文件而已。</li><li>源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段也不是包名。</li><li>包导入路径的最后一段目录名最好与包名一致,当包名与包导入路径中的最后一个目录名不同时，最好用下面的语法将包名显式放入包导入语句</li></ul><h1 id="第17条-理解Go语言表达式的求值顺序"><a href="#第17条-理解Go语言表达式的求值顺序" class="headerlink" title="第17条 理解Go语言表达式的求值顺序"></a>第17条 理解Go语言表达式的求值顺序</h1><ul><li><p>支持在同一行声明和初始化多个变量（不同类型也可以）</p></li><li><p>在Go包中，<strong>包级别变量的初始化按照变量声明的先后顺序进行</strong>。</p></li><li><p>未初始化的且不含有对应初始化表达式或初始化表达式不依赖任何未初始化变量的变量，我们称之为“ready for initialization”变量。包级别变量的初始化是逐步进行的，每一步就是按照变量声明顺序找到下一个“ready for initialization”变量并对其进行初始化的过程。反复重复这一步骤，直到没有“ready for initialization”变量为止。</p></li><li><p>当多个变量在声明语句左侧且右侧为单一表达式时的表达式求值情况。在这种情况下，无论左侧哪个变量被初始化，同一行的其他变量也会被一并初始化。</p></li><li><p><strong>switch-case语句中的表达式求值，这类求值属于“惰性求值”范畴。</strong>惰性求值指的就是需要进行求值时才会对表达值进行求值，这样做的目的是让计算机少做事，从而降低程序的消耗，对性能提升有一定帮助。</p></li></ul><p><strong>小结：</strong>包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高。表达式操作数中的函数、方法及channel操作按普通求值顺序，即从左到右的次序进行求值。赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按从左到右的顺序对变量进行赋值。重点关注switch-case和select-case语句中的表达式“惰性求值”规则。</p><h1 id="第18条-理解Go语言代码块与作用域"><a href="#第18条-理解Go语言代码块与作用域" class="headerlink" title="第18条　理解Go语言代码块与作用域"></a>第18条　理解Go语言代码块与作用域</h1><h4 id="18-1-Go代码块与作用域简介"><a href="#18-1-Go代码块与作用域简介" class="headerlink" title="18.1 Go代码块与作用域简介"></a>18.1 Go代码块与作用域简介</h4><ul><li>代码块是代码执行流流转的基本单元，代码执行流总是从一个代码块跳到另一个代码块。</li><li><strong>Go规范定义了如下几种隐式代码块</strong>。<strong>宇宙（Universe）代码块</strong>：所有Go源码都在该隐式代码块中，就相当于所有Go代码的最外层都存在一对大括号。<strong>包代码块</strong>：每个包都有一个包代码块，其中放置着该包的所有Go源码。<strong>文件代码块</strong>：每个文件都有一个文件代码块，其中包含着该文件中的所有Go源码。</li><li>每个if、for和switch语句均被视为位于其自己的隐式代码块中；switch或select语句中的每个子句都被视为一个隐式代码块。</li></ul><h1 id="第19条-了解Go语言控制语句惯用法及使用注意事项"><a href="#第19条-了解Go语言控制语句惯用法及使用注意事项" class="headerlink" title="第19条　了解Go语言控制语句惯用法及使用注意事项"></a>第19条　了解Go语言控制语句惯用法及使用注意事项</h1><ul><li>使用if控制语句时应遵循“快乐路径”原则，所谓“快乐路径”即成功逻辑的代码执行路径，这个原则要求：当出现错误时，快速返回；成功逻辑不要嵌入if-else语句中；“快乐路径”的执行逻辑在代码布局上始终靠左，这样读者可以一眼看到该函数的正常逻辑流程；“快乐路径”的返回值一般在函数最后一行，就像上面伪代码段1中的那样。</li></ul><h4 id="19-2-for-range的避“坑”指南（重要）"><a href="#19-2-for-range的避“坑”指南（重要）" class="headerlink" title="19.2 for range的避“坑”指南（重要）"></a>19.2 for range的避“坑”指南（重要）</h4><ul><li><strong>参与循环的是range表达式的副本。</strong></li><li><strong>切片与数组还有一个不同点，就是其len在运行时可以被改变，而数组的长度可认为是一个常量，不可改变。</strong></li><li>range表达式的类型为切片或数组指针的性能相近，消耗都接近数组类型的1/2。</li><li><strong>对于range后面的其他表达式类型，比如string、map和channel，for range依旧会制作副本。</strong></li><li>如果在循环体中新创建一个map元素项，那么该项元素可能出现在后续循环中，也可能不出现：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// chapter3/sources/control_structure_idiom_4.go</span><br><span class="line">m["tony"] = 21</span><br><span class="line">counter = 0</span><br><span class="line"></span><br><span class="line">for k, v := range m {</span><br><span class="line">    if counter == 0 {</span><br><span class="line">        m["lucy"] = 24</span><br><span class="line">    }</span><br><span class="line">    counter++</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br><span class="line">fmt.Println("counter is ", counter)</span><br><span class="line"></span><br><span class="line">//执行结果</span><br><span class="line">tony 21</span><br><span class="line">tom 22</span><br><span class="line">jim 23</span><br><span class="line">lucy 24</span><br><span class="line">counter is  4</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">tony 21</span><br><span class="line">tom 22</span><br><span class="line">jim 23</span><br><span class="line">counter is  3</span><br></pre></td></tr></tbody></table></figure><ul><li>当channel作为range表达式类型时，for range最终以阻塞读的方式阻塞在channel表达式上，即便是带缓冲的channel亦是如此：当channel中无数据时，for range也会阻塞在channel上，直到channel关闭</li><li>Go语言规范中明确规定break语句（不接label的情况下）结束执行并跳出的是同一函数内break语句所在的最内层的for、switch或select的执行。Go语言为for提供的一项高级能力：break [label]</li><li>尽量用case表达式列表替代fallthrough</li></ul><p><strong>小结：</strong>使用if语句时遵循“快乐路径”原则；小心for range的循环变量重用，明确真实参与循环的是range表达式的副本；明确break和continue执行后的真实“目的地”；使用fallthrough关键字前，考虑能否用更简洁、清晰的case表达式列表替代。</p><h1 id="第20条-在init函数中检查包级变量的初始状态"><a href="#第20条-在init函数中检查包级变量的初始状态" class="headerlink" title="第20条　在init函数中检查包级变量的初始状态"></a>第20条　在init函数中检查包级变量的初始状态</h1><ul><li>一个Go包可以拥有多个init函数，每个组成Go包的Go源文件中可以定义多个init函数。</li><li>一般来说，先被传递给Go编译器的源文件中的init函数先被执行，同一个源文件中的多个init函数按声明顺序依次执行。但Go语言的惯例告诉我们：不要依赖init函数的执行次序。</li><li><strong>init函数的执行顺位排在其所在包的包级变量之后。</strong></li><li>使用init函数检查包级变量的初始状态：1). 重置包级变量值。2).对包级变量进行初始化，保证其后续可用。3).init函数中的注册模式。</li><li><strong>空别名方式导入lib/pq的副作用就是Go运行时会将lib/pq作为main包的依赖包并会初始化pq包，于是pq包的init函数得以执行。</strong></li><li>一旦init函数在检查包数据初始状态时遇到失败或错误的情况（尽管极少出现），则说明对包的“质检”亮了红灯，如果让包“出厂”，那么只会导致更为严重的影响。因此，在这种情况下，快速失败是最佳选择。我们一般建议直接调用panic或者通过log.Fatal等函数记录异常日志，然后让程序快速退出。</li></ul><h3 id="第21条-让自己习惯于函数是“一等公民”"><a href="#第21条-让自己习惯于函数是“一等公民”" class="headerlink" title="第21条 让自己习惯于函数是“一等公民”"></a>第21条 让自己习惯于函数是“一等公民”</h3><p>Go语言的函数具有如下特点：以func关键字开头；支持多返回值；支持具名返回值；支持递归调用；支持同类型的可变参数；支持defer，实现函数优雅返回。</p><h4 id="21-1-什么是“一等公民”"><a href="#21-1-什么是“一等公民”" class="headerlink" title="21.1 什么是“一等公民”"></a>21.1 什么是“一等公民”</h4><p>如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”，Go中的函数可以像普通整型值那样被创建和使用。</p><h4 id="21-2-函数作为“一等公民”的特殊运用"><a href="#21-2-函数作为“一等公民”的特殊运用" class="headerlink" title="21.2 函数作为“一等公民”的特殊运用"></a>21.2 函数作为“一等公民”的特殊运用</h4><ol><li>像对整型变量那样对函数进行显式类型转换。函数也可以被显式类型转换，并且这样的类型转换在特定的领域具有奇妙的作用。最为典型的示例就是http.HandlerFunc这个类型。</li><li>函数式编程：<ol><li>柯里化是把接受多个参数的函数变换成接受一个单一参数（原函数的第一个参数）的函数，并返回接受余下的参数和返回结果的新函数的技术。</li><li>闭包是在函数内部定义的匿名函数，并且允许该匿名函数访问定义它的外部函数的作用域。</li><li>函子需要满足两个条件：函子本身是一个容器类型，以Go语言为例，这个容器可以是切片、map甚至channel；该容器类型需要实现一个方法，该方法接受一个函数类型参数，并在容器的每个元素上应用那个函数，得到一个新函子，原函子容器内部的元素值不受影响。</li></ol></li></ol><p><strong>小结：</strong>让自己习惯于函数是“一等公民”，请牢记本条要点：Go函数可以像变量值那样被赋值给变量、作为参数传递、作为返回值返回和在函数内部创建等；函数可以像变量那样被显式类型转换；基于函数特质，了解Go中的几种有用的函数式编程风格，如柯里化、函子等；不要为了符合特定风格而滥用函数特质。</p><h1 id="第22条-使用defer让函数更简洁、更健壮"><a href="#第22条-使用defer让函数更简洁、更健壮" class="headerlink" title="第22条　使用defer让函数更简洁、更健壮"></a>第22条　使用defer让函数更简洁、更健壮</h1><p>在Go中，只有在函数和方法内部才能使用defer；defer关键字后面只能接函数或方法，这些函数被称为deferred函数。defer将它们注册到其所在goroutine用于存放deferred函数的栈数据结构中，这些<strong>deferred函数将在执行defer的函数退出前被按后进先出（LIFO）的顺序调度执行。</strong></p><ul><li>defer的常见用法：<ul><li>拦截panic：deferred函数虽然可以拦截绝大部分的panic，但无法拦截并恢复一些运行时之外的致命问题。比如下面代码中通过C代码“制造”的崩溃，deferred函数便无能为力。</li><li>修改函数的具名返回值</li><li>输出调试信息</li><li>还原变量旧值</li></ul></li></ul><h4 id="22-3-关于defer的几个关键问题"><a href="#22-3-关于defer的几个关键问题" class="headerlink" title="22.3 关于defer的几个关键问题"></a>22.3 关于defer的几个关键问题</h4><ol><li>明确哪些函数可以作为deferred函数对于自定义的函数或方法，defer可以给予无条件的支持，但是<strong>对于有返回值的自定义函数或方法，返回值会在deferred函数被调度执行的时候被自动丢弃。</strong></li><li>append、cap、len、make、new等内置函数是不可以直接作为deferred函数的，而close、copy、delete、print、recover等可以。对于那些不能直接作为deferred函数的内置函数，我们可以使用一个包裹它的匿名函数来间接满足要求。以append为例：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer func() {</span><br><span class="line">    _ = append(sl, 11)</span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>把握好defer关键字后表达式的求值时机,defer关键字后面的表达式是在将deferred函数注册到deferred函数栈的时候进行求值的</li><li>==从Go1.14开始，带来的性能负担不太多了。==</li></ol><h3 id="第23条-理解方法的本质以选择正确的receiver类型"><a href="#第23条-理解方法的本质以选择正确的receiver类型" class="headerlink" title="第23条 理解方法的本质以选择正确的receiver类型"></a>第23条 理解方法的本质以选择正确的receiver类型</h3><ul><li><p>和函数相比，Go语言中的方法在声明形式上仅仅多了一个参数，Go称之为receiver参数。receiver参数是方法与类型之间的纽带。</p></li><li><p>Go方法具有如下特点。</p><ul><li>1）方法名的首字母是否大写决定了该方法是不是导出方法。</li><li>2）方法定义要与类型定义放在同一个包内。由此我们可以推出：<strong>不能为原生类型（如int、float64、map等）添加方法，只能为自定义类型定义方法,不能横跨Go包为其他包内的自定义类型定义方法。</strong></li><li>3）每个方法只能有一个receiver参数，不支持多receiver参数列表或变长receiver参数。一个方法只能绑定一个基类型，Go语言不支持同时绑定多个类型的方法。</li><li>4）receiver参数的基类型本身不能是指针类型或接口类型</li></ul></li><li><p>Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。这种直接以类型名T调用方法的表达方式被称为方法表达式（Method Expression）。类型T只能调用T的方法集合（Method Set）中的方法，同理，<code>*T只能调用*T</code>的方法集合中的方法。</p></li><li><p>receiver类型选用的初步结论。如果要对类型实例进行修改，那么为receiver选择<code>*T</code>类型。如果没有对类型实例修改的需求，那么为receiver选择T类型或<em>T类型均可；但考虑到Go方法调用时，receiver是以值复制的形式传入方法中的，如果类型的size较大，以值形式传入会导致较大损耗，这时选择</em>T作为receiver类型会更好些。关于receiver类型的选择其实还有一个重要因素，那就是类型是否要实现某个接口</p></li></ul><p><strong>小结：</strong>Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。Go语法糖使得我们在通过类型实例调用类型方法时无须考虑实例类型与receiver参数类型是否一致，编译器会为我们做自动转换。在选择receiver参数类型时要看是否要对类型实例进行修改。如有修改需求，则选择*T；如无修改需求，T类型receiver传值的性能损耗也是考量因素之一。</p><h1 id="第24条-方法集合决定接口实现"><a href="#第24条-方法集合决定接口实现" class="headerlink" title="第24条　方法集合决定接口实现"></a>第24条　方法集合决定接口实现</h1><h4 id="24-1-方法集合"><a href="#24-1-方法集合" class="headerlink" title="24.1 方法集合"></a>24.1 方法集合</h4><ul><li><p>自定义类型与接口之间的实现关系是松耦合的：如果某个自定义类型T的方法集合是某个接口类型的方法集合的超集，那么就说类型T实现了该接口，并且类型T的变量可以被赋值给该接口类型的变量，即我们说的方法集合决定接口实现。</p></li><li><p><strong>对于非接口类型的自定义类型T，其方法集合由所有receiver为T类型的方法组成；而类型<code>*T</code>的方法集合则包含所有receiver为T和<code>*T</code>类型的方法。也正因为如此，pt才能成功赋值给Interface类型变量。</strong></p></li><li><p>与接口类型和结构体类型相关的类型嵌入有三种组合：<strong>在接口类型中嵌入接口类型、在结构体类型中嵌入接口类型及在结构体类型中嵌入结构体类型。</strong></p></li><li><p>嵌入了其他接口类型的结构体类型的实例在调用方法时，Go选择方法的次序。1）优先选择结构体自身实现的方法。2）如果结构体自身并未实现，那么将查找结构体中的嵌入接口类型的方法集合中是否有该方法，如果有，则提升（promoted）为结构体的方法。</p></li><li><p>如果结构体嵌入了多个接口类型且这些接口类型的方法集合存在交集，那么Go编译器将报错，除非结构体自己实现了交集中的所有方法。</p></li><li><p>结构体类型在嵌入某接口类型的同时，也实现了这个接口。</p></li><li><p>外部的结构体类型T可以“继承”嵌入的结构体类型的所有方法的实现，并且无论是T类型的变量实例还是*T类型变量实例，都可以调用所有“继承”的方法。</p></li><li><p>T类型的方法集合 = T1的方法集合 + <code>*T2</code>的方法集合；<code>*T</code>类型的方法集合 = <code>*T1</code>的方法集合 + <code>*T2</code>的方法集合。</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// chapter4/sources/method_set_10.go</span><br><span class="line"></span><br><span class="line">type T1 struct{}</span><br><span class="line"></span><br><span class="line">func (T1) T1M1()   { println("T1's M1") }</span><br><span class="line">func (T1) T1M2()   { println("T1's M2") }</span><br><span class="line">func (*T1) PT1M3() { println("PT1's M3") }</span><br><span class="line"></span><br><span class="line">type T2 struct{}</span><br><span class="line"></span><br><span class="line">func (T2) T2M1()   { println("T2's M1") }</span><br><span class="line">func (T2) T2M2()   { println("T2's M2") }</span><br><span class="line">func (*T2) PT2M3() { println("PT2's M3") }</span><br><span class="line"></span><br><span class="line">type T struct {</span><br><span class="line">    T1</span><br><span class="line">    *T2</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><ul><li>已有的类型（比如上面的I、T）被称为underlying类型，而新类型被称为defined类型，而基于自定义非接口类型创建的defined类型则并没有“继承”原类型的方法集合，新的defined类型的方法集合是空的。</li><li><strong>类型别名与原类型拥有完全相同的方法集合，无论原类型是接口类型还是非接口类型。</strong></li></ul><p><strong>小结：</strong>方法集合是类型与接口间隐式关系的纽带，只有当类型的方法集合是某接口类型的超集时，我们才说该类型实现了某接口；类型T的方法集合是以T为receiver类型的所有方法的集合，类型<code>*T</code>的方法集合是以<code>*T</code>为receiver类型的所有方法的集合与类型T的方法集合的并集；了解类型嵌入对接口类型和自定义结构体类型的方法集合的影响；基于接口类型创建的defined类型与原类型具有相同的方法集合，而基于自定义非接口类型创建的defined类型的方法集合为空；类型别名与原类型拥有完全相同的方法集合。</p><h1 id="第25条-了解变长参数函数的妙用"><a href="#第25条-了解变长参数函数的妙用" class="headerlink" title="第25条　了解变长参数函数的妙用"></a>第25条　了解变长参数函数的妙用</h1><ul><li><code>... interface{}</code>。这种接受“…T”类型形式参数的函数就被称为变长参数函数。</li><li>一个变长参数函数只能有一个“…T”类型形式参数，并且该形式参数应该为函数参数列表中的最后一个形式参数</li><li>虽然string类型变量可以直接赋值给interface{}类型变量，但是[]string类型变量并不能直接赋值给[]interface{}类型变量。</li></ul><h4 id="25-2-模拟函数重载"><a href="#25-2-模拟函数重载" class="headerlink" title="25.2 模拟函数重载"></a>25.2 模拟函数重载</h4><p>Go语言不允许在同一个作用域下定义名字相同但函数原型不同的函数，如果定义这样的函数</p><p>如果要重载的函数的参数都是相同类型的，仅参数的个数是变化的，那么变长参数函数可以轻松对应；如果参数类型不同且个数可变，那么我们还要结合interface{}类型的特性。我们来看一个例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// chapter4/sources/variadic_function_5.go</span><br><span class="line"></span><br><span class="line">func concat(sep string, args ...interface{}) string {</span><br><span class="line">    var result string</span><br><span class="line">    for i, v := range args {</span><br><span class="line">        if i != 0 {</span><br><span class="line">            result += sep</span><br><span class="line">        }</span><br><span class="line">        switch v.(type) {</span><br><span class="line">        case int, int8, int16, int32, int64,</span><br><span class="line">            uint, uint8, uint16, uint32, uint64:</span><br><span class="line">            result += fmt.Sprintf("%d", v)</span><br><span class="line">        case string:</span><br><span class="line">            result += fmt.Sprintf("%s", v)</span><br><span class="line">        case []int:</span><br><span class="line">            ints := v.([]int)</span><br><span class="line">            for i, v := range ints {</span><br><span class="line">                if i != 0 {</span><br><span class="line">                    result += sep</span><br><span class="line">                }</span><br><span class="line">                result += fmt.Sprintf("%d", v)</span><br><span class="line">            }</span><br><span class="line">        case []string:</span><br><span class="line">            strs := v.([]string)</span><br><span class="line">            result += strings.Join(strs, sep)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Printf("the argument type [%T] is not supported", v)</span><br><span class="line">            return ""</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return result</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    println(concat("-", 1, 2))</span><br><span class="line">    println(concat("-", "hello", "gopher"))</span><br><span class="line">    println(concat("-", "hello", 1, uint32(2),</span><br><span class="line">        []int{11, 12, 13}, 17,</span><br><span class="line">        []string{"robot", "ai", "ml"},</span><br><span class="line">        "hacker", 33))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="25-3-模拟实现函数的可选参数与默认参数"><a href="#25-3-模拟实现函数的可选参数与默认参数" class="headerlink" title="25.3 模拟实现函数的可选参数与默认参数"></a>25.3 模拟实现函数的可选参数与默认参数</h4><p>如果参数在传入时有隐式要求的固定顺序（这点由调用者保证），我们还可以利用变长参数函数模拟实现函数的可选参数和默认参数。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter4/sources/variadic_function_6.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> record <span class="keyword">struct</span> {</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    gender  <span class="type">string</span></span><br><span class="line">    age     <span class="type">uint16</span></span><br><span class="line">    city    <span class="type">string</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enroll</span><span class="params">(args ...<span class="keyword">interface</span>{} /* name, gender, age, city = "Beijing", country = "China" */)</span></span> (*record, <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">5</span> || <span class="built_in">len</span>(args) &lt; <span class="number">3</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"the number of arguments passed is wrong"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    r := &amp;record{</span><br><span class="line">        city:    <span class="string">"Beijing"</span>, <span class="comment">// 默认值：Beijing</span></span><br><span class="line">        country: <span class="string">"China"</span>,   <span class="comment">// 默认值：China</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> args {</span><br><span class="line">        <span class="keyword">switch</span> i {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// name</span></span><br><span class="line">            name, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"name is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.name = name</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// gender</span></span><br><span class="line">            gender, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"gender is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.gender = gender</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// age</span></span><br><span class="line">            age, ok := v.(<span class="type">int</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"age is not passed as int"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.age = <span class="type">uint16</span>(age)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// city</span></span><br><span class="line">            city, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"city is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.city = city</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// country</span></span><br><span class="line">            country, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"country is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.country = country</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unknown argument passed"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    r, _ := enroll(<span class="string">"小明"</span>, <span class="string">"male"</span>, <span class="number">23</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, _ = enroll(<span class="string">"小红"</span>, <span class="string">"female"</span>, <span class="number">13</span>, <span class="string">"Hangzhou"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, _ = enroll(<span class="string">"Leo Messi"</span>, <span class="string">"male"</span>, <span class="number">33</span>, <span class="string">"Barcelona"</span>, <span class="string">"Spain"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, err := enroll(<span class="string">"小吴"</span>, <span class="number">21</span>, <span class="string">"Suzhou"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="25-4-实现功能选项模式"><a href="#25-4-实现功能选项模式" class="headerlink" title="25.4 实现功能选项模式"></a>25.4 实现功能选项模式</h4><p>在设计和实现类似NewFinishedHouse这样带有配置选项的函数或方法时，功能选项模式让我们可以收获如下好处：更漂亮的、不随时间变化的公共API；参数可读性更好；配置选项高度可扩展；提供使用默认选项的最简单方式；使用更安全。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter4/sources/variadic_function_9.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FinishedHouse <span class="keyword">struct</span> {</span><br><span class="line">    style                  <span class="type">int</span>    <span class="comment">// 0: Chinese; 1: American; 2: European</span></span><br><span class="line">    centralAirConditioning <span class="type">bool</span>   <span class="comment">// true或false</span></span><br><span class="line">    floorMaterial          <span class="type">string</span>  <span class="comment">// "ground-tile"或"wood"</span></span><br><span class="line">    wallMaterial           <span class="type">string</span> <span class="comment">// "latex"或"paper"或"diatom-mud"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*FinishedHouse)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFinishedHouse</span><span class="params">(options ...Option)</span></span> *FinishedHouse {</span><br><span class="line">    h := &amp;FinishedHouse{</span><br><span class="line">        <span class="comment">// default options</span></span><br><span class="line">        style:                  <span class="number">0</span>,</span><br><span class="line">        centralAirConditioning: <span class="literal">true</span>,</span><br><span class="line">        floorMaterial:          <span class="string">"wood"</span>,</span><br><span class="line">        wallMaterial:           <span class="string">"paper"</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, option := <span class="keyword">range</span> options {</span><br><span class="line">        option(h)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStyle</span><span class="params">(style <span class="type">int</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.style = style</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithFloorMaterial</span><span class="params">(material <span class="type">string</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.floorMaterial = material</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithWallMaterial</span><span class="params">(material <span class="type">string</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.wallMaterial = material</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCentralAirConditioning</span><span class="params">(centralAirConditioning <span class="type">bool</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.centralAirConditioning = centralAirConditioning</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, NewFinishedHouse()) <span class="comment">// 使用默认选项</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, NewFinishedHouse(WithStyle(<span class="number">1</span>),</span><br><span class="line">        WithFloorMaterial(<span class="string">"ground-tile"</span>),</span><br><span class="line">        WithCentralAirConditioning(<span class="literal">false</span>)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第26条-了解接口类型变量的内部表示"><a href="#第26条-了解接口类型变量的内部表示" class="headerlink" title="第26条 了解接口类型变量的内部表示"></a>第26条 了解接口类型变量的内部表示</h3><p>接口是Go这门静态类型语言中唯一“动静兼备”的语言特性。接口的静态特性 接口类型变量具有静态类型，比如：var e error中变量e的静态类型为error。支持在编译阶段的类型检查：当一个接口类型变量被赋值时，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法。接口的动态特性 接口类型变量兼具动态类型，即在运行时存储在接口类型变量中的值的真实类型。比如：var i interface{} = 13中接口变量i的动态类型为int。接口类型变量在程序运行时可以被赋值为不同的动态类型变量，从而支持运行时多态。</p><ul><li>nil error值!= nil</li></ul><h4 id="26-2-接口类型变量的内部表示"><a href="#26-2-接口类型变量的内部表示" class="headerlink" title="26.2 接口类型变量的内部表示"></a>26.2 接口类型变量的内部表示</h4><p>eface：用于表示没有方法的空接口（empty interface）类型变量，即interface{}类型的变量。iface：用于表示其余拥有方法的接口（interface）类型变量。</p><p>Go运行时会为程序内的全部类型建立只读的共享_type信息表，因此拥有相同动态类型的同类接口类型变量的_type/tab信息是相同的。而接口类型变量的data部分则指向一个动态分配的内存空间，该内存空间存储的是赋值给接口类型变量的动态类型变量的值。未显式初始化的接口类型变量的值为nil，即该变量的_type/tab和data都为nil。这样，我们要判断两个接口类型变量是否相同，只需判断_type/tab是否相同以及data指针所指向的内存空间所存储的数据值是否相同（注意：不是data指针的值）。</p><p>无论是空接口类型变量还是非空接口类型变量，一旦变量值为nil，那么它们内部表示均为(0x0,0x0)，即类型信息和数据信息均为空。</p><p>对于空接口类型变量，只有在_type和data所指数据内容一致（注意：不是数据指针的值一致）的情况下，两个空接口类型变量之间才能画等号。</p><p>从returnsError返回的error接口类型变量e的数据指针虽然为空，但其类型信息（iface.tab）并不为空（而是*MyError对应的类型信息），因此与nil(0x0,0x0)自然不相等，这就是那个问题的答案。</p><p>空接口类型变量和非空接口类型变量内部表示的结构有所不同（第一个字段：_type vs. tab），似乎一定不能相等。但Go在进行等值比较时，类型比较使用的是eface的_type和iface的tab._type，因此就像我们在这个例子中看到的那样，当eif和err都被赋值为T(5)时，两者之间是可以画等号的。</p><h4 id="26-4-接口类型的装箱原理"><a href="#26-4-接口类型的装箱原理" class="headerlink" title="26.4 接口类型的装箱原理"></a>26.4 接口类型的装箱原理</h4><ul><li><strong>装箱（boxing）是编程语言领域的一个基础概念，一般是指把值类型转换成引用类型。</strong></li><li>在Go语言中，将任意类型赋值给一个接口类型变量都是装箱操作。接口类型的装箱实则就是创建一个eface或iface的过程。</li><li>接口类型变量在运行时表示为eface和iface，eface用于表示空接口类型变量，iface用于表示非空接口类型变量；当且仅当两个接口类型变量的类型信息（eface._type/iface.tab._type）相同，且数据指针（eface.data/iface.data）所指数据相同时，两个接口类型才是相等的；通过println可以输出接口类型变量的两部分指针变量的值；可通过复制runtime包eface和iface相关类型源码，自定义输出eface/iface详尽信息的函数；接口类型变量的装箱操作由Go编译器和运行时共同完成。</li></ul><h3 id="第27条-尽量定义小接口"><a href="#第27条-尽量定义小接口" class="headerlink" title="第27条 尽量定义小接口"></a>第27条 尽量定义小接口</h3><ul><li><p>接口越大，抽象程度越低。</p></li><li><p>小契约：契约繁了便束缚了手脚，降低了灵活性，抑制了表现力。Go选择使用小契约，表现在代码上便是尽量定义小接口。</p></li><li><p>小接口的优势</p><ol><li><p>接口越小，抽象程度越高，被接纳度越高</p></li><li><p>易于实现和测试</p></li><li><p>契约职责单一，易于复用组合</p></li></ol></li></ul><h4 id="27-3-定义小接口可以遵循的一些点"><a href="#27-3-定义小接口可以遵循的一些点" class="headerlink" title="27.3 定义小接口可以遵循的一些点"></a>27.3 定义小接口可以遵循的一些点</h4><ul><li><p>初期不要在意接口的大小，因为对问题域的理解是循序渐进的，期望在第一版代码中直接定义出小接口可能并不现实。</p></li><li><p>有了接口后，我们就会看到接口被用在代码的各个地方。一段时间后，我们来分析哪些场合使用了接口的哪些方法，是否可以将这些场合使用的接口的方法提取出来放入一个新的小接口中</p></li><li><p>接口是将对象的行为进行抽象而形成的契约；<strong>Go青睐定义小接口，即方法数量为1～3个、通常为1个的接口</strong>（这种最佳实践被Go社区项目广泛采纳）；小接口抽象程度高，被接纳度高，易于实现和测试，易于复用组合；先抽象出接口，再拆分为小接口，另外接口的契约职责应尽可能保持单一。</p></li></ul><h3 id="第28条-尽量避免使用空接口作为函数参数类型"><a href="#第28条-尽量避免使用空接口作为函数参数类型" class="headerlink" title="第28条 尽量避免使用空接口作为函数参数类型"></a>第28条 尽量避免使用空接口作为函数参数类型</h3><ul><li><p>在函数或方法参数中使用空接口类型，意味着你没有为编译器提供关于传入实参数据的任何信息，因此，你将失去静态类型语言类型安全检查的保护屏障，你需要自己检查类似的错误，并且直到运行时才能发现此类错误。</p></li><li><p><strong>尽量不要使用可以逃过编译器类型安全检查的空接口类型（interface{}）</strong>。</p></li><li><p>仅在处理未知类型数据时使用空接口类型；在其他情况下，尽可能将你需要的行为抽象成带有方法的接口，并使用这样的非空接口类型作为函数或方法的参数。</p></li></ul><h1 id="第29条-使用接口作为程序水平组合的连接点"><a href="#第29条-使用接口作为程序水平组合的连接点" class="headerlink" title="第29条　使用接口作为程序水平组合的连接点"></a>第29条　使用接口作为程序水平组合的连接点</h1><p>Go语言无类型体系（type hierarchy），类型定义正交独立；方法和类型是正交的，每种类型都可以拥有自己的方法集合；接口与其实现者之间无显式关联。正交性为“组合”哲学的落地提供了前提，而组合就像本条开头引用的Rob Pike的观点那样，是Go程序内各组件间的主要耦合方式，也是搭建Go程序静态结构的主要方式。</p><ul><li><p>Go语言中主要有两种组合方式。垂直组合（类型组合）：Go语言主要通过类型嵌入机制实现垂直组合，进而实现方法实现的复用、接口定义重用等。水平组合：通常Go程序以接口类型变量作为程序水平组合的连接点。接口是水平组合的关键，它就好比程序肌体上的关节，给予连接关节的两个部分或多个部分各自自由活动的能力，而整体又实现了某种功能。</p></li><li><p>Go语言通过类型嵌入实现垂直组合。组合方式莫过于以下3种。</p><ul><li>（1）通过嵌入接口构建接口</li><li>（2）通过嵌入接口构建结构体</li><li>（3）通过嵌入结构体构建新结构体</li></ul></li><li><p>水平组合的基本形式是接受接口类型参数的函数或方法</p></li><li><p>函数/方法参数中的接口类型作为连接点，将位于多个包中的多个类型“编织”到一起，共同形成一幅程序“骨架”。同时接口类型与其实现者之间隐式的关系在不经意间满足了依赖抽象、里氏替换原则、接口隔离等代码设计原则，这在其他语言中是需要刻意设计和谋划的，但对Go接口来看，这一切却是自然而然的。</p></li><li><p>包裹函数（wrapper function）的形式是这样的：它接受接口类型参数，并返回与其参数类型相同的返回值。通过包裹函数可以实现对输入数据的过滤、装饰、变换等操作，并将结果再次返回给调用者。由于包裹函数的返回值类型与参数类型相同，因此我们可以将多个接受同一接口类型参数的包裹函数组合成一条链来调用</p></li><li><p>适配器函数类型（adapter function type）是一个辅助水平组合实现的“工具”类型。强调一下，它是一个类型。它可以将一个满足特定函数签名的普通函数显式转换成自身类型的实例，转换后的实例同时也是某个单方法接口类型的实现者。</p></li><li><p>“中间件”（middleware）这个词的含义可大可小，在Go Web编程中，它常常指的是一个实现了http.Handler接口的http.HandlerFunc类型实例。实质上，这里的中间件就是包裹函数和适配器函数类型结合的产物。</p></li></ul><h3 id="第30条-使用接口提高代码的可测试性"><a href="#第30条-使用接口提高代码的可测试性" class="headerlink" title="第30条 使用接口提高代码的可测试性"></a>第30条 使用接口提高代码的可测试性</h3><p><strong>Go语言有一个惯例是让单元测试代码时刻伴随着你编写的Go代码。</strong></p><ul><li>使用接口来降低耦合，接口本是契约，天然具有降低耦合的作用。</li><li>代码的可测试性已经成为判定Go代码是否优秀的一条重要标准。适当抽取接口，让接口成为好代码与单元测试之间的桥梁是Go语言的一种最佳实践。</li><li>并行方案就是在处理器核数充足的情况下启动多个单线程应用的实例，这样每个实例“运行”在一个核上（如图中的CPU核1～CPU核N），尽可能多地利用多核计算资源。</li><li>简单来说，并发就是重新做应用结构设计，即将应用分解成多个在基本执行单元（图中这样的执行单元为操作系统线程）中执行的、可能有一定关联关系的代码片段（图中的模块1～模块N）。</li></ul><h1 id="第31条-优先考虑并发设计"><a href="#第31条-优先考虑并发设计" class="headerlink" title="第31条　优先考虑并发设计"></a>第31条　优先考虑并发设计</h1><ul><li><strong>goroutine相比传统操作系统线程而言具有如下优势。</strong>1）资源占用小，每个goroutine的初始栈大小仅为2KB。[插图]2）由Go运行时而不是操作系统调度，goroutine上下文切换代价较小。3）语言原生支持：goroutine由go关键字接函数或方法创建，函数或方法返回即表示goroutine退出，开发体验更佳。4）语言内置channel作为goroutine间通信原语，为并发设计提供强大支撑。</li></ul><h1 id="第32条-了解goroutine的调度原理"><a href="#第32条-了解goroutine的调度原理" class="headerlink" title="第32条　了解goroutine的调度原理"></a>第32条　了解goroutine的调度原理</h1><p>直接看书。有GMP模型。</p><h3 id="第33条-掌握Go并发模型和常见并发模式（重要）"><a href="#第33条-掌握Go并发模型和常见并发模式（重要）" class="headerlink" title="第33条 掌握Go并发模型和常见并发模式（重要）"></a>第33条 掌握Go并发模型和常见并发模式（重要）</h3><ul><li><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p></li><li><p>Go始终推荐以CSP模型风格构建并发程序。</p></li><li><p>在内部创建一个goroutine并返回一个channel类型变量的函数，这是Go中最常见的goroutine创建模式</p></li><li><p>goroutine的使用代价很低，<strong>Go官方推荐多使用goroutine。</strong>在多数情况下，我们无须考虑对goroutine的退出进行控制：goroutine的执行函数返回，即意味着goroutine退出。</p></li><li><p>分类说明一下goroutine的几种退出模式：</p><ul><li>（1）分离模式，对于分离的goroutine，创建它的goroutine不需要关心它的退出，这类goroutine在启动后即与其创建者彻底分离，其生命周期与其执行的主函数相关，函数返回即goroutine退出。这类goroutine有两个常见用途。<ul><li>1）一次性任务：顾名思义，新创建的goroutine用来执行一个简单的任务，执行后即退出。</li><li>2）常驻后台执行一些特定任务，如监视（monitor）、观察（watch）等。其实现通常采用for {…}或for { select{…} }代码段形式，并多以定时器（timer）或事件（event）驱动执行。</li></ul></li><li>（2）join模式，goroutine的创建者需要等待新goroutine结束。笔者为这样的goroutine退出模式起名为“join模式”。<ul><li>① 等待一个goroutine退出</li><li>② 获取goroutine的退出状态</li><li>③ 等待多个goroutine退出</li></ul></li><li>（3）notify-and-wait模式<ul><li>① 通知并等待一个goroutine退出</li><li>② 通知并等待多个goroutine退出</li></ul></li><li>（4）退出模式的应用<ul><li>一组goroutine的退出总体上有两种情况。一种是并发退出，在这类退出方式下，各个goroutine的退出先后次序对数据处理无影响，因此各个goroutine可以并发执行退出逻辑；另一种则是串行退出，即各个goroutine之间的退出是按照一定次序逐个进行的，次序若错了可能会导致程序的状态混乱和错误。</li></ul></li></ul></li><li><p>Go语言的channel有一个特性是，当使用close函数关闭channel时，所有阻塞到该channel上的goroutine都会得到通知。</p></li><li><p>一组goroutine的退出总体上有两种情况。一种是并发退出，在这类退出方式下，各个goroutine的退出先后次序对数据处理无影响，因此各个goroutine可以并发执行退出逻辑；另一种则是串行退出，即各个goroutine之间的退出是按照一定次序逐个进行的，次序若错了可能会导致程序的状态混乱和错误。</p></li><li><p>下面来了解两种基于管道模式的扩展模式。</p><ul><li>（1）扇出模式在某个处理环节，多个功能相同的goroutine从同一个channel读取数据并处理，直到该channel关闭，这种情况被称为“扇出”（fan-out）。使用扇出模式可以在一组goroutine中均衡分配工作量，从而更均衡地利用CPU。</li><li>（2）扇入模式在某个处理环节，处理程序面对不止一个输入channel。我们把所有输入channel的数据汇聚到一个统一的输入channel，然后处理程序再从这个channel中读取数据并处理，直到该channel因所有输入channel关闭而关闭。这种情况被称为“扇入”（fan-in）。</li><li>下面示例包含扇入扇出两种模式：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// chapter6/sources/go-concurrency-pattern-9.go </span><br><span class="line">func newNumGenerator(start, count int) &lt;-chan int {</span><br><span class="line">    c := make(chan int)</span><br><span class="line">    go func() {</span><br><span class="line">        for i := start; i &lt; start+count; i++ {</span><br><span class="line">            c &lt;- i</span><br><span class="line">        }</span><br><span class="line">        close(c)</span><br><span class="line">    }()</span><br><span class="line">    return c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func filterOdd(in int) (int, bool) {</span><br><span class="line">    if in%2 != 0 {</span><br><span class="line">        return 0, false</span><br><span class="line">    }</span><br><span class="line">    return in, true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func square(in int) (int, bool) {</span><br><span class="line">    return in * in, true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func spawnGroup(name string, num int, f func(int) (int, bool), in &lt;-chan int) &lt;-chan int {</span><br><span class="line">    groupOut := make(chan int)</span><br><span class="line">    var outSlice []chan int</span><br><span class="line">    for i := 0; i &lt; num; i++ {</span><br><span class="line">        out := make(chan int)</span><br><span class="line">        go func(i int) {</span><br><span class="line">            name := fmt.Sprintf("%s-%d:", name, i)</span><br><span class="line">            fmt.Printf("%s begin to work...\n", name)</span><br><span class="line">            </span><br><span class="line">            for v := range in {</span><br><span class="line">                r, ok := f(v)</span><br><span class="line">                if ok {</span><br><span class="line">                    out &lt;- r</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            close(out)</span><br><span class="line">            fmt.Printf("%s work done\n", name)</span><br><span class="line">        }(i)</span><br><span class="line">        outSlice = append(outSlice, out)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // 扇入模式</span><br><span class="line">    //</span><br><span class="line">    // out --\</span><br><span class="line">    //        \</span><br><span class="line">    // out ---- --&gt; groupOut</span><br><span class="line">    //        /</span><br><span class="line">    // out --/</span><br><span class="line">    //</span><br><span class="line">    go func() {</span><br><span class="line">        var wg sync.WaitGroup</span><br><span class="line">        for _, out := range outSlice {</span><br><span class="line">            wg.Add(1)</span><br><span class="line">            go func(out &lt;-chan int) {</span><br><span class="line">                for v := range out {</span><br><span class="line">                        groupOut &lt;- v</span><br><span class="line">                }</span><br><span class="line">                wg.Done()</span><br><span class="line">            }(out)</span><br><span class="line">        }</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(groupOut)</span><br><span class="line">    }()</span><br><span class="line">    </span><br><span class="line">    return groupOut</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">      in := newNumGenerator(1, 20)</span><br><span class="line">      out := spawnGroup("square", 2, square, spawnGroup("filterOdd", 3, filterOdd, in))</span><br><span class="line"></span><br><span class="line">      time.Sleep(3 * time.Second) //为了输出更直观的结果，这里等上面的goroutine都就绪</span><br><span class="line"></span><br><span class="line">      for v := range out {</span><br><span class="line">          fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="第34条-了解channel的妙用"><a href="#第34条-了解channel的妙用" class="headerlink" title="第34条 了解channel的妙用"></a>第34条 了解channel的妙用</h3><p><strong>channel类型在Go中为“一等公民”，</strong>我们可以像使用普通变量那样使用channel，比如：定义channel类型变量，为channel变量赋值，将channel作为参数传递给函数/方法，将channel作为返回值从函数/方法中返回，甚至将channel发送到其他channel中。</p><ul><li><p>对于无缓冲channel而言，我们得到以下结论：发送动作一定发生在接收动作完成之前；接收动作一定发生在发送动作完成之前。</p><ul><li>用作信号传递<ul><li>（1）一对一通知信号</li><li>（2）一对多通知信号</li></ul></li><li>用于替代锁机制</li></ul></li><li><p>对带缓冲channel的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是异步的（发送或接收无须阻塞等待）。</p><ul><li>用作消息队列,无论是单收单发还是多收多发，带缓冲channel的收发性能都要好于无缓冲channel的；对于带缓冲channel而言，选择适当容量会在一定程度上提升收发性能。</li><li>用作计数信号量</li></ul></li><li><p>Go并发设计的一个惯用法是将带缓冲channel用作计数信号量（counting semaphore）。带缓冲channel中的当前数据个数代表的是当前同时处于活动状态（处理业务）的goroutine的数量，而带缓冲channel的容量（capacity）代表允许同时处于活动状态的goroutine的最大数量。一个发往带缓冲channel的发送操作表示获取一个信号量槽位，而一个来自带缓冲channel的接收操作则表示释放一个信号量槽位。</p></li><li><p>len是Go语言原生内置的函数，它可以接受数组、切片、map、字符串或channel类型的参数，并返回对应类型的“长度”——一个整型值。以len(s)为例：如果s是字符串（string）类型，len(s)返回字符串中的字节数；如何s是[n]T或*[n]T的数组类型，len(s)返回数组的长度n；如果s是[]T的切片（slice）类型，len(s)返回切片的当前长度；如果s是map[K]T的map类型，len(s)返回map中已定义的key的个数；如果s是chan T类型，那么len(s)针对channel的类型不同，有如下两种语义：当s为无缓冲channel时，len(s)总是返回0；当s为带缓冲channel时，len(s)返回当前channel s中尚未被读取的元素个数。这样一来，针对带缓冲channel的len调用才是有意义的。</p></li><li><p>单纯依靠len(channel)来判断channel中元素的状态，不能保证在后续对channel进行收发时channel的状态不变。</p></li><li><p>为了不阻塞在channel上，常见的方法是将判空与读取放在一个事务中，将判满与写入放在一个事务中，而这类事务我们可以通过select实现。</p></li><li><p>a是一个多发送单接收的场景，即有多个发送者，但有且只有一个接收者。在这样的场景下，我们可以在接收者goroutine中根据len(channel)是否大于0来判断channel中是否有数据需要接收。</p></li><li><p>b是一个多接收单发送的场景，即有多个接收者，但有且只有一个发送者。在这样的场景下，我们可以在发送goroutine中根据len(channel)是否小于cap(channel)来判断是否可以执行向channel的发送操作。</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_60" alt="img"></p><ul><li>34.3 nil channel的妙用：<strong>对没有初始化的channel（nil channel）进行读写操作将会发生阻塞</strong>，在判断c1或c2被关闭后，显式地将c1或c2置为nil。我们知道，对一个nil channel执行获取操作，该操作将被阻塞</li><li>channel与select结合使用的一些惯用法<ul><li>利用default分支避免阻塞</li><li>实现超时机制</li><li>实现心跳机制</li></ul></li></ul><h1 id="第35条-了解sync包的正确用法"><a href="#第35条-了解sync包的正确用法" class="headerlink" title="第35条　了解sync包的正确用法"></a>第35条　了解sync包的正确用法</h1><ul><li><p>在下面一些场景下，我们依然需要sync包提供的低级同步原语。</p><ul><li>（1）需要高性能的临界区同步机制场景</li><li>（2）不想转移结构体对象所有权，但又要保证结构体内部状态数据的同步访问的场景</li></ul></li><li><p>使用sync包的注意事项：那些sync包中类型的实例在首次使用后被复制得到的副本一旦再被使用将导致不可预期的结果，为此在使用sync包中类型时，推荐通过闭包方式或传递类型实例（或包裹该类型的类型实例）的地址或指针的方式进行，这是使用sync包最值得注意的事项。</p></li><li><p>读写锁还是互斥锁：在并发量较小的情况下，互斥锁性能更好；随着并发量增大，互斥锁的竞争激烈，导致加锁和解锁性能下降。读写锁的读锁性能并未随并发量的增大而发生较大变化，性能始终恒定在40ns左右。在并发量较大的情况下，读写锁的写锁性能比互斥锁、读写锁的读锁都差，并且随着并发量增大，其写锁性能有继续下降的趋势。由此我们可以看出，<strong>读写锁适合应用在具有一定并发量且读多写少的场合。</strong></p></li><li><p>在Go标准库中，sync.Once的“仅执行一次”语义被一些包用于初始化和资源清理的过程中，以避免重复执行初始化或资源关闭操作。</p></li></ul><h4 id="35-6-使用sync-Pool减轻垃圾回收压力"><a href="#35-6-使用sync-Pool减轻垃圾回收压力" class="headerlink" title="35.6 使用sync.Pool减轻垃圾回收压力"></a>35.6 使用sync.Pool减轻垃圾回收压力</h4><p>sync.Pool是一个数据对象缓存池，它具有如下特点：它是goroutine并发安全的，可以被多个goroutine同时使用；放入该缓存池中的数据对象的生命是暂时的，随时都可能被垃圾回收掉；缓存池中的数据对象是可以重复利用的，这样可以在一定程度上降低数据对象重新分配的频度，减轻GC的压力；sync.Pool为每个P（goroutine调度模型中的P）单独建立一个local缓存池，进一步降低高并发下对锁的争抢。</p><p>由于sync.Pool的Get方法从缓存池中挑选bytes.Buffer数据对象时并未考虑该数据对象是否满足调用者的需求，因此一旦返回的Buffer对象是刚刚被“大数据”撑大后的，并且即将被长期用于处理一些“小数据”时，这个Buffer对象所占用的“大内存”将长时间得不到释放。一旦这类情况集中出现，将会给Go应用带来沉重的内存消耗负担，改进措施：（1）限制要放回缓存池中的数据对象大小（2）建立多级缓存池</p><h4 id="36-1-atomic包与原子操作"><a href="#36-1-atomic包与原子操作" class="headerlink" title="36.1 atomic包与原子操作"></a>36.1 atomic包与原子操作</h4><ul><li><p>原子操作的指令是不可中断的，它就好比一个事务，要么不执行，一旦执行就一次性全部执行完毕，不可分割。</p></li><li><p>利用原子操作的无锁并发写的性能随着并发量增大几乎保持恒定；利用原子操作的无锁并发读的性能随着并发量增大有持续提升的趋势，并且性能约为读锁的200倍。</p></li><li><p>atomic通过Value类型的装拆箱操作实现了对任意自定义类型的原子操作（Load和Store），从而实现对共享自定义类型变量无锁读写的支持</p></li><li><p>atomic包更适合一些对性能十分敏感、并发量较大且读多写少的场合</p></li></ul><h3 id="第37条-了解错误处理的4种策略"><a href="#第37条-了解错误处理的4种策略" class="headerlink" title="第37条 了解错误处理的4种策略"></a>第37条 了解错误处理的4种策略</h3><ul><li><p>在标准库中，Go提供了构造错误值的两种基本方法——errors.New和fmt.Errorf</p></li><li><p>error接口的实现者负责提供错误上下文供负责错误处理的代码使用。这种错误上下文与error接口类型的分离体现了Go设计哲学中的“正交”理念。</p></li><li><p><strong>透明错误处理策略</strong>：最大限度地减少了错误处理方与错误值构造方之间的耦合关系，它们之间唯一的耦合就是error接口变量所规定的契约。</p></li><li><p>　<strong>“哨兵”错误处理策略</strong>：Go标准库采用了定义导出的（exported）“哨兵”错误值的方式来辅助错误处理方检视错误值并做出错误处理分支的决策，如果你使用的是Go 1.13及后续版本，请尽量使用errors.Is方法检视某个错误值是不是某个特定的“哨兵”错误值。</p></li><li><p>错误值类型检视策略：我们需要通过自定义错误类型的构造错误值的方式来提供更多的错误上下文信息，并且由于错误值均通过error接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用Go提供的类型断言机制（type assertion）或类型选择机制（type switch），这种错误处理笔者称之为错误值类型检视策略。我们来看一个标准库中的例子。从Go 1.13版本开始，标准库errors包提供了As方法用于错误处理方对错误值进行检视。As方法类似于通过类型断言判断一个error类型变量是否为特定的自定义错误类型。</p></li><li><p><strong>错误行为特征检视策略</strong>：将某个包中的错误类型归类，统一提取出一些公共的错误行为特征（behaviour），并将这些错误行为特征放入一个公开的接口类型中。</p></li></ul><p><strong>小结：</strong>尽量使用透明错误处理策略降低错误处理方与错误值构造方之间的耦合；如果可以通过错误值类型的特征进行错误检视，那么尽量使用错误行为特征检视策略；在上述两种策略无法实施的情况下，再用“哨兵”策略和错误值类型检视策略；在Go 1.13及后续版本中，尽量用errors.Is和errors.As方法替换原先的错误检视比较语句。</p><h1 id="第38条-尽量优化反复出现的if-err-x3D-nil"><a href="#第38条-尽量优化反复出现的if-err-x3D-nil" class="headerlink" title="第38条　尽量优化反复出现的if err != nil"></a>第38条　尽量优化反复出现的if err != nil</h1><ul><li><p>1）改善代码的视觉呈现。</p></li><li><p>2）降低if err != nil重复的次数。</p></li><li><p>圈复杂度是一种代码复杂度的衡量标准，我们常用它来衡量一个模块判定结构的复杂程度。圈复杂度高，说明程序代码可能质量低且难于测试和维护。根据经验，程序的可能错误与高的圈复杂度有着很大关系。圈复杂度可以通过程序控制流图计算，公式为V(G) = e + 2 - n。其中：e为控制流图中边的数量；n为控制流图中节点的数量（包括起点和终点；所有终点只计算一次，多个return和throw算作一个节点）。图38-3是不同数量的if语句对应的不同圈复杂度的示意图。<img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_65" alt="img"></p></li></ul><p>掌握错误处理代码优化的四种常见方法（位于三个不同象限中），并根据所处场景与约束灵活使用：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_66" alt="img"></p><h4 id="39-2-panic的典型应用"><a href="#39-2-panic的典型应用" class="headerlink" title="39.2 panic的典型应用"></a>39.2 panic的典型应用</h4><ul><li><p>在Go标准库中，大多数panic是充当类似断言的作用的。</p></li><li><p>用于简化错误处理控制结构。</p></li><li><p>使用recover捕获panic，防止goroutine意外退出。</p></li><li><p><strong>在Go 1.11及以后版本中，Go编译器得到更深入的优化，很多简单的函数或方法会被自动内联（inline）。函数一旦内联化，我们就无法在栈跟踪信息中看到栈帧信息了，栈帧信息都变成了省略号。</strong></p></li><li><p>深入理解不要使用panic进行正常错误处理的原因。Go标准库中panic的常见使用场景。理解程序发生panic时输出的栈帧信息有助于快速定位bug，找出“元凶”。</p></li></ul><h1 id="其他金句摘抄"><a href="#其他金句摘抄" class="headerlink" title="其他金句摘抄"></a>其他金句摘抄</h1><ul><li>语言影响或决定人类的思维方式。不能影响到你的编程思维方式的编程语言不值得学习和使用。</li><li>每当你花费大量时间使用某种特定工具时，深入了解它并了解如何高效地使用它是很值得的。</li><li>Go的设计哲学之一是偏好组合。</li><li>Go语言的设计哲学之一是“原生并发，轻量高效”。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《c++Primer》笔记</title>
      <link href="/2024/01/08/%E3%80%8Ac++Primer%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/01/08/%E3%80%8Ac++Primer%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="第二章变量类型"><a href="#第二章变量类型" class="headerlink" title="第二章变量类型"></a>第二章变量类型</h2><ul><li>类型char和类型signed char不一样，尽管字符型有三种，但是字符的表现只有两种：带符号的和无符号的，类型char会表现为上述两种形式的一种，具体由编译器决定。</li><li>程序也应该尽量避免依赖于实现环境的行为。如果我们把int的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植的(nonportable)。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。</li><li>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值。</li><li>在c++中，初始化和赋值不是一个概念。</li><li>定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。<strong>故建议初始化每一个内置类型的变量。</strong></li><li>变量只能被定义一次，但可以多次声明。</li><li>在第一次使用变量的时候再定义它。</li><li>建议初始化所有指针。</li><li>(void*)指针可以存放任意对象的地址。</li><li>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</li><li>默认状态下，const对象仅在文件内有效。如果想多个文件之间共享，需要加上extern关键字。</li><li>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240420160229611.png" alt="image-20240420160229611"></p><h2 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h2><ul><li><strong>头文件不应该包含using声明，因为头文件如果有某个using声明，那么每一个使用了这个头文件的文件就都会有这个声明。</strong></li><li>普通迭代器和常迭代器:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240420165146058.png" alt="image-20240420165146058"></p><ul><li>不要在基于范围的for循环中向vector中添加元素，还有push_back也可能会使迭代器失效。</li><li>迭代器可以进行运算：<code>auto mid = s.begin() + (s.end() - s.begin())/2;</code></li><li>c++的数组是固定大小的。</li><li>c++的数组不允许拷贝和赋值。eg:<code>int a[] = {0,1,2};int a2[] = a; //error  a2 = a; // error</code></li><li>c++11标准库中有begin()和end()两个函数，可以得到容器的首位指针。</li><li>两个指针相减的结果的类型是 <strong>ptrdiff_t</strong>的类型，他是有符号的。</li><li>c++程序最好不用c风格字符串，因为不安全。</li><li>使用数组可以初始化vector的对象:<code>int int_arr[] = {0,1,2,3};vector&lt;int&gt; ivec(begin(int_arr),end(int_arr));</code></li></ul><h1 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h1><ul><li>在需要右值的地方可以用左值代替，但是不能把右值当成左值。</li><li>只有四种运算符明确规定了运算对象的求值顺序，1) &amp;&amp;;2)||;3)?:;4),    对于其他的运算符我们是不知道求值的顺序的比如<code>int i = f1() * f2()</code>不一定f1()和f2()是谁先调用，另外<code>cout &lt;&lt; i &lt;&lt; " " &lt;&lt; ++i &lt;&lt; endl;</code>也是未定义的，&lt;&lt;没有规定何时求值。</li><li>处理复合表达式的两个经验建议:1)拿不准的话用括号来强制让表达式的组合关系符合程序逻辑的要求。</li><li>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</li><li>短路求值(short-circuit evaluation)。对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li><li>赋值运算符的左侧运算对象必须是一个可修改的左值。</li><li>除非必须，否则不适用递减递增运算符的后置版本。主要其实是为了编译器优化考虑，减少编译器优化。</li><li>reinterpret cast本质上依赖于机器。要想安全地使用reinterpret cast必须对涉及的类型和编译器实现转换的过程都非常了解。</li></ul><h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><ul><li>即使不准备在 default标签下做任何工作，定义一个 default 标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前<br>什么也没做。</li><li>定义在while条件部分或者while循环体内的变量每次选代都经历从创建到销毁的过程。</li><li><strong>编写异常安全的代码是非常困难的</strong></li></ul><h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><ul><li>调用重载函数有三种可能的结果：1.编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。2)找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。3)有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，存在二义性调用。</li><li>在C++语言中，名字查找发生在类型检查之前。</li><li>好吧，原来c++ primer都提了inline只是请求了:</li></ul><p><img src="C:\Users\14064\AppData\Roaming\Typora\typora-user-images\image-20240420184059636.png" alt="image-20240420184059636"></p><ul><li>内联函数和constexpr函数可以放在头文件里，因为他们可以在程序中多次定义，但是要保证多个定义必须完全一致。</li><li>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。</li></ul><h1 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h1><ul><li>定义在类内部的函数是隐式的inline函数。</li><li>对于常成员函数，其声明时参数列表后面的const关键字其实是修改隐式this指针的类型的。</li><li><strong>合成构造函数</strong>：就是编译器生成的构造函数。</li><li>封装的优点:1.确保用户代码不会无意间破坏封装对象的状态。  2.被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。</li><li>class 的public下面的using和typedef用户也可以使用的。</li><li>可变数据成员用mutable修饰。</li><li>一个const 成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</li><li>编译器处理完类中的全部声明后才会处理成员函数的定义。</li><li>尽管类的成员被隐藏了（当全局变量和类成员名称相同时），但我们仍然可以通过加上类的名字或显式地使用this 指针来强制访问成员。</li><li>最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。</li><li>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。</li></ul><h3 id="什么是聚合类？"><a href="#什么是聚合类？" class="headerlink" title="什么是聚合类？"></a>什么是聚合类？</h3><p><img src="C:\Users\14064\AppData\Roaming\Typora\typora-user-images\image-20240420202831357.png" alt="image-20240420202831357"></p><h1 id="第八章-IO库"><a href="#第八章-IO库" class="headerlink" title="第八章 IO库"></a>第八章 IO库</h1><ul><li>IO对象无拷贝或者赋值比如说<code>ofstream out1,out2; out1 = out2;//error</code></li><li>当一个fstream对象被销毁时，close会自动调用。</li></ul><h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><ul><li>常见的顺序容器:vector 、deque、list、forward_list、array、string。</li><li>通常，vector是最好的选择，除非有更好的理由选择其他容器。</li><li>如果程序有很多小的元素，且空间的额外开销很重要，就不要用list或者forward_list。</li><li>如果程序要求随机访问元素，应使用vector或者deque</li><li>如果程序要求在容器的中间插入或删除元素，应使用list或者forward_list</li><li>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操<br>作，则使用 deque。</li><li><strong>当不需要写访问时，应用cbegin()和cend()</strong></li><li>当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型<br>都必须相同。</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421143503574.png" alt="image-20240421143503574"></p><ul><li>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</li><li>标准库array有固定大小<code>array&lt;int,42&gt;</code></li><li>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap 操作将容器内容交换不会导致指向容器的选代器、引用和指针失效容器类型为array和string的情况除外)。</li><li>assign仅顺序容器可用，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值，比如说可以用assign来将一个vector中的一段char * 赋值给一个list的string。</li><li>除 array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证<br>在常数时间内完成：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421143920343.png" alt="image-20240421143920343"></p><ul><li>向一个 vector、string或deque 插入元素会使所有指向容器的选代器引用和指针失效。</li><li>insert可以插入范围内的元素:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421144210614.png" alt="image-20240421144210614"></p><ul><li><p>insert的返回值:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421144556823.png" alt="image-20240421144556823"></p></li><li><p>当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。</p></li><li><p><strong>为了确保下标合法，可以使用at成员函数，如果下标越界at会抛出out_of_range的异常。</strong></p></li><li><p>erase可以删除一个元素，也可以删除多个元素<code>slist.erase(elem1,elem2)</code>,会删除elem1到elem2范围内的元素。</p></li><li><p>如果resize缩小容器，则指向被删除元素的迭代器、引用和指针都会失效;对vector、string或deque进行resize可能导致选代器、指针和引用失效。</p></li><li><p>如果在一个循环中插入/删除deque、string或vector中的元素，不要缓存end 返回的选代器。<strong>我更建议直接就不要缓存end()的迭代器。</strong></p></li><li><p>vector可以调用shrinkto fit来要求 vector 将超出当前大小的多余内存退回给系统。</p></li><li><p>每个 vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是:只有当迫不得已时才可以分配新的内存空间。</p></li><li><p>string有两个额外的成员函数:append和replace</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421145622488.png" alt="image-20240421145622488"></p><ul><li>string 搜索函数返回string::size type值，该类型是一个unsigned<br>类型。</li><li><strong>容器适配器</strong>：三种顺序容器适配器：stack、queue、priority_queue。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器(除array或forward list外)，并使其操作起来像一个stack 一样。表9.17列出了所有容器适配器都支持的操作和类型。</li></ul><h1 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h1><p>大多数算法都定义在头文件 algorithm中。标准库还在头文件numeric 中定义了组数值泛型算法。</p><ul><li>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范<br>围(参见9.2.1节，第296页)来进行操作。通常情况下，算法遍历范围，对其中每个元<br>素进行一些处理。</li><li>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。</li><li>对于只读取而不改变元素的算法，通常最好使用cbegin()和cend()。但是，如果你计划使用算法返回的选代器来改变元素的值，就需要使用begin()和end()的结果作为参数。</li><li>向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素</li><li><code>vector&lt;int&gt; vec;fill_n(vec.begin(),10,0);</code> 这是一个未定义的行为，因为vec的大小没有10这么大。</li><li>unique函数会消去重复值，把vector后面的元素给删掉。</li><li>stable_sort算法是一个稳定的排序算法，会维持相等元素的原有顺序。</li><li>bind 的标准库函数，它定义在头文件 functional中。可以将 bind 函数看作一个通用<br>的函数适配器(参见9.6节，第329页)，它接受一个可调用对象，生成一个新的可调用对<br>象来“适应”原对象的参数列表。</li><li>placeholders:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421151519389.png" alt="image-20240421151519389"></p><ul><li>迭代器的四种类型:插入迭代器、流迭代器、反向迭代器、移动迭代器。</li><li>五类迭代器:输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代。</li><li>对于 list和forward list,应该优先使用成员函数版本的算法而不是通用算法。</li></ul><h1 id="第十一章-关联容器"><a href="#第十一章-关联容器" class="headerlink" title="第十一章 关联容器"></a>第十一章 关联容器</h1><ul><li>就这么几种：map、set、multimap、multiset、unordered_map、unordered_set、unordered_multimap、unordered_multiset.</li><li>必须记住，一个map的value type 是一个pair，我们可以改变 pair 的值，但不能改变关键字成员的值。</li><li>向map中添加元素:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421152811118.png" alt="image-20240421152811118"></p><ul><li><strong>insert有返回值，通过判断他的second成员为true，说明插入成功，为false说明已经存在了，什么事情都不做。</strong></li><li><strong>erase函数会返回bool，为true表示删除成功，否则表示删除失败，也就说明了删除的元素并不在容器中。所以说不要删除前find找找了！！！！！！！</strong></li><li>对一个map使用下标操作，其行为与数组或vector上的下标操作很不相同:使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到map中。</li><li>如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。</li><li>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈<br>希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。无序容器提供了一组管理桶的函数：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421153326763.png" alt="image-20240421153326763"></p><h1 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h1><ul><li><p><strong>make shared 用其参数来构造给定类型的对象。</strong></p></li><li><p>如果你将 shared ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</p></li><li><p>使用了动态生存期的资源的类一般处于下面三种原因（容器类就是第一种原因）：</p><ul><li>1.程序不知道自己需要使用多少对象</li><li>2.程序不知道所需对象的准确类型</li><li>3.程序需要在多个对象间共享数据</li></ul></li><li><p>一旦一个程序用光了它所有可用的内存，new表达式就会失败。默认情况下，如果<br>new不能分配所要求的内存空间，它会抛出一个类型为badalloc(参见5.6节，第173<br>页)的异常。我们可以改变使用new的方式来阻止它抛出异常：<code>int *p2 = new (nothrow) int;// 如果分配失败，new返回一个空指针。</code></p></li><li><p>delete一个空指针总是没有错误的。</p></li><li><p>shared_ptr的构造函数:<br><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421193019250.png" alt="image-20240421193019250"></p></li><li><p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无<br>法知道对象何时会被销毁。</p></li><li><p>get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。</p></li><li><p>智能指针陷阱:<br><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421193328756.png" alt="image-20240421193328756"></p></li><li><p>因为对象可能不存在，所以不能使用weak_ptr来直接访问对象，必须调用lock，这个函数会检查weak_ptr指向的对象是否存在，如果存在的话，lock会返回一个指向共享对象的shared_ptr,使用示例:<code>if (shared_ptr&lt;int&gt; np = wp.lock())</code></p></li><li><p>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</p></li><li><p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造<br>分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p></li><li><p>为了使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。</p></li><li><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p></li><li><p><strong>三/五法则</strong>：如前所述，有三个基本操作可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。</p></li><li><p>如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。</p></li><li><p>需要拷贝操作的类也需要赋值操作，反之亦然。</p></li><li><p>对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。</p></li><li><p>希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的。</p></li><li><p>类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，<br>副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。比如说string，标准库容器。</p></li><li><p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相<br>同的底层数据。改变副本也会改变原对象，反之亦然。比如说shared_ptr。</p></li><li><p>赋值运算符注意事项:</p></li><li><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421202027475.png" alt="image-20240421202027475"></p></li><li><p>一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。</p></li><li><p><strong>拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况<br>下，公共的工作应该放在private的工具函数中完成。</strong></p></li><li><p>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能<br>对其值进行任何假设。</p></li><li><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。</p></li><li><p>在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用std::move。</p></li><li><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p></li></ul><h1 id="第十四章-重载运算与类型转换"><a href="#第十四章-重载运算与类型转换" class="headerlink" title="第十四章 重载运算与类型转换"></a>第十四章 重载运算与类型转换</h1><ul><li>当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的(显式)参数数量比运算对象的数量少一个。</li><li>可重载的和不可重载的运算符:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421203644342.png" alt="image-20240421203644342"></p><ul><li>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</li><li>运算符定义为成员还是普通函数的选择建议:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421203804159.png" alt="image-20240421203804159"></p><ul><li>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</li><li><strong>输入输出运算符必须是非成员函数。</strong></li><li>当读取操作发生错误时，输入运算符应该负责从错误中恢复，输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</li><li>如果类定义了operator== ，则这个类也应该定义operator!=。对于用户来说,当他们能使用==时肯定也希望能使用!=，反之亦然。</li><li>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含–,则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</li><li>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</li><li>如果一个类包含下标运算符，则它通常会定义两个版本:一个返回普通引用，<br>另一个是类的常量成员并且返回常量引用。</li><li>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。</li><li>为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</li><li>为了与内置版本保持一致，后置运算符应该返回对象的原值(递增或递减之前<br>的值)，返回的形式是一个值而非引用。</li><li>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义<br>了一个执行命名操作的调用运算符：</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421205959017.png" alt="image-20240421205959017"></p><ul><li>function模板实现函数表:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240421210335755.png" alt="image-20240421210335755"></p><ul><li>类型转换操作符:类型转换运算符(conversion operator)是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示:<code>operator type()const;</code></li><li>向 bool的类型转换通常用在条件部分，因此operatorbool一般定义成explicit的。</li><li>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</li></ul><h1 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h1><ul><li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li><li>派生类可以访问基类的公有成员和受保护成员。</li><li>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</li><li>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</li><li>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算<br>符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限<br>递归。下面是一个回避虚函数机制的例子，通过利用作用域限定符来调用父类的函数:</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Child: public Father</span><br><span class="line">{...};</span><br><span class="line">Father* baseP = new Child();</span><br><span class="line">auto undiscounted = baseP-&gt;Father::net_price(42);//正确，使用了作用域限定符。</span><br></pre></td></tr></tbody></table></figure><ul><li>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected说明符可以看做是public和private中和后的产物。</li><li>不能继承友元关系;每个类负责控制各自成员的访问权限。</li><li><strong>派生类只能为那些它可以访问的名字提供using声明，来改变个别成员的可访问性</strong>：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Base{</span><br><span class="line">public:</span><br><span class="line">std::size_t size() const {return n;}</span><br><span class="line">protected:</span><br><span class="line">std::size_t n;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line">class Derived: private Base{</span><br><span class="line">public:</span><br><span class="line">using Base::size; // 本来该是private的，转换为了public，和父类保持了一直。</span><br><span class="line">protected:</span><br><span class="line">using Base::n;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>派生类的成员将隐藏同名的基类成员。</strong></li><li>除了覆盖继承而来的虚函数之外,派生类最好不要重用其他定义在基类中的名字。</li><li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员<br>在内的整个对象。</li></ul><h1 id="第十六章-模板与泛型编程"><a href="#第十六章-模板与泛型编程" class="headerlink" title="第十六章 模板与泛型编程"></a>第十六章 模板与泛型编程</h1><ul><li>编译器用推断出的模板参数来为我们实例化(instantiate)一个特定版本的函数。当编<br>译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个<br>新“实例”。</li><li>函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr说明符放在模板参数列表之后，返回类型之前:<code>template&lt;class T&gt; inline void min(T a,T b);</code></li><li>模板程序应该尽量减少对实参类型的要求。</li><li>保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</li><li>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</li><li>类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友<br>元间的友好关系。</li><li>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为<br>友元。<strong>也可以将模板的类型参数当做友元。。<code>template&lt;Typename Type&gt; class Base{friend Type;}</code></strong></li><li>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于<br>任何使用这些模板的代码之前。</li><li><strong>对模板设计者所面对的设计选择，标准库智能指针类型给出了一个很好的展示。</strong>主要可以考虑shared_ptr。</li><li>标准库的类型转换模板:</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240422085651552.png" alt="image-20240422085651552"></p><ul><li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放<br>在前面，然后是这些模板的特例化版本。</li></ul><h1 id="第十七章-标准库特殊设施"><a href="#第十七章-标准库特殊设施" class="headerlink" title="第十七章 标准库特殊设施"></a>第十七章 标准库特殊设施</h1><ul><li>当我们希望将一些数据组合成单一对象,但又不想麻烦地定义一个新数据结构来表示<br>这些数据时，tuple是非常有用的。</li><li>由于 tuple 定义了&lt;和==运算符，我们可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型。</li><li>string的下标编号习惯与bitset恰好相反:string中下标最大的字符(最右字符)用来初始化bitset中的低位(下标为0的二进制位)。当你用一个<br>string初始化一个bitset时，要记住这个差别。</li><li>C++程序不应该使用库函数rand，而应使用default random engine 类和恰当的分布类对象。</li><li>当我们说随机数发生器时，是指分布对象和引擎对象的组合。</li><li>除非你需要控制浮点数的表示形式(如，按列打印数据或打印表示金额或百分<br>比的数据)，否则由标准库选择记数法是最好的方式。</li></ul><h1 id="之前记录的合并过来"><a href="#之前记录的合并过来" class="headerlink" title="之前记录的合并过来"></a>之前记录的合并过来</h1><ol><li><p>想声明一个变量而非定义它，那么在变量名前添加extern,而且不要显式的初始化变量。</p><p>即extern int i;如果写为extern int i=10,那么就变为定义了。</p></li><li><p>引用的类型要和与之绑定的对象严格匹配。</p></li><li><p>指针的类型要和与之绑定的对象严格匹配。</p></li><li><p>空指针的三种等价方法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p1 = nullptr;</span><br><span class="line">int *p2 = 0;</span><br><span class="line">int *p3 = NULL;</span><br></pre></td></tr></tbody></table></figure></li><li><p>面对一条比较复杂的指针或引用的声明语句时，从右往左读有助于理解他的真实含义，如<code>int *&amp;r=p</code>的意思是r是对整型指针p的引用。</p></li><li><p>要想存放常量对象的地址，只能使用指向常量的指针。同时指针常量也可以指向非常量。</p></li><li><p>顶层const表示指针本身是个常量，底层const表示指针所知的对象是一个常量。</p></li><li><p>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</p></li><li><p>头文件不应包含using声明</p></li><li><p>string.size()返回的是string::size_type类型的值。</p></li></ol><h1 id="suggestion"><a href="#suggestion" class="headerlink" title="suggestion"></a>suggestion</h1><ul><li>初始化变量。</li><li>检查下标的值。</li><li>尽量使用for-range循环，并且保证过程中不会改变容器的大小。</li><li>简洁可以成为一种美德。</li><li>移位运算符满足左结合律，即<code>cout &lt;&lt;"hi" &lt;&lt; "here" &lt;&lt; endl;</code>等价于<code>((cout &lt;&lt; "hi") &lt;&lt; "there" ) &lt;&lt; endl;</code></li><li>sizeof运算符满足右结合律。<code>sizeof * p</code>，因为其中sizeof和*的优先级是一样的，但是呢又因为满足右结合律，所以是从右往左的顺序求值的，就是<code>sizeof(*p)</code></li><li></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读找错记录</title>
      <link href="/2024/01/08/%E9%98%85%E8%AF%BB%E6%89%BE%E9%94%99%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/01/08/%E9%98%85%E8%AF%BB%E6%89%BE%E9%94%99%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="阅读其他书籍"><a href="#阅读其他书籍" class="headerlink" title="阅读其他书籍"></a>阅读其他书籍</h1><p>待建设。。。</p><h1 id="阅读的技术书籍"><a href="#阅读的技术书籍" class="headerlink" title="阅读的技术书籍"></a>阅读的技术书籍</h1><ol><li>发现技术书籍中也有很多的错误，不管是简单的排版错字，还是概念不清不楚，或者是作者的知识面广度不够。比如说我看了一个模板的书，未决名这么简单的事情，说的让人一头雾水。或者是有个现代cpp的书，在后来重温的时候，他在讲解=delete的功能时提了一下把operator new删除后可阻值在堆上创建对象，首先这个观点应该是错的就不说了，并且他没有说一个关键的用处，就是=删除模板，它将成为任何非精确模板的匹配项参数和防止隐式转换,或者就是我们主动的明确的进行删除某个类型的<code>void func(double data)=delete</code>:</li></ol></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《记录一次升级libc.so.6的事故》</title>
      <link href="/2023/12/09/%E3%80%8A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%8D%87%E7%BA%A7libc.so.6%E7%9A%84%E4%BA%8B%E6%95%85%E3%80%8B/"/>
      <url>/2023/12/09/%E3%80%8A%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%8D%87%E7%BA%A7libc.so.6%E7%9A%84%E4%BA%8B%E6%95%85%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>之前在一家私募公司实习的时候，我做过一次升级glibc的操作，并且还升级成功了，没成想啊没成想，原来升级glibc的操作这么的敏感啊其实。。。我在华为云服务器上运行了如下的命令：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231209100657537.png" alt="image-20231209100657537"></p><p>想着先备份一下再给新的复制过去，没成想直接就G了，我提工单，华为云的工程师也没有办法处理（好像具体是因为我的这个服务器的版本的问题，所以导致的他们也没有解决的办法，我真他妈服了，服了服了，只能重装了。</p><p>​以后做类似的操作的时候，要谨慎，谨慎，55555</p></body></html>]]></content>
      
      
      <categories>
          
          <category> bug记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go电商项目笔记</title>
      <link href="/2023/12/05/Go%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/05/Go%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h1><ul><li>metadata</li></ul><h2 id="proto生成grpc对应的代码"><a href="#proto生成grpc对应的代码" class="headerlink" title="proto生成grpc对应的代码:"></a>proto生成grpc对应的代码:</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go-grpc_out=./ *.proto</span><br></pre></td></tr></tbody></table></figure><h2 id="proto同步文件可能遇到的坑"><a href="#proto同步文件可能遇到的坑" class="headerlink" title="proto同步文件可能遇到的坑"></a>proto同步文件可能遇到的坑</h2><p>假如说对于客户端的proto:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message HelloRequest {</span><br><span class="line">    string name = 1;</span><br><span class="line">    string url = 2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而对于服务端是这样的:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message HelloRequest {</span><br><span class="line">    string url = 1;</span><br><span class="line">    string name = 2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么就会引发接受到的顺序和发送的顺序不一致的问题，==并且比较坑的是不会报错==</p><h1 id="YAPI部署"><a href="#YAPI部署" class="headerlink" title="YAPI部署"></a>YAPI部署</h1><p>靠，这个地方有点坑啊，我一直部署的1.4.1怎么都部署不好，然后给切换为了1.4.2，就好了！！！<strong>并且注意，如果用的是内网穿透来做的话，数据库端口要填27016，就是和frpc.ini保持一致</strong></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231231110008320.png" alt="image-20231231110008320"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231231110148547.png" alt="image-20231231110148547"></p><p>部署成功显示:</p><blockquote><p>初始化管理员账号成功,账号名：”<a href="mailto:admin@admin.com">admin@admin.com</a>“，密码：”ymfe.org”</p><p>部署成功，请切换到部署目录，输入： “node vendors/server/app.js” 指令启动服务器, 然后在浏览器打开 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000</a> 访问</p></blockquote><h1 id="Gorm"><a href="#Gorm" class="headerlink" title="Gorm"></a>Gorm</h1><p>IORM全称是:Object Relational Mapping(对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据<br>库中表的概念对应起来。举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中<br>的一条记录</p><p>gorm在学习的过程中要特别的小心注意，你写的gorm语句对应的生成的sql的命令是什么样子的。</p><h1 id="ZAP"><a href="#ZAP" class="headerlink" title="ZAP"></a>ZAP</h1><p>高性能的日志</p><h1 id="viper"><a href="#viper" class="headerlink" title="viper"></a>viper</h1><p>配置文件使用</p><h1 id="base64Captcha"><a href="#base64Captcha" class="headerlink" title="base64Captcha"></a>base64Captcha</h1><p>图形验证码</p><h1 id="nacos"><a href="#nacos" class="headerlink" title="nacos"></a>nacos</h1><p>docker一键启动：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run --name nacos-standalone -e MODE=standalone -e JVM_XMS=512m -e JVM_XMX=512m -e JVM_XMN=256M -p 8848:8848 -d nacos/nacos-server:1.3.2</span><br></pre></td></tr></tbody></table></figure><p>访问：</p><p><a href="http://124.71.35.233:8848/nacos/index.html">http://124.71.35.233:8848/nacos/index.html</a><br>用户名密码: nacos/nacos</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ul><li>什么是json web token？</li><li>跨域问题是这么产生的，后端如何解决跨域问题？</li></ul><h1 id="完成一个项目的pipeline工作"><a href="#完成一个项目的pipeline工作" class="headerlink" title="完成一个项目的pipeline工作"></a>完成一个项目的pipeline工作</h1><ol><li>技术选型：比如选哪个log库类似的</li><li>。。。</li><li>需求分析-&gt;表结构设计</li><li>。。。</li><li>项目重构</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 网课学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闪记卡词条</title>
      <link href="/2023/11/28/%E9%97%AA%E8%AE%B0%E5%8D%A1%E8%AF%8D%E6%9D%A1/"/>
      <url>/2023/11/28/%E9%97%AA%E8%AE%B0%E5%8D%A1%E8%AF%8D%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>三个编程范式</td><td><strong>结构化编程(structured programming)<strong>、</strong>面向对象编程(object-oriented programming)<strong>以及</strong>函数式编程(functional programming)</strong></td></tr><tr><td>==设计原则——SRP：单一职责原则==</td><td>每个软件模块都有且只有一个需要被改变的理由</td></tr><tr><td>==设计原则——OCP：开闭原则==</td><td>设计良好的计算机软件应该易于扩展，同时抗拒修改。如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。</td></tr><tr><td>==设计原则——LSP：里氏替换原则==</td><td>任何基类可以出现的地方，子类一定可以出现。正方形/长方形问题是一个著名（或者说臭名远扬）的<strong>违反</strong>LSP的设计案例</td></tr><tr><td>==设计原则——ISP：接口隔离原则==</td><td>可以说是最小接口原则，客户不应该依赖它们用不到的方法，只给每个客户它所需要的接口。换句话说，就是不能强迫用户去依赖那些他们不使用的接口。告诫软件设计师应该在设计中避免不必要的依赖。</td></tr><tr><td>==设计原则——DIP：依赖反转原则==</td><td>该设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。</td></tr><tr><td>黑盒测试</td><td>黑盒测试是一种重要的测试策略，又称为数据驱动的测试或输入/输出驱动的测试。使用这种测试方法时，<strong>将程序视为一个黑盒子。测试目标与程序的内部机制和结构完全无关，而是将重点集中放在发现程序不按其规范正确运行的环境条件。</strong></td></tr><tr><td>白盒测试</td><td>白盒测试或称逻辑驱动的测试，允许我们检查程序的内部结构。这种测试策略对程序的逻辑结构进行检查，从中获取测试数据（遗憾的是，常常忽略了程序的规范）。</td></tr><tr><td>SOLID原则</td><td>单一原则、开闭原则、里氏替换原则、接口隔离原则、依赖倒置原则。</td></tr><tr><td>热代码</td><td>通常只有一部分代码会被经常执行，而应用的性能主要取决于这些代码执行得有多快。这些关键代码段被称为应用的热点代码，代码执行得越多就被认为是越热。故与之相对的就是冷代码了。</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="Go相关"><a href="#Go相关" class="headerlink" title="Go相关"></a>Go相关</h1><table><thead><tr><th>概念</th><th>解释</th></tr></thead><tbody><tr><td>路由分组</td><td>gin库：比如说对于/goods/pen,/goods/book,/goods/apple都属于goods下面的，我们就可以对他们进行一个分组的操作:<img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231204214422426.png" alt="image-20231204214422426"></td></tr><tr><td>Go编译器的源码搜索路径空间是什么？</td><td>每个包源码文件头部的包导入路径和基础搜索路径，</td></tr><tr><td>import 后面的部分是什么？</td><td>源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段也不是包名。不过虽然如此，最好包导入路径的最后一段目录名最好与包名一致；当包名和包导入路径的最后一个目录名不同时，最好通过rename的方式显式的把包名放入到包导入语句中。</td></tr><tr><td>如何解决包名冲突的问题？</td><td>用为包导入路径下的包显式指定包名的方法</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="20231206"><a href="#20231206" class="headerlink" title="20231206"></a>20231206</h1><ol><li>RPC四种模式？</li></ol><p>简单模式：客户端请求一次，服务端响应一次。</p><p>服务端数据流模式：客户端发送一次请求，服务端返回一段数据流。</p><p>客户端数据流模式：客户端源源不断的向服务端发送数据流，而在发送结束后，由服务端返回一个响应。</p><p>双向数据流模式：顾名思义，这是客户端和服务端都可以向对方发送数据流，这个时候双方<br>的数据可以同时互相发送，也就是可以实现实时交互。典型的例子是聊天机<br>器人。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 琐碎知识记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业软件开发人员必须精通的事项</title>
      <link href="/2023/11/22/%E4%B8%93%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E7%B2%BE%E9%80%9A%E7%9A%84%E4%BA%8B%E9%A1%B9/"/>
      <url>/2023/11/22/%E4%B8%93%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E7%B2%BE%E9%80%9A%E7%9A%84%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>以下内容摘抄自《代码整洁之道：程序员的职业素养》</p><blockquote><p>设计模式。必须能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验。</p><p>设计原则。必须了解SOLID原则，而且要深刻理解组件设计原则。</p><p>方法。必须理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等。</p><p>实践。必须掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程。</p><p>工件。必须了解如何使用UML图、DFD图、结构图、Petri网络图、状态迁移图表、流程图和决策表。</p></blockquote><p>有空展开写写</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robert C. Martin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《代码整洁之道：程序员的职业素养》笔记</title>
      <link href="/2023/11/22/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/22/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="译者序1：享受职业素养"><a href="#译者序1：享受职业素养" class="headerlink" title="译者序1：享受职业素养"></a>译者序1：享受职业素养</h2><ul><li><p>因为我们需要招聘的不是“经历丰富”的人，而是“有职业素养”的人。你遇到的问题可能很容易也可能很难，但我看重的并不是问题的难度，而是解决问题的方式、步骤以及反思的程度。</p></li><li><p>与问题本身的难度相比，解决问题的方式、步骤以及反思的程度，才能体现出一个人的职业素养</p></li><li><p>基本技能不够熟练，当然谈不上职业素养。但是仅仅能迅速地编写代码，却不关心代码背后的意义，不能迅速判断、解决程序运行中的各种问题，不能自信满满地为自己交付的程序承担责任，同样是与职业素养绝缘的</p></li><li><p>（说“是”时）你对自己将会做某件事做了清晰的事实陈述，而且还明确说明了完成期限。那不是指别人，而是指你自己。你陈述的是自己会去执行的一项行动，而且，你不是“可能”去做，或是“可能做到”，而是“会”做到。</p></li><li><p>这两个项目之所以会搞砸，因为开发人员没有坚决抵制各种不专业的需求（比如一些无关紧要但成本巨大的需求），抵制各种不专业的行为（比如为了赶工期而降低对程序质量的要求），最终只好喝下自己酿出的苦酒。</p></li><li><p>花三分的力气去抵制无理的需求，可以节省十分甚至二十分的开发时间</p></li></ul><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ul><li>Joe并不信任我们，只有对技术团队进行微观管理才能让他安心。而与此同时，出于某种原因，他确实能够信任法务团队，也并没有要对他们进行微观管理的想法。这一切说明了什么问题？法务团队肯定以某种方式展现了他们的专业精神，而技术团队尚未做到这点。</li></ul><p>技术人员需要如何改变才能被视为专业人士呢</p><h2 id="必读引言"><a href="#必读引言" class="headerlink" title="必读引言"></a>必读引言</h2><ul><li>后来，我曾经因为粗心耽误了关键日期被炒鱿鱼，因为不小心向客户泄露机密数据几乎被炒鱿鱼。我曾经领导过毫无成功希望的项目，看着它垮掉，明知需要他人帮助却无动于衷。我曾经好强地固守自己的技术决策，即便这些决策在客户的需求面前黯然失色。我曾经雇用完全不合适的人，让我的老板背上沉重的负担。最糟糕的是，因为我领导无方，其他两个人被炒了鱿鱼。</li></ul><h2 id="第1章-专业主义"><a href="#第1章-专业主义" class="headerlink" title="第1章 专业主义"></a>第1章 专业主义</h2><ul><li><p>发布软件时，你应该确保QA找不出任何问题。故意发送明知有缺陷的代码，这种做法是极其不专业的。<strong>什么样的代码是有缺陷的呢？那些你没把握的代码都是！</strong></p></li><li><p>你怎么知道代码能否常运行呢？很简单，测试！一遍遍地测，翻来覆去、颠来倒去地测，使出浑身解数来测！</p></li><li><p>但是有些代码不是很难测试吗？是的，但之所以很难测试，是因为设计时就没考虑如何测试。唯一的解决办法就是要设计易于测试的代码，最好是先写测试，再写要测的代码。</p></li><li><p>要想证明软件易于修改，唯一办法就是做些实际的修改。如果发现这些改动并不像你预想的那样简单，你便应该改进设计，使后续修改变简单。</p></li><li><p>为什么大多数开发人员不敢不断修改他的代码呢？因为他们害怕会改坏代码！为什么会有这样的担心呢？因为他们没做过测试。</p></li><li><p>不能铭记过去的人，注定要重蹈覆辙。</p></li></ul><p>==下面列出了每个专业软件开发人员必须精通的事项。==</p><p>==下面列出了每个专业软件开发人员必须精通的事项。==</p><p>==下面列出了每个专业软件开发人员必须精通的事项。==</p><p>#TODO有空写个博客展开写下这个</p><blockquote><p>设计模式。必须能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验。</p><p>设计原则。必须了解SOLID原则，而且要深刻理解组件设计原则。</p><p>方法。必须理解XP、Scrum、精益、看板、瀑布、结构化分析及结构化设计等。</p><p>实践。必须掌握测试驱动开发、面向对象设计、结构化编程、持续集成和结对编程。</p><p>工件。必须了解如何使用UML图、DFD图、结构图、Petri网络图、状态迁移图表、流程图和决策表。</p></blockquote><h2 id="第2章-说“不”"><a href="#第2章-说“不”" class="headerlink" title="第2章 说“不”"></a>第2章 说“不”</h2><ul><li><p>专业人士敢于说明真相而不屈从于权势。专业人士有勇气对他们的经理说“不”。</p></li><li><p>面对艰难决定，直面不同角色的冲突是最好的办法。</p></li><li><p>你的经理要求你在明天之前完成登录页面，这就是他在追求和捍卫的一个目标，那是尽他的工作职责。如果你明知第二天之前不可能完成登录页面，嘴上却说“好的，我会试试的”，那么便是你失职了。这时候，尽职的唯一选择是说“不，这不可能”。</p></li><li><p>“为什么”远不如“事实”重要</p></li><li><p>许诺“尝试”，就意味着你承认自己之前未尽全力，承认自己还有余力可施。许诺“尝试”，意味着只要你再加把劲还是可以达成目标的；而且，这也是一种表示你将再接再厉去实现目标的承诺。因此，只要你许诺自己会去“尝试”，你其实是在承诺你会确保成功。这样，压力就要由你自己来扛了。如果你的“尝试”没有达成预期的结果，那就表示你失败了。</p></li><li><p>客户所要的任何一项功能，一旦写起来，总是远比它开始时所说的要复杂许多，但最终你还是会接下这些活。</p></li><li><p>成为英雄及“解决问题”的诱惑诚然巨大，只是我们要明白，牺牲专业原则以求全，并非问题的解决之道。舍弃这些原则，只会制造出更多的麻烦。</p></li></ul><h2 id="第3章-说“是”"><a href="#第3章-说“是”" class="headerlink" title="第3章 说“是”"></a>第3章 说“是”</h2><ul><li><p>做出承诺，包含三个步骤。（1）口头上说自己将会去做。（2）心里认真对待做出的承诺。（3）真正付诸行动。</p></li><li><p>我们有竭力逃避承担责任的倾向。</p></li><li><p>识别真正承诺的诀窍在于，要去搜寻与下列相似的语句：我将在……之前……（例如，我将在周二之前完成这个任务。）</p></li><li><p>你只能承诺自己能完全掌控的事。</p></li><li><p>如果你无法兑现承诺，那么最重要的就是尽早向你的承诺对象发出预警，越快越好，越早越好。</p></li><li><p>如果是专业开发人员，就不会放弃底线。</p></li></ul><h2 id="第4章-编码"><a href="#第4章-编码" class="headerlink" title="第4章 编码"></a>第4章 编码</h2><ul><li><p>能够感知到错误确实非常重要。不只对“录入”是这样，对于一切事情莫不如此。具备“出错感知能力”，说明你已经能够非常迅速地获得反馈，能够更为快速地从错误中学习。</p></li><li><p>我发现，要精熟掌握每项技艺，关键都是要具备“信心”和“出错感知”能力。</p></li><li><p>一些曾经进入这种状态但终又从中摆脱出来的人给出了一点儿忠告：避免进入流态区。这种意识状态并非真的极为高效，也绝非毫无错误。这其实只是一种“浅层冥想”状态，在这种状态下，为了追求所谓的速度，理性思考的能力会下降。</p></li><li><p>结对编程最大的一个好处在于，结对中的任一方都不可能进入流态区。流态区是一种与世隔绝的状态，而结对则要求持续密切地进行沟通。</p></li><li><p>当坐到别人旁边的时候，本来挡住去路的问题忽然就会消失了。和别人一起工作时，会发生一种生理上的变化。我不知道这种变化是什么，但是我能够真切感知到这种变化。在我的大脑或身体中会发生一些化学变化，这种变化能帮助我冲破阻塞继续前进。</p></li><li><p><strong>衡量你是否是一名专业人士的一个重要方面，便是看你是否能将调试时间尽量降到最低。绝对的零调试时间是一个理想化的目标，无法达到，但要将之作为努力方向。</strong></p></li><li><p>管理延迟的诀窍，便是早期检测和保持透明。最糟糕的情况是，你一直都在告诉每个人你会按时完成工作，到最后期限来临前你还在这样说，但最终你只能让他们大失所望。不要这么做。相反，要根据目标定期衡量进度，使用三个考虑到多种因素的期限[8]：乐观预估、标称预估、悲观预估。</p></li><li><p>如果可怜的开发人员在压力之下最终屈服，同意尽力赶上截止日期，结局会十分悲惨。那些开发人员会开始抄近路，会额外加班加点工作，抱着创造奇迹的渺茫希望。</p></li><li><p><strong>在程序员所能表现的各种不专业行为中，最糟糕的是明知道还没有完成任务却宣称已经完成。</strong></p></li><li><p>如果有人向你伸出援手，要诚挚接受，心怀感激地接受帮助并诚意合作。</p></li><li><p><strong>花时间手把手地辅导年轻程序员是资深程序员的专业职责所在。同样道理，向资深导师寻求辅导也是年轻程序员的专业职责。</strong></p></li></ul><h2 id="第5章-测试驱动开发"><a href="#第5章-测试驱动开发" class="headerlink" title="第5章 测试驱动开发"></a>第5章 测试驱动开发</h2><p>==TDD三项法则==</p><p>（1）在编好失败单元测试之前，不要编写任何产品代码。</p><p>（2）只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败情况。（3）产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。</p><p>遵循这三项法则的话，大概30秒钟就要运行一次代码。先写好一个单元测试的一小部分代码，很快，你会发现还缺少一些类或函数，所以单元测试无法编译。因此必须编写产品代码，让这些测试能够编译成功。产品代码够用即可，然后再回头接着写单元测试代码。</p><p>事后写的测试只是一种防守。而先行编写的测试则是进攻，事后编写测试的作者已经受制于已有代码，他已经知道问题是如何解决的。与采用测试先行的方式编写的测试代码比起来，后写的测试在深度和捕获错误的灵敏度方面要逊色很多。</p><h2 id="第6章-练习"><a href="#第6章-练习" class="headerlink" title="第6章 练习"></a>第6章 练习</h2><ul><li>卡塔是一套设计好的、用来模拟搏斗一方的招式。目标则是要逐步把整套招式练习到纯熟。习武者努力训练自己的身体来熟悉每一招，把它们连贯成流畅的套路。训练有素的卡塔看起来相当漂亮。</li><li>无论如何，专业人士都需要练习。他们这么做，是因为他们关心自己能做到的最好结果。更重要的是，他们用自己的时间练习，因为他们知道保持自己的技能不落伍是自己的责任，而不是雇主的责任。练习的时候你是赚不到钱的，但是练习之后，你会获得回报，而且是丰厚的回报。</li></ul><h2 id="第7章-验收测试"><a href="#第7章-验收测试" class="headerlink" title="第7章 验收测试"></a>第7章 验收测试</h2><ul><li><p>在工作中，有一种现象叫观察者效应，或者不确定原则。每次你向业务方展示一项功能，他们就获得了比之前更多的信息，这些新信息反过来又会影响他们对整个系统的看法。最终结果就是，需求完成得越精细，就越容易被忽视，系统因此也谈不上完工。</p></li><li><p>需求文档中的每一点模糊之处，都对应着业务方的一点分歧。当然，模糊不只来自于分歧或争论。有时候，业务方会想当然地认为看文档的人懂得自己的意思。</p></li></ul><h2 id="第9章-时间管理"><a href="#第9章-时间管理" class="headerlink" title="第9章 时间管理"></a>第9章 时间管理</h2><ul><li><p>如果会议让人厌烦，就离席。</p></li><li><p>“凡是不能在5分钟内解决的争论，都不能靠辩论解决。”争论之所以要花这么多时间，是因为各方都拿不出足够有力的证据。所以这类争论依据的不是事实，而是信念。</p></li><li><p>忧虑和分心也会消耗注意力点数。</p></li><li><p>在走入死胡同时可以迅速意识到，并有足够的勇气走回头路。</p></li><li><p>坑法则（The Rule of Holes）：如果你掉进了坑里，别挖。</p></li></ul><h2 id="第10章-预估"><a href="#第10章-预估" class="headerlink" title="第10章 预估"></a>第10章 预估</h2><ul><li><p>专业开发人员不随便承诺，除非他们确切知道可以完成。道理就是这么简单。</p></li><li><p>控制错误的办法之一是使用大数定律。该定律的意思是：<strong>把大任务分成许多小任务，分开预估再加总，结果会比单独评估大任务要准确很多。这样做之所以能提高准确度，是因为小任务的预估错误几乎可以忽略，不会对总的结果产生明显影响。</strong></p></li></ul><h2 id="第11章-压力"><a href="#第11章-压力" class="headerlink" title="第11章 压力"></a>第11章 压力</h2><ul><li><p>他知道这些是他赖以战胜由最后期限和承诺所带来的压力感的最好方法。</p></li><li><p>观察自己在危机时刻中的反应，就可以了解自己的信念。如果在危机中依然遵循着你守持的纪律，就说明你确实相信那些纪律。</p></li></ul><h2 id="第12章-协作"><a href="#第12章-协作" class="headerlink" title="第12章 协作"></a>第12章 协作</h2><ul><li><strong>人际关系难以应付而且毫无规律</strong>.编程用的机器则整洁，行为也可预见。如果可以一个人待在房间里数个小时沉浸在一些真正有趣的问题上，那将会是最开心的时光。</li></ul><h2 id="第14章-辅导、学徒期与技艺"><a href="#第14章-辅导、学徒期与技艺" class="headerlink" title="第14章 辅导、学徒期与技艺"></a>第14章 辅导、学徒期与技艺</h2><ul><li><p>成熟工匠手脚麻利，从容淡定，他们能够做出合情合理的估算并遵守承诺。工匠知道何时该说“不”，但他们更懂得如何承诺。成熟工匠可以算是专业人士。</p></li><li><p><strong>技艺是工匠所持的精神状态。技艺的“模因”（meme[6]）中包含着价值观、原则、技术、态度和正见。</strong></p></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robert C. Martin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《架构整洁之道》笔记</title>
      <link href="/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="推荐序一"><a href="#推荐序一" class="headerlink" title="推荐序一"></a>推荐序一</h2><p>我们把这些有“洁癖”、有工匠精精、有修养的程序员叫作工程师，工程师不仅仅是在编写代码，他们会用工程的方法来编写代码，以便让编程开发更为高效和快速。他们把编程当成一种设计，一种工业设计，把代码模块化，让这些模块可以更容易地交互拼装和组织，让代码排列整齐——阅读和维护这些代码就像看阅兵式一样舒心畅快。</p><h2 id="推荐序二-久远的教诲，古老的智慧"><a href="#推荐序二-久远的教诲，古老的智慧" class="headerlink" title="推荐序二 久远的教诲，古老的智慧"></a>推荐序二 久远的教诲，古老的智慧</h2><p>避免随意使用goto，使用if-else、switch-case之类控制语句和函数、子函数组织起来的程序代码，可以保证程序的结构是清楚的，自顶向下层层细化，消灭了杂错，杜绝了混淆。</p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>软件架构学关注的的一个重点是组织结构(structure)。不管是讨论组件(Component)、类(Class)、函数(Function)、模块(Module)，还是层级(Layer)、服务(Service)以及微观与宏观的软件开发过程，软件的组织结构都是我们的主要关注点。</p><h3 id="第1章-设计与架构究竟是什么"><a href="#第1章-设计与架构究竟是什么" class="headerlink" title="第1章 设计与架构究竟是什么"></a>第1章 设计与架构究竟是什么</h3><ul><li><strong>软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。</strong></li><li>一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。如果该成本很低，并且在系统的整个生命周期内一直都能维持这样的低成本，那么这个系统的设计就是优良的。</li></ul><h3 id="第2章-两个价值维度"><a href="#第2章-两个价值维度" class="headerlink" title="第2章 两个价值维度"></a>第2章 两个价值维度</h3><ul><li><p>行为价值：大部分程序员认为这就是他们的全部工作。他们的工作是且仅是：按照需求文档编写代码，并且修复任何Bug。这真是大错特错。</p></li><li><p>架构价值：为了达到软件的本来目的，软件系统必须够“软”——也就是说，软件应该容易被修改。当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便地实现。</p></li><li><p>如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为0。</p></li><li><p>软件系统的第一个价值维度：<strong>系统行为</strong>，是紧急的，但是并不总是特别重要。软件系统的第二个价值维度：<strong>系统架构</strong>，是重要的，但是并不总是特别紧急。</p></li></ul><p>==艾森豪威尔矩阵==</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122204108331.png" alt="image-20231122204108331"></p><h2 id="第2部分-从基础构件开始：编程范式"><a href="#第2部分-从基础构件开始：编程范式" class="headerlink" title="第2部分 从基础构件开始：编程范式"></a>第2部分 从基础构件开始：编程范式</h2><ul><li><strong>编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。这些范式会告诉你应该在什么时候采用什么样的代码结构。</strong></li></ul><h3 id="第3章-编程范式总览"><a href="#第3章-编程范式总览" class="headerlink" title="第3章 编程范式总览"></a>第3章 编程范式总览</h3><p>三个编程范式，它们分别是**结构化编程(structured programming)<strong>、</strong>面向对象编程(object-oriented programming)<strong>以及</strong>函数式编程(functional programming)**。</p><ul><li><p>结构化编程对程序控制权的直接转移进行了限制和规范。</p></li><li><p>面向对象编程对程序控制权的间接转移进行了限制和规范。</p></li><li><p>函数式编程对程序中的赋值进行了限制和规范。</p></li><li><p>每个编程范式的目的都是设置限制。这些范式主要是为了告诉我们不能做什么，而不是可以做什么。</p></li><li><p><strong>这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</strong></p></li></ul><h3 id="第4章-结构化编程"><a href="#第4章-结构化编程" class="headerlink" title="第4章 结构化编程"></a>第4章 结构化编程</h3><ul><li>结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。</li><li>无论在哪一个层面上，从最小的函数到最大组件，软件开发的过程都和科学研究非常类似，它们都是由证伪驱动的。软件架构师需要定义可以方便地进行证伪（测试）的模块、组件以及服务。</li></ul><h3 id="第5章-面向对象编程"><a href="#第5章-面向对象编程" class="headerlink" title="第5章 面向对象编程"></a>第5章 面向对象编程</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122204725715.png" alt="image-20231122204725715"></p><ul><li><p>请注意模块ML1和接口I在源代码上的依赖关系（或者叫继承关系），该关系的方向和控制流正好是相反的，我们称之为依赖反转。这种反转对软件架构设计的影响是非常大的。</p></li><li><p>通过这种（多态）方法，软件架构师可以完全控制采用了面向对象这种编程方式的系统中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者被调用，软件架构师都可以随意更改源代码依赖关系。</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122205041012.png" alt="image-20231122205041012"></p><ul><li>面向对象编程到底是什么？然而对一个软件架构师来说，其含义应该是非常明确的：<strong>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力</strong></li></ul><h3 id="第6章-函数式编程"><a href="#第6章-函数式编程" class="headerlink" title="第6章 函数式编程"></a>第6章 函数式编程</h3><ul><li><p>作为一个软件架构师，当然应该要对并发问题保持高度关注。我们需要确保自己设计的系统在多线程、多处理器环境中能稳定工作。</p></li><li><p>一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。</p></li><li><p>如果我们有足够大的存储量和处理能力，应用程序就可以用完全不可变的、纯函数式的方式来编程。</p></li><li><p>三个编程范式都对程序员提出了新的限制。每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。也就是说，我们过去50年学到的东西主要是——什么不应该做。我们必须面对这种不友好的现实：软件构建并不是一个迅速前进的技术。今天构建软件的规则和1946年阿兰·图灵写下电子计算机的第一行代码时是一样的。尽管工具变化了，硬件变化了，但是软件编程的核心没有变。</p></li></ul><h2 id="第3部分-设计原则"><a href="#第3部分-设计原则" class="headerlink" title="第3部分 设计原则"></a>第3部分 设计原则</h2><blockquote><p>一般情况下，我们为软件构建中层结构的主要目标如下：使软件可容忍被改动。使软件更容易被理解。构建可在多个软件系统中复用的组件。</p></blockquote><ul><li><p>SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类，以及如何将这些类链接起来成为程序。</p></li><li><p>==SRP：单一职责原则==。该设计原则是基于康威定律(Conway’s Law)[插图]的一个推论——一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有一个需要被改变的理由。</p></li><li><p>==OCP：开闭原则==。该设计原则是由Bertrand Meyer在20世纪80年代大力推广的，其核心要素是：如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。</p></li><li><p>==LSP：里氏替换原则==。该设计原则是Barbara Liskov在1988年提出的一个著名的子类型定义。简单来说，这项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换，就是说<strong>任何基类可以出现的地方，子类一定可以出现</strong>。</p></li><li><p>==ISP：接口隔离原则==。这项设计原则主要告诫软件设计师应该在设计中避免不必要的依赖。</p></li><li><p>==DIP：依赖反转原则==。该设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。</p></li></ul><h3 id="第7章-SRP：单一职责原则"><a href="#第7章-SRP：单一职责原则" class="headerlink" title="第7章 SRP：单一职责原则"></a>第7章 SRP：单一职责原则</h3><p>以下是三种相同的表述:</p><blockquote><p>任何一个软件模块都应该有且仅有一个被修改的原因。</p><p>任何一个软件模块都应该只对一个用户(User)或系统利益相关者(Stakeholder)负责。</p><p>任何一个软件模块都应该只对某一类行为者负责</p></blockquote><p>单一职责原则主要讨论的是函数和类之间的关系——但是它在两个讨论层面上会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则(Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心(Axis of Change)。我们在接下来的章节中会深入学习这些原则。</p><h3 id="第8章-OCP：开闭原则"><a href="#第8章-OCP：开闭原则" class="headerlink" title="第8章 OCP：开闭原则"></a>第8章 OCP：开闭原则</h3><ul><li><p>设计良好的计算机软件应该易于扩展，同时抗拒修改。</p></li><li><p>一个好的软件架构设计师会努力将旧代码的修改需求量降至最小，甚至为0。</p></li><li><p>我们可以先将满足不同需求的代码分组（即SRP），然后再来调整这些分组之间的依赖关系（即DIP）</p></li><li><p>如果A组件不想被B组件上发生的修改所影响，那么就应该让B组件依赖于A组件。</p></li><li><p>软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些互相隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改而受到影响。</p></li><li><p><strong>OCP是我们进行系统架构设计的主导原则</strong>，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围</p></li></ul><h3 id="第9章-LSP：里氏替换原则"><a href="#第9章-LSP：里氏替换原则" class="headerlink" title="第9章 LSP：里氏替换原则"></a>第9章 LSP：里氏替换原则</h3><ul><li><p>可替换性：如果对于每个类型是S的对象o1都存在一个类型为T的对象o2，能使操作T类型的程序P在用o2替换o1时行为保持不变，我们就可以将S称为T的子类型。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210636930.png"></p></li></ul><p>正方形/长方形问题是一个著名（或者说臭名远扬）的违反LSP的设计案例,在这个案例中，Square类并不是Rectangle类的子类型，因为Rectangle类的高和宽可以分别修改，而Square类的高和宽则必须一同修改。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210751691.png" alt="image-20231122210751691"></p><ul><li>LSP可以且应该被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。</li></ul><h3 id="第10章-ISP：接口隔离原则"><a href="#第10章-ISP：接口隔离原则" class="headerlink" title="第10章 ISP：接口隔离原则"></a>第10章 ISP：接口隔离原则</h3><ul><li>在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。</li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210912274.png" alt="image-20231122210912274"></p><h3 id="第11章-DIP：依赖反转原则"><a href="#第11章-DIP：依赖反转原则" class="headerlink" title="第11章 DIP：依赖反转原则"></a>第11章 DIP：依赖反转原则</h3><ul><li><p><strong>如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。</strong></p></li><li><p>优秀的软件设计师和架构师会花费很大精力来设计接口，以减少未来对其进行改动。毕竟争取在不修改接口的情况下为软件增加新的功能是软件设计的基础常识。</p></li><li><p>如果想要在软件架构设计上追求稳定，就必须多使用稳定的抽象接口，少依赖多变的具体实现。</p></li><li><p>应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。</p></li><li><p>对象的创建过程也应该受到严格限制，对此，我们通常会选择用抽象工厂(abstract factory)这个设计模式。</p></li><li><p>不要在具体实现类上创建衍生类。</p></li><li><p>不要覆盖(override)包含具体实现的函数</p></li><li><p>应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字</p></li></ul><h2 id="第4部分-组件构建原则"><a href="#第4部分-组件构建原则" class="headerlink" title="第4部分 组件构建原则"></a>第4部分 组件构建原则</h2><p><strong>如果说SOLID原则是用于指导我们如何将砖块砌成墙与房间的，那么组件构建原则就是用来指导我们如何将这些房间组合成房子的。</strong></p><h3 id="第12章-组件"><a href="#第12章-组件" class="headerlink" title="第12章 组件"></a>第12章 组件</h3><ul><li><p>组件都是该软件在部署过程中的最小单元</p></li><li><p>设计良好的组件都应该永远保持可被独立部署的特性，这同时也意味着这些组件应该可以被单独开发。</p></li></ul><h3 id="第13章-组件聚合"><a href="#第13章-组件聚合" class="headerlink" title="第13章 组件聚合"></a>第13章 组件聚合</h3><ul><li>究竟是哪些类应该被组合成一个组件呢？这是一个非常重要的设计决策，应该遵循优秀的软件工程经验来行事。但不幸的是，很多年以来，我们对于这么重要的决策经常是根据当下面临的实际情况临时拍脑门决定的。</li></ul><p>三个与构建组件相关的基本原则：</p><p>==REP：复用/发布等同原则。CCP：共同闭包原则。CRP：共同复用原则。==</p><ul><li><p>软件复用的最小粒度应等同于其发布的最小粒度。</p></li><li><p><strong>REP原则</strong>就是指组件中的类与模块必须是彼此紧密相关的。也就是说，一个组件不能由一组毫无关联的类和模块组成，它们之间应该有一个共同的主题或者大方向。</p></li><li><p><strong>CCP</strong>的主要作用就是提示我们要将所有可能会被一起修改的类集中在一处。也就是说，如果两个类紧密相关，不管是源代码层面还是抽象理念层面，永远都会一起被修改，那么它们就应该被归属为同一个组件。通过遵守这个原则，我们就可以有效地降低因软件发布、验证及部署所带来的工作压力。</p></li><li><p>对大部分应用程序来说，可维护性的重要性要远远高于可复用性。</p></li><li><p><strong>CCP原则</strong>实际上就是SRP原则的组件版。在SRP原则的指导下，我们将会把变更原因不同的函数放入不同的类中。而CCP原则指导我们应该将变更原因不同的类放入不同的组件中。</p></li><li><p>不要强迫一个组件的用户依赖他们不需要的东西。**共同复用原则(CRP)**是另外一个帮助我们决策类和模块归属于哪一个组件的原则。该原则建议我们将经常共同复用的类和模块放在同一个组件中。</p></li><li><p>由于这种依赖关系的存在，每当被引用组件发生变更时，引用它的组件一般也需要做出相应的变更。即使它们不需要进行代码级的变更，一般也免不了需要被重新编译、验证和部署。哪怕引用组件根本不关心被引用组件中的变更，也要如此。</p></li><li><p>在CRP原则中，关于哪些类不应该被放在一起的建议是其更为重要的内容</p></li><li><p>CRP原则实际上是ISP原则的一个普适版。ISP原则是建议我们不要依赖带有不需要的函数的类，而CRP原则则是建议我们不要依赖带有不需要的类的组件。可以总结为：<strong>不要依赖不需要用到的东西。</strong></p></li></ul><p>==一张组件聚合三大原则的张力图==</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122211753671.png" alt="image-20231122211753671"></p><p>一般来说，一个软件项目的重心会从该三角区域的右侧开始，先期主要牺牲的是复用性。然后，随着项目逐渐成熟，其他项目会逐渐开始对其产生依赖，项目重心就会逐渐向该三角区域的左侧滑动。换句话说，一个项目在组件结构设计上的重心是根据该项目的开发时间和成熟度不断变动的，我们对组件结构的安排主要与项目开发的进度和它被使用的方式有关，与项目本身功能的关系其实很小。</p><h3 id="第14章-组件耦合"><a href="#第14章-组件耦合" class="headerlink" title="第14章 组件耦合"></a>第14章 组件耦合</h3><ul><li><p><strong>组件依赖关系图中不应该出现环。</strong></p></li><li><p>“一觉醒来综合征”的解决方法：第一种是“每周构建”，第二种是“无依赖环原则(ADP)”。</p></li><li><p>每当一个组件发布新版本时，其他依赖这个组件的团队都可以自主决定是否立即采用新版本。若不采用，该团队可以选择继续使用旧版组件，直到他们准备好采用新版本为止。</p></li><li><p>我们可以打破这些组件中的循环依赖，并将其依赖图转化为DAG。目前有以下两种主要机制可以做到这件事情：1.应用依赖反转原则(DIP)：2.创建一个新的组件；</p></li><li><p>根据上述讨论，我们可以得出一个无法逃避的结论：组件结构图是不可能自上而下被设计出来的。它必须随着软件系统的变化而变化和扩张，而不可能在系统构建的最初就被完美设计出来。</p></li><li><p>人们也普遍认为项目粗粒度的组件分组规则所产生的就是组件的依赖结构，也应该在某种程度上与项目的系统功能分解的结果相互对应</p></li><li><p>组件依赖结构图并不是用来描述应用程序功能的，它更像是应用程序在构建性与维护性方面的一张地图</p></li><li><p>如果我们在设计具体类之前就来设计组件依赖关系，那么几乎是必然要失败的。</p></li><li><p><strong>依赖关系必须要指向更稳定的方向。</strong></p></li><li><p><strong>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖，否则这个多变的组件也将会变得非常难以被修改。</strong></p></li><li><p>让软件组件难于修改的一个最直接的办法就是让很多其他组件依赖于它。带有许多入向依赖关系的组件是非常稳定的，因为它的任何变更都需要应用到所有依赖它的组件上，比如下图的X</p></li></ul><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231128193729125.png" alt="image-20231128193729125"></p><ul><li><p>稳定性指标：</p><ul><li><strong>Fan-in：入向依赖</strong>，这个指标指代了组件外部类依赖于组件内部类的数量。</li><li><strong>Fan-out：出向依赖</strong>，这个指标指代了组件内部类依赖于组件外部类的数量。</li><li>**I：不稳定性，I=Fan-out/(Fan-in+Fan-out)**。该指标的范围是[0,1],I=0意味着组件是最稳定的，I=1意味着组件是最不稳定的。</li></ul></li><li><p><strong>稳定依赖原则(SDP)的要求是让每个组件的I指标都必须大于其所依赖组件的I指标。也就是说，组件结构依赖图中各组件的I指标必须要按其依赖关系方向递减。</strong></p></li><li><p>我们设计组件架构图的目的就是要决定应该让哪些组件稳定，让哪些组件不稳定。</p></li><li><p>动态类型语言中的依赖关系是非常简单的，因为其依赖反转的过程并不需要声明和继承接口。</p></li><li><p>==稳定抽象原则（SAP）==：一个组件的抽象化程度应该与其稳定性保持一致。</p></li><li><p>抽象程度的衡量：假设A指标是对组件抽象化程度的一个衡量，它的值是组件中抽象类与接口所占的比例。那么：Nc：组件中类的数量。Na：组件中抽象类和接口的数量。A：抽象程度，A=Na÷Nc。A指标的取值范围是从0到1，值为0代表组件中没有任何抽象类，值为1就意味着组件中只有抽象类。</p></li></ul><h2 id="第5部分-软件架构"><a href="#第5部分-软件架构" class="headerlink" title="第5部分 软件架构"></a>第5部分 软件架构</h2><h3 id="第15章-什么是软件架构"><a href="#第15章-什么是软件架构" class="headerlink" title="第15章 什么是软件架构"></a>第15章 什么是软件架构</h3><ul><li>软件系统的架构质量是由它的构建者所决定的，软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。</li></ul><blockquote><p>如果想设计一个便于推进各项工作的系统，其策略就是要在设计中尽可能长时间地保留尽可能多的可选项。</p></blockquote><p>==说白了就是要可扩展性要强==</p><ul><li><p>一个系统的部署成本越高，可用性就越低。</p></li><li><p>架构应该起到揭示系统运行过程的作用。</p></li><li><p>系统维护的主要成本集中在“探秘”和“风险”这两件事上。其中，“探秘(spelunking)”的成本主要来自我们对于现有软件系统的挖掘，目的是确定新增功能或被修复问题的最佳位置和最佳方式。而“风险(risk)”，则是指当我们进行上述修改时，总是有可能衍生出新的问题，这种可能性就是风险成本。</p></li><li><p>软件架构师的目标是创建一种系统形态，该形态会以策略为最基本的元素，并让细节与策略脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容。</p></li><li><p>如果在开发高层策略时有意地让自己摆脱具体细节的纠缠，我们就可以将与具体实现相关的细节决策推迟或延后，因为越到项目的后期，我们就拥有越多的信息来做出合理的决策。</p></li><li><p>一个优秀的软件架构师应该致力于最大化可选项数量。</p></li><li><p>优秀的架构师会小心地将软件的高层策略与其底层实现隔离开，让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖。</p></li><li><p>优秀的架构师所设计的策略应该允许系统尽可能地推迟与实现细节相关的决策，越晚做决策越好。</p></li></ul><h3 id="第16章-独立性"><a href="#第16章-独立性" class="headerlink" title="第16章 独立性"></a>第16章 独立性</h3><ul><li><p>一个设计良好的软件架构必须支持以下几点：系统的用例与正常运行、系统的维护、系 统的开发、系统的部署。</p></li><li><p>一个设计良好的架构在行为上对系统最重要的作用就是明确和显式地反映系统设计意图的行为，使其在架构层面上可见。</p></li><li><p>任何一个组织在设计系统时，往往都会复制出一个与该组织内沟通结构相同的系统。</p></li><li><p>设计目标一定是实现“立刻部署”。一个设计良好的架构通常不会依赖于成堆的脚本与配置文件，也不需要用户手动创建一堆“有严格要求”的目录与文件。总而言之，一个设计良好的软件架构可以让系统在构建完成之后立刻就能部署。</p></li><li><p><strong>如果我们按照变更原因的不同对系统进行解耦，就可以持续地向系统内添加新的用例，而不会影响旧有的用例。如果我们同时对支持这些用例的UI和数据库也进行了分组，那么每个用例使用的就是不同面向的UI与数据库，因此增加新用例就更不太可能会影响旧有的用例了</strong></p></li><li><p>为了在不同的服务器上运行，被隔离的组件不能依赖于某个处理器上的同一个地址空间，它们必须是独立的服务，然后通过某种网络来进行通信。许多架构师将上面这种组件称为“服务”或“微服务”，至于是前者还是后者，往往取决于某些非常模糊的代码行数阈值。对于这种基于服务来构建的架构，架构师们通常称之为<strong>面向服务的架构(service-oriented architecture)，即SOA</strong>。</p></li><li><p>如果有两段看起来重复的代码，它们走的是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两段代码就不是真正的重复。</p></li></ul><h3 id="第17章-划分边界"><a href="#第17章-划分边界" class="headerlink" title="第17章 划分边界"></a>第17章 划分边界</h3><ul><li><p>软件架构设计本身就是一门划分边界的艺术。</p></li><li><p>一个系统最消耗人力资源的是什么？答案是系统中存在的耦合——尤其是那些过早做出的、不成熟的决策所导致的耦合。</p></li><li><p>边界线应该画在那些不相关的事情中间。GUI与业务逻辑无关，所以两者之间应该有一条边界线。数据库与GUI无关，这两者之间也应该有一条边界线。数据库又与业务逻辑无关，所以两者之间也应该有一条边界线。</p></li><li><p>将系统设计为插件式架构，就等于构建起了一面变更无法逾越的防火墙。</p></li></ul><h3 id="第18章-边界剖析"><a href="#第18章-边界剖析" class="headerlink" title="第18章 边界剖析"></a>第18章 边界剖析</h3><ul><li><p>高层进程的源码中不应该包含低层进程的名字、物理内存地址或是注册表键名。</p></li><li><p>系统架构中最强的边界形式就是服务。</p></li><li><p>一个系统中通常会同时包含高通信量、低延迟的本地架构边界和低通信量、高延迟的服务边界。</p></li></ul><h3 id="第19章-策略与层次"><a href="#第19章-策略与层次" class="headerlink" title="第19章 策略与层次"></a>第19章 策略与层次</h3><ul><li><p>计算机程序不过就是一组仔细描述如何将输入转化为输出的策略语句的集合。</p></li><li><p>架构设计的工作常常需要将组件重排组合成为一个有向无环图。图中的每一个节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了一种组件之间的依赖关系，它们将不同级别的组件链接起来。</p></li><li><p>低层组件应该成为高层组件的插件</p></li></ul><h3 id="第20章-业务逻辑"><a href="#第20章-业务逻辑" class="headerlink" title="第20章 业务逻辑"></a>第20章 业务逻辑</h3><ul><li><p>业务实体这个概念只要求我们将关键业务数据和关键业务逻辑绑定在一个独立的软件模块内。</p></li><li><p>用例控制着业务实体之间的交互方式。</p></li><li><p>业务实体并不会知道是哪个业务用例在控制它们，这也是依赖反转原则(DIP)的另一个应用情景。也就是像业务实体这样的高层概念是无须了解像用例这样的低层概念的。反之，低层的业务用例却需要了解高层的业务实体。</p></li><li><p>业务逻辑是一个软件系统存在的意义，它们属于核心功能，是系统用来赚钱或省钱的那部分代码，是整个系统中的皇冠明珠。</p></li></ul><h3 id="第21章-尖叫的软件架构"><a href="#第21章-尖叫的软件架构" class="headerlink" title="第21章 尖叫的软件架构"></a>第21章 尖叫的软件架构</h3><p>软件的系统架构应该为该系统的用例提供支持。这就像住宅和图书馆的建筑计划满篇都在非常明显地凸显这些建筑的用例一样，软件系统的架构设计图也应该非常明确地凸显该应用程序会有哪些用例。</p><h3 id="第22章-整洁架构"><a href="#第22章-整洁架构" class="headerlink" title="第22章 整洁架构"></a>第22章 整洁架构</h3><ul><li><p>按照不同关注点对软件进行切割。也就是说，这些架构都会将软件切割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口、系统接口则属于其他层。</p></li><li><p>源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。</p></li><li><p>我们不应该让外层圆中发生的任何变更影响到内层圆的代码。</p></li><li><p>读者必须注意一下这里的依赖关系方向。所有跨边界的依赖线都是指向内的，这很好地遵守了架构的依赖关系规则。</p></li></ul><h3 id="第23章-展示器和谦卑对象"><a href="#第23章-展示器和谦卑对象" class="headerlink" title="第23章 展示器和谦卑对象"></a>第23章 展示器和谦卑对象</h3><ul><li>展示器实际上是采用谦卑对象(humble object)模式的一种形式，这种设计模式可以很好地帮助识别和保护系统架构的边界。</li></ul><h3 id="第24章-不完全边界"><a href="#第24章-不完全边界" class="headerlink" title="第24章 不完全边界"></a>第24章 不完全边界</h3><ul><li>构建不完全边界的一种方式就是在将系统分割成一系列可以独立编译、独立部署的组件之后，再把它们构建成一个组件。换句话说，在将系统中所有的接口、用于输入/输出的数据格式等每一件事都设置好之后，仍选择将它们统一编译和部署为一个组件。</li></ul><h3 id="第28章-测试边界"><a href="#第28章-测试边界" class="headerlink" title="第28章 测试边界"></a>第28章 测试边界</h3><ul><li><p>我们可以将测试组件视为系统架构中最外圈的程序。它们始终是向内依赖的，而且系统中没有其他组件依赖于它们。</p></li><li><p>修改一个通用的系统组件可能会导致成百上千个测试出现问题，我们通常将这类问题称为脆弱的测试问题(fragiletestsproblem)。</p></li></ul><h3 id="第29章-整洁的嵌入式架构"><a href="#第29章-整洁的嵌入式架构" class="headerlink" title="第29章 整洁的嵌入式架构"></a>第29章 整洁的嵌入式架构</h3><ul><li><p>“虽然软件本身并不会随时间推移而磨损，但硬件及其固件却会随时间推移而过时，随即也需要对软件做相应改动。”</p></li><li><p>不要再写固件代码了，让我们的代码活得更久一点！</p></li></ul><h3 id="第32章-应用程序框架是实现细节"><a href="#第32章-应用程序框架是实现细节" class="headerlink" title="第32章 应用程序框架是实现细节"></a>第32章 应用程序框架是实现细节</h3><ul><li><p>我们可以使用框架——但要时刻警惕，别被它拖住。我们应该将框架作为架构最外圈的一个实现细节来使用，不要让它们进入内圈。</p></li><li><p>如果一旦在项目中引入一个框架，很有可能在整个生命周期中都要依赖于它，不管后来情形怎么变化，这个决定都很难更改了。因此，不应该草率地做出决定。</p></li></ul><h3 id="第34章-拾遗"><a href="#第34章-拾遗" class="headerlink" title="第34章 拾遗"></a>第34章 拾遗</h3><ul><li>如果不考虑具体实现细节，再好的设计也无法长久。必须要将设计映射到对应的代码结构上，考虑如何组织代码树，以及在编译期和运行期采用哪种解耦合的模式。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Robert C. Martin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>From Now On重新开写！</title>
      <link href="/2023/11/21/thought_%E5%BC%80%E5%A7%8B%E5%86%99blog/"/>
      <url>/2023/11/21/thought_%E5%BC%80%E5%A7%8B%E5%86%99blog/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Hello，Blog！"><a href="#Hello，Blog！" class="headerlink" title="Hello，Blog！"></a>Hello，Blog！</h1><p>​本科的时候就有写blog的习惯，觉得与人分享是件快乐的事，同时在写博客的过程中也可以让自己重新审视一下自己学过的知识，在大概距离现在半年前就又有了开始写博客的念头，磕磕绊绊，只整理了三四篇就停了，现在，让我们继续重启吧！继续记录一下看过的一些书，和有趣的一些知识。</p><p>​就以，《From now on》这首我喜欢的歌曲作为这段路途的开头吧。</p><blockquote><p>From now on</p><p>从现在</p><p>These eyes will not be blinded by the lights</p><p>我双眼不会被幻象遮盖</p><p>From now on</p><p>从现在</p><p>What’s waited till tomorrow starts tonight</p><p>那些拖欠的事情今夜就</p><p>Tonight</p><p>Let this promise in me start</p><p>我愿将错误补偿</p><p>Like an anthem in my heart</p><p>如心中圣歌奏响</p><p>From now on</p><p>从现在</p><p>From now on</p></blockquote><p>​2023.11.21  22:07 于深圳</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《软件测试的艺术》笔记</title>
      <link href="/2023/11/21/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/21/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="第1章-一次自评价测试"><a href="#第1章-一次自评价测试" class="headerlink" title="第1章 一次自评价测试"></a>第1章 一次自评价测试</h2><p>所谓软件测试，<strong>就是一个过程或一系列过程，用来确认计算机代码完成了其应该完成的功能，不执行其不该有的操作。软件应当是可预测且稳定的，不会给用户带来意外惊奇。</strong></p><h2 id="第2章-软件测试的心理学和经济学"><a href="#第2章-软件测试的心理学和经济学" class="headerlink" title="第2章 软件测试的心理学和经济学"></a>第2章 软件测试的心理学和经济学</h2><p>要成功地测试一个软件应用程序，测试人员也需要有正确的态度（也许用“愿景”（vision）这个词会更好一些）。在某些情况下，测试人员的态度可能比实际的测试过程本身还要重要。</p><h3 id="2-1-软件测试的心理学"><a href="#2-1-软件测试的心理学" class="headerlink" title="2.1 软件测试的心理学"></a>2.1 软件测试的心理学</h3><ol><li><p><strong>每当测试一个程序时，应当想到要为程序增加一些价值。</strong>通过测试来增加程序的价值，是指测试提高了程序的可靠性或质量。提高了程序的可靠性，是指找出并最终修改了程序的错误。</p></li><li><p><strong>测试是为发现错误而执行程序的过程。</strong></p></li></ol><p>​3. 人类行为总是倾向于具有高度目标性，确立一个正确的目标有着重要的心理学影响。</p><ol start="4"><li><p><strong>如果在测试某段程序时发现了错误，而且这些错误是可以修复的，就将这次合理设计并得到有效执行的测试称做是“成功的”。如果本次测试可以最终确定再无其他可查出的错误，同样也被称做是“成功的”。</strong>所谓“不成功的”测试，仅指未能适当地对程序进行检查，在大多数情况下，未能找出错误的测试被认为是“不成功的”，这是因为认为软件中不包含错误的观点基本上是不切实际的。</p></li><li><p>心理学研究表明，当人们开始一项工作时，如果已经知道它是不可行的或无法实现时，人的表现就会相当糟糕。</p></li><li><p><strong>软件测试更适宜被视为试图发现程序中错误（假设其存在）的破坏性的过程。</strong>一个成功的测试用例，通过诱发程序发生错误，可以在这个方向上促进软件质量的改进。当然，最终我们还是要通过软件测试来建立某种程度的信心：软件做了其应该做的，未做其不应该做的。但是通过对错误的不断研究是实现这个目的的最佳途径。</p></li></ol><h4 id="2-2-1-黑盒测试"><a href="#2-2-1-黑盒测试" class="headerlink" title="2.2.1 黑盒测试"></a>2.2.1 黑盒测试</h4><p>黑盒测试是一种重要的测试策略，又称为数据驱动的测试或输入/输出驱动的测试。使用这种测试方法时，<strong>将程序视为一个黑盒子。测试目标与程序的内部机制和结构完全无关，而是将重点集中放在发现程序不按其规范正确运行的环境条件。</strong></p><h4 id="2-2-2-白盒测试"><a href="#2-2-2-白盒测试" class="headerlink" title="2.2.2 白盒测试"></a>2.2.2 白盒测试</h4><p>白盒测试或称逻辑驱动的测试，允许我们检查程序的内部结构。这种测试策略对程序的逻辑结构进行检查，从中获取测试数据（遗憾的是，常常忽略了程序的规范）。</p><blockquote><p>所谓穷举路径测试，即如果使用测试用例执行了程序中所有可能的控制流路径，那么程序有可能得到了完全测试。</p></blockquote><p>==注意这里的表述是有可能。==</p><p>“穷举路径测试即完全的测试”论断存在的第二个问题是，虽然我们可以测试到程序中的所有路径，但是程序可能仍然存在着错误。这有三个原因。第一，<strong>即使是穷举路径测试也决不能保证程序符合其设计规范。</strong>举例来说，如果要编写一个升序排序程序，但却错误地编成了一个降序排序程序，那么穷举路径测试就没多大价值了；程序仍然存在着一个缺陷：它是个错误的程序，因为不符合设计的规范。第二，<strong>程序可能会因为缺少某些路径而存在问题。</strong>穷举路径测试当然不能发现缺少了哪些必需路径。第三，穷举路径测试可能不会暴露数据敏感错误。</p><h3 id="2-3-软件测试的原则"><a href="#2-3-软件测试的原则" class="headerlink" title="2.3 软件测试的原则"></a>2.3 软件测试的原则</h3><p>==表2-1总结了这些重要原则==</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_4" alt="img"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_5" alt="img"></p><p>原则1：测试用例中一个必需部分是对预期输出或结果的定义。</p><p>一个测试用例必须包括两个部分：1.对程序的输入数据的描述。2.对程序在上述输入数据下的正确输出结果的精确描述。</p><p>原则2：程序员应当避免测试自己编写的程序。</p><p>原则3：编写软件的组织不应当测试自己编写的软件。</p><p>原则4：应当彻底检查每个测试的执行结果。</p><p>原则5：测试用例的编写不仅应当根据有效和预期的输入情况，而且也应当根据无效和未预料到的输入情况。</p><p>原则6：检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”。</p><p>原则7：应避免测试用例用后即弃，除非软件本身就是一个一次性的软件。</p><p>原则8：计划测试工作时不应默许假定不会发现错误。</p><p>原则9：程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比。</p><p>原则10：软件测试是一项极富创造性、极具智力挑战性的工作。</p><h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>==在阅读本书接下来的内容时，请牢记以下几个重要的测试原则：·软件测试是为发现错误而执行程序的过程。·尽量避免编码人员测试自己的程序。·好的测试用例能够对未发现的错误高度敏感。·成功的测试用例能够发现未知的错误。·成功的测试需要仔细定义输入输出的期望值。·成功的测试需要仔细研究分析测试结果。==</p><h2 id="第3章-代码检查、走查与评审"><a href="#第3章-代码检查、走查与评审" class="headerlink" title="第3章 代码检查、走查与评审"></a>第3章 代码检查、走查与评审</h2><p>在开始讨论人工测试技术之前，有一条重要的注意事项：由于包含了人为因素在内，导致很多方法的正规性要差于由计算机执行的数学证明，人们可能会怀疑某些如此简单和不正规的东西是否有用。反之亦然。这些不正规的方法并没有妨碍测试取得成功；相反，它们从以下两个方面显著地提高了测试的功效和可靠性。</p><p>首先，<strong>人们普遍认识到错误发现得越早，改正错误的成本越低，正确改正错误的可能性也越大。</strong>其次<strong>，程序员在开始基于计算机的测试时似乎要经历一个心理上的转变。从内部产生的压力似乎会急剧增长，并产生一个趋势，要“尽可能快地修正这个缺陷”。</strong>由于这些压力的存在，程序员在改正某个由基于计算机测试发现的错误时所犯的失误，要比改正早期发现的问题时所犯的失误更多一些。</p><h3 id="3-1-代码检查与走查"><a href="#3-1-代码检查与走查" class="headerlink" title="3.1 代码检查与走查"></a>3.1 代码检查与走查</h3><p><strong>代码检查、走查以及可用性测试是三种主要的人工测试方法。</strong></p><p>代码检查与走查都要求人们组成一个小组来阅读或直观检查特定的程序。</p><p>代码走查的另一个优点在于，一旦发现错误，通常就能在代码中对其进行精确定位，这就降低了调试（错误修正）的成本。另外，这个过程通常发现成批的错误，这样错误就可以一同得到修正。而基于计算机的测试通常只能暴露出错误的某个表症（程序不能停止，或打印出了一个无意义的结果），错误通常是逐个地被发现并得到纠正的。</p><p>一些测试人员在使用了人工方法之后发现，对于某些特定类型的错误，人工方法比基于计算机的方法更有效，而对于其他错误类型，基于计算机的方法更有效。这就意味着，代码检查/走查与基于计算机的测试是互补的。缺少其中任何一种，错误检查的效率都会降低。</p><h4 id="3-2-2-检查议程与注意事项"><a href="#3-2-2-检查议程与注意事项" class="headerlink" title="3.2.2 检查议程与注意事项"></a>3.2.2 检查议程与注意事项</h4><p>大多数的代码检查都是按<strong>每小时大约阅读150行代码的速度进行。</strong>因此，对大型软件的检查应安排多个代码检查会议同时进行，每个代码检查会议处理一个或几个模块或子程序。</p><h4 id="3-2-4-代码检查的衍生功效"><a href="#3-2-4-代码检查的衍生功效" class="headerlink" title="3.2.4 代码检查的衍生功效"></a>3.2.4 代码检查的衍生功效</h4><ol><li>程序员通常会得到编程风格、算法选择及编程技术等方面的反馈信息。</li><li>其他参与者也可以通过接触程序员的错误和编程风格而同样受益匪浅。通常来说，这种类型的测试方法能够增强项目中团队的凝聚力，减少消极人际关系滋长的可能性，有利于打造高度合作的、高效的以及信得过的开发模式。</li></ol><h3 id="3-3-用于代码检查的错误列表"><a href="#3-3-用于代码检查的错误列表" class="headerlink" title="3.3 用于代码检查的错误列表"></a>3.3 用于代码检查的错误列表</h3><p>代码检查过程的一个重要部分就是对照一份错误列表，来检查程序是否存在常见错误。请参考下面博客：《软件测试的艺术》原书第3版的3.3节笔记-用于代码检查的错误列表</p><h3 id="3-5-桌面检查"><a href="#3-5-桌面检查" class="headerlink" title="3.5 桌面检查"></a>3.5 桌面检查</h3><p>人工查找错误的第三种过程是古老的桌面检查方法。</p><p>对于大多数人而言，桌面检查的效率是相当低的。其中的一个原因是，它是一个完全没有约束的过程。另一个重要的原因是它违反了本书第2章提出的测试原则，即人们一般不能有效地测试自己编写的程序。因此桌面检查最好由其他人而非该程序的编写人员来完成</p><h3 id="4-1-白盒测试"><a href="#4-1-白盒测试" class="headerlink" title="4.1 白盒测试"></a>4.1 白盒测试</h3><p>白盒测试关注的是<strong>测试用例执行的程度或覆盖程序逻辑结构（源代码）的程度。</strong></p><p>判定覆盖或分支覆盖是较强一些的逻辑覆盖准则。该准则要求必须编写足够的测试用例，使得每一个判断都至少有一个为真和为假的输出结果。换句话说，也就是每条分支路径都必须至少遍历一次。</p><p>在条件覆盖情况下，要编写足够的测试用例以确保将一个判断中的每个条件的所有可能的结果至少执行一次。</p><p>判定/条件覆盖准则。这种准则要求设计出充足的测试用例，将一个判断中的每个条件的所有可能的结果至少执行一次，将每个判断的所有可能的结果至少执行一次，将每个入口点都至少调用一次。</p><p>对于包含每个判断只存在一种条件的程序，最简单的测试准则就是设计出足够数量的测试用例，实现：（1）将每个判断的所有结果都至少执行一次；（2）将所有的程序入口（例如入口点或ON单元）都至少调用一次，以确保全部的语句都至少执行一次。而对于包含多重条件判断的程序，最简单的测试准则是设计出足够数量的测试用例，将每个判断的所有可能的条件结果的组合，以及所有的入口点都至少执行一次（加入“可能”二字，是因为有些组合情况难以生成）。</p><h4 id="4-2-1-等价划分"><a href="#4-2-1-等价划分" class="headerlink" title="4.2.1 等价划分"></a>4.2.1 等价划分</h4><ol><li>每个测试用例都必须体现尽可能多的不同的输入情况，以使最大限度地减少测试所需的全部用例的数量。</li><li>应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类，这样就可以合理地假设（但是，显然不能绝对肯定）测试每个等价类的代表性数据等同于测试该类的其他任何数据。</li></ol><p>上面两种思想形成了称为等价划分的黑盒测试方法。第二种思想可以用来设计一个“令人感兴趣的”输入条件集合以供测试，而第一个思想可以随后用来设计涵盖这些状态的一个最小测试用例集。</p><p>使用等价划分方法设计测试用例主要有两个步骤：（1）确定等价类；（2）生成测试用例。</p><h4 id="4-2-3-边界值分析"><a href="#4-2-3-边界值分析" class="headerlink" title="4.2.3 边界值分析"></a>4.2.3 边界值分析</h4><p><strong>考虑了边界条件的测试用例与其他没有考虑边界条件的测试用例相比，具有更高的测试回报率。</strong>所谓边界条件，是指输入和输出等价类中那些恰好处于边界、或超过边界、或在边界以下的状态。</p><p>边界值分析方法与等价划分方法存在两方面的不同：1.与从等价类中挑选出任意一个元素作为代表不同，边界值分析需要选择一个或多个元素，以便等价类的每个边界都经过一次测试。2.与仅仅关注输入条件（输入空间）不同，还需要考虑从结果空间（输出等价类）设计测试用例。</p><p>==通用指南==：</p><p>1.如果输入条件规定了一个输入值范围，那么应针对范围的边界设计测试用例，针对刚刚越界的情况设计无效输入测试用例。</p><p>2.如果输入条件规定了输入值的数量，那么应针对最小数量输入值、最大数量输入值，以及比最小数量少一个、比最大数量多一个的情况设计测试用例。</p><p>3.对每个输出条件应用指南1。</p><p>4.对每个输出条件应用指南2。</p><p>5.如果程序的输入或输出是一个有序序列（例如顺序的文件、线性列表或表格），则应特别注意该序列的第一个和最后一个元素。</p><p>6.此外，发挥聪明才智找出其他的边界条件。</p><h3 id="4-3-错误猜测"><a href="#4-3-错误猜测" class="headerlink" title="4.3 错误猜测"></a>4.3 错误猜测</h3><p>错误猜测主要是一项依赖于直觉的非正规的过程，因此很难描述出这种方法的规程。其基本思想是列举出可能犯的错误或错误易发情况的清单，然后依据清单来编写测试用例。</p><h2 id="第5章-模块（单元）测试"><a href="#第5章-模块（单元）测试" class="headerlink" title="第5章 模块（单元）测试"></a>第5章 模块（单元）测试</h2><p>模块测试的目的是将模块的功能与定义模块的功能规格说明或接口规格说明进行比较。</p><h3 id="5-1-测试用例设计"><a href="#5-1-测试用例设计" class="headerlink" title="5.1 测试用例设计"></a>5.1 测试用例设计</h3><p>在为模块测试设计的测试用例时，需要使用两种类型的信息：<strong>模块的规格说明</strong>和<strong>模块的源代码</strong>。规格说明一般都规定了模块的输入和输出参数以及模块的功能。模块测试总体上是面向白盒测试的。</p><p>模块测试中测试用例的设计过程如下：使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例。</p><h3 id="5-2-增量测试"><a href="#5-2-增量测试" class="headerlink" title="5.2 增量测试"></a>5.2 增量测试</h3><p>软件测试是否应先独立地测试每个模块，然后再将这些模块组装成完整的程序？还是先将下一步要测试的模块组装到测试完成的模块集合中，然后再进行测试？第一种方法称为非增量测试或<strong>“崩溃（big-bang）”测试</strong>，而第二种方法称为<strong>增量测试或集成</strong>。</p><p>1.非增量测试所需的工作量要多一些。</p><p>2.如果使用了增量测试，可以较早地发现模块中与不匹配接口、不正确假设相关的编程错误。</p><p>3.因此，如果使用了增量测试，调试会进行得容易一些。</p><p>4.增量测试会将测试进行得更彻底。</p><p>5.非增量测试所占用的机器时间显得少一些。</p><p>6.模块测试阶段开始时，如果使用的是非增量测试，就会有更多的机会进行并行操作（也就是说，所有的模块可以同时测试）。</p><h3 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h3><p>单元测试用来检查软件的功能实现是否满足了规格说明书要求。</p><p>彻底的单元测试设计需要使用增量策略，如自顶而下以及自底而上的技术。</p><h2 id="第6章-更高级别的测试"><a href="#第6章-更高级别的测试" class="headerlink" title="第6章 更高级别的测试"></a>第6章 更高级别的测试</h2><p>==·模块测试的目的是发现程序模块与其接口规格说明之间的不一致。·功能测试的目的是为了证明程序未能符合其外部规格说明。·系统测试的目的是为了证明软件产品与其初始目标不一致。==</p><h3 id="6-1-功能测试"><a href="#6-1-功能测试" class="headerlink" title="6.1 功能测试"></a>6.1 功能测试</h3><p>功能测试是一个试图发现程序与其外部规格说明之间存在不一致的过程。外部规格说明是一份从最终用户的角度对程序行为的精确描述。</p><h3 id="6-6-测试结束准则"><a href="#6-6-测试结束准则" class="headerlink" title="6.6 测试结束准则"></a>6.6 测试结束准则</h3><p>最常见的两个准则是：1.用完了安排的测试时间后，测试便结束。2.当执行完所有测试用例都未发现错误，测试便结束。也就是说，当所有的测试用例不成功时便结束。</p><h4 id="7-2-1-测试用户的选择"><a href="#7-2-1-测试用户的选择" class="headerlink" title="7.2.1 测试用户的选择"></a>7.2.1 测试用户的选择</h4><p>如果用户需要太长时间来接受某一软件，这将直接导致该项目的失败。</p><h4 id="7-2-5-何时收工，还是多多益善"><a href="#7-2-5-何时收工，还是多多益善" class="headerlink" title="7.2.5 何时收工，还是多多益善"></a>7.2.5 何时收工，还是多多益善</h4><p>检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程序是否“做了其不应该做的”，这其中有着微妙的差别。</p><h2 id="第8章-调试"><a href="#第8章-调试" class="headerlink" title="第8章 调试"></a>第8章 调试</h2><p>==所谓成功的测试，是指它可以证明程序没有实现预期的功能。==调试是一个包含两个步骤的过程，从执行了一个成功的测试用例、发现了一个问题之后开始。第一步，确定程序中可疑错误的准确性质和位置；第二步，修改错误。</p><h3 id="8-1-暴力法调试"><a href="#8-1-暴力法调试" class="headerlink" title="8.1 暴力法调试"></a>8.1 暴力法调试</h3><p>暴力调试方法可至少被划分为三种类型：1.利用内存信息输出来调试。2.根据一般的“在程序中插入打印语句”建议来调试。3.使用自动化的调试工具进行调试。</p><h4 id="8-6-1-定位错误的原则"><a href="#8-6-1-定位错误的原则" class="headerlink" title="8.6.1 定位错误的原则"></a>8.6.1 定位错误的原则</h4><p>在试过了其他的方法之后才使用调试工具，并将其作为头脑思考的辅助手段，而不是替代手段。正如本章前面所述，调试工具比如输出和跟踪工具，代表的是一种偶然的调试方法。经验证明，不使用工具的人即使在调试并不熟悉的程序时，也要比使用工具的人更为成功。</p><p>调试程序的新手最常犯的错误是为了解决问题而试验性地去修改程序。调试者可能会说：“我知道什么出错了，所以我要改动一下DO语句，看一看会发生什么”。这种纯粹是无计划的方法甚至不属于调试；它表现的是盲目的行动。它获得成功的机会不仅很小，而且还会将新的错误引入程序中，使问题更为复杂。</p><h2 id="第9章-敏捷开发模式下的测试"><a href="#第9章-敏捷开发模式下的测试" class="headerlink" title="第9章 敏捷开发模式下的测试"></a>第9章 敏捷开发模式下的测试</h2><p>图　9-1　《敏捷软件开发宣言》</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_96" alt="figure_0155_0100"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_97" alt="figure_0156_0101"></p><h1 id="其他好句"><a href="#其他好句" class="headerlink" title="其他好句"></a>其他好句</h1><ul><li>在一个典型的编程项目中，软件测试或系统测试大约占用50%的项目时间和超过50%的总成本。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《大话设计模式》笔记</title>
      <link href="/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="本书特色"><a href="#本书特色" class="headerlink" title="本书特色"></a>本书特色</h3><p>如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_323" alt="img"></p><h3 id="1-11-UML类图"><a href="#1-11-UML类图" class="headerlink" title="1.11 UML类图"></a>1.11 UML类图</h3><p>继承关系用空心三角形+实线来表示</p><p>实现接口用空心三角形+虚线来表示。</p><p>关联关系用实线箭头来表示。</p><p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。聚合关系用空心的菱形+实线箭头来表示。</p><p>合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p><p>合成关系用实心的菱形+实线箭头来表示</p><p>合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例</p><p>依赖关系（Dependency），用虚线箭头来表示。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_24" alt="img"></p><h3 id="2-4-策略模式"><a href="#2-4-策略模式" class="headerlink" title="2.4 策略模式"></a>2.4 策略模式</h3><p><strong>策略模式（Strategy）</strong>：<mark>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_47" alt="img"></p><h3 id="2-7-策略模式解析"><a href="#2-7-策略模式解析" class="headerlink" title="2.7 策略模式解析"></a>2.7 策略模式解析</h3><ul><li><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p></li><li><p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能</p></li><li><p>策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试</p></li><li><p>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句</p></li><li><p>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性</p></li><li><p>在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象任何需求的变更都是需要成本的。</p></li></ul><h3 id="3-4-单一职责原则"><a href="#3-4-单一职责原则" class="headerlink" title="3.4 单一职责原则"></a>3.4 单一职责原则</h3><p><strong>单一职责原则（SRP）</strong>：<mark>就一个类而言，应该仅有一个引起它变化的原因。<mark></mark></mark></p><h3 id="3-5-单一职责原则说明"><a href="#3-5-单一职责原则说明" class="headerlink" title="3.5 单一职责原则说明"></a>3.5 单一职责原则说明</h3><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏</p><p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</p><p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p><h3 id="4-2-开放-封闭原则"><a href="#4-2-开放-封闭原则" class="headerlink" title="4.2 开放-封闭原则"></a>4.2 开放-封闭原则</h3><p><strong>开放-封闭原则</strong>：<mark>对于扩展是开放的（Open for extension）’，另一个是说‘对于更改是封闭的（Closed for modification）。<mark></mark></mark></p><p>怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？[ASD]</p><h3 id="4-3-开放-封闭原则说明"><a href="#4-3-开放-封闭原则说明" class="headerlink" title="4.3 开放-封闭原则说明"></a>4.3 开放-封闭原则说明</h3><ul><li><p>无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化[ASD]。</p></li><li><p>等到变化发生时立即采取行动</p></li><li><p>在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[</p></li><li><p>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。</p></li><li><p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难[ASD]。</p></li><li><p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]。</p></li></ul><h3 id="5-3-依赖倒转原则"><a href="#5-3-依赖倒转原则" class="headerlink" title="5.3 依赖倒转原则"></a>5.3 依赖倒转原则</h3><p><strong>依赖倒转原则</strong>：<mark>原话解释是抽象不应该依赖细节，细节应该依赖于抽象，这话绕口，说白了，就是要针对接口编程，不要对实现编程。<mark></mark></mark></p><p>A．高层模块不应该依赖低层模块。两个都应该依赖抽象。B．抽象不应该依赖细节。细节应该依赖抽象。</p><ul><li>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了</li></ul><h3 id="5-4-里氏代换原则"><a href="#5-4-里氏代换原则" class="headerlink" title="5.4 里氏代换原则"></a>5.4 里氏代换原则</h3><p><strong>里氏代换原则</strong>：<mark>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。<mark></mark></mark></p><p><strong>里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。[ASD]</strong></p><ul><li><p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p></li><li><p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p></li></ul><p>依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。</p><h3 id="6-4-装饰模式"><a href="#6-4-装饰模式" class="headerlink" title="6.4 装饰模式"></a>6.4 装饰模式</h3><p><strong>装饰模式（Decorator）</strong>:<mark>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_63" alt="img"></p><p>Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。</p><p>装饰模式是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中</p><p>如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_63" alt="img"></p><h3 id="6-6-装饰模式总结"><a href="#6-6-装饰模式总结" class="headerlink" title="6.6 装饰模式总结"></a>6.6 装饰模式总结</h3><ul><li><p>装饰模式是为已有功能动态地添加更多功能的一种方式。</p></li><li><p>当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为，在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，就像你起初的那个‘人’类，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。而装饰模式却提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了</p></li><li><p><strong>优点</strong>：1.把类中的装饰功能从类中搬移去除，这样可以简化原有的类。2.有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。</p></li></ul><h3 id="7-5-代理模式"><a href="#7-5-代理模式" class="headerlink" title="7.5 代理模式"></a>7.5 代理模式</h3><p><strong>代理模式（Proxy）</strong>:<mark>为其他对象提供一种代理以控制对这个对象的访问。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_76" alt="img"></p><h3 id="7-6-代理模式应用"><a href="#7-6-代理模式应用" class="headerlink" title="7.6 代理模式应用"></a>7.6 代理模式应用</h3><p>以下为几种应用的场合：</p><ul><li><p><strong>远程代理</strong>，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实</p></li><li><p><strong>虚拟代理</strong>，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象</p></li><li><p><strong>安全代理</strong>，用来控制真实对象访问时的权限</p></li><li><p><strong>智能指引</strong>，是指当调用真实的对象时，代理处理另外一些事</p></li></ul><h3 id="8-4-简单工厂vs-工厂方法"><a href="#8-4-简单工厂vs-工厂方法" class="headerlink" title="8.4 简单工厂vs.工厂方法"></a>8.4 简单工厂vs.工厂方法</h3><p><strong>简单工厂的实现</strong></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_77" alt="img"></p><p><strong>工厂方法的实现</strong>（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_79" alt="img"></p><ul><li><p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p></li><li><p>我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，变成了一个工厂抽象接口和多个具体生成对象的工厂</p></li><li><p>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端</p></li></ul><h3 id="9-3-原型模式"><a href="#9-3-原型模式" class="headerlink" title="9.3 原型模式"></a>9.3 原型模式</h3><p><strong>原型模式（Prototype）</strong>:<mark>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_86" alt="img"></p><p>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。</p><h3 id="9-4原型模式的优点"><a href="#9-4原型模式的优点" class="headerlink" title="9.4原型模式的优点"></a>9.4原型模式的优点</h3><ul><li><p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高</p></li><li><p>不用重新初始化对象，而是动态地获得对象运行时的状态。</p></li></ul><h3 id="10-4-模板方法模式"><a href="#10-4-模板方法模式" class="headerlink" title="10.4 模板方法模式"></a>10.4 模板方法模式</h3><p>重复=易错+难改</p><p><strong>模板方法模式</strong>:<mark>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_106" alt="img"></p><h3 id="10-5-模板方法模式特点"><a href="#10-5-模板方法模式特点" class="headerlink" title="10.5 模板方法模式特点"></a>10.5 模板方法模式特点</h3><ul><li><p>模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。</p></li><li><p>模板方法模式就是提供了一个很好的代码复用平台。</p></li><li><p>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p></li></ul><h3 id="11-3-迪米特法则"><a href="#11-3-迪米特法则" class="headerlink" title="11.3 迪米特法则"></a>11.3 迪米特法则</h3><p><strong>迪米特法则（LoD）</strong>:<mark>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。<mark></mark></mark></p><ul><li><p>迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权。</p></li><li><p>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</p></li></ul><h3 id="12-5-何时使用外观模式"><a href="#12-5-何时使用外观模式" class="headerlink" title="12.5 何时使用外观模式"></a>12.5 何时使用外观模式</h3><p><strong>外观模式（Facade）</strong>:<mark>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_114" alt="img"></p><p>在设计初期阶段，应该要有意识的将不同的两个层分离</p><h2 id="第13章-好菜每回味不同——建造者模式"><a href="#第13章-好菜每回味不同——建造者模式" class="headerlink" title="第13章 好菜每回味不同——建造者模式"></a>第13章 好菜每回味不同——建造者模式</h2><h3 id="13-1-炒面没放盐"><a href="#13-1-炒面没放盐" class="headerlink" title="13.1 炒面没放盐"></a>13.1 炒面没放盐</h3><p>依赖倒转原则？抽象不应该依赖细节，细节应该依赖于抽象</p><h3 id="13-4-建造者模式"><a href="#13-4-建造者模式" class="headerlink" title="13.4 建造者模式"></a>13.4 建造者模式</h3><p>如果你需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们需要应用于一个设计模式，‘建造者（Builder）模式’，又叫生成器模式。</p><p><strong>建造者模式（Builder）</strong>:<mark>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_123" alt="img"></p><p>指挥者（Director）一个很重要的类，用它来控制建造过程，也用它来隔离用户与建造过程的关联。”</p><h3 id="13-5-建造者模式应用"><a href="#13-5-建造者模式应用" class="headerlink" title="13.5 建造者模式应用"></a>13.5 建造者模式应用</h3><p>主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。</p><h3 id="14-5-观察者模式"><a href="#14-5-观察者模式" class="headerlink" title="14.5 观察者模式"></a>14.5 观察者模式</h3><p><strong>观察者模式</strong>:<mark>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_136" alt="img"></p><h3 id="14-6-观察者模式特点"><a href="#14-6-观察者模式特点" class="headerlink" title="14.6 观察者模式特点"></a>14.6 观察者模式特点</h3><ul><li><p>动机：将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便</p></li><li><p>适用场景：当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。另外，当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p></li><li><p>解释：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p></li></ul><h3 id="14-9-事件委托说明"><a href="#14-9-事件委托说明" class="headerlink" title="14.9 事件委托说明"></a>14.9 事件委托说明</h3><p><strong>委托就是一种引用方法的类型。</strong>一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。</p><ul><li><p>一个委托可以搭载多个方法，所有方法被依次唤起。更重要的是，它可以使得委托对象所搭载的方法并不需要属于同一个类。</p></li><li><p>委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。</p></li></ul><h2 id="第15章-就不能不换DB吗？——抽象工厂模式"><a href="#第15章-就不能不换DB吗？——抽象工厂模式" class="headerlink" title="第15章 就不能不换DB吗？——抽象工厂模式"></a>第15章 就不能不换DB吗？——抽象工厂模式</h2><h3 id="15-5-抽象工厂模式"><a href="#15-5-抽象工厂模式" class="headerlink" title="15.5 抽象工厂模式"></a>15.5 抽象工厂模式</h3><p><strong>抽象工厂模式（Abstract Factory）</strong>:<mark>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_150" alt="img"></p><h3 id="15-6-抽象工厂模式的优点与缺点"><a href="#15-6-抽象工厂模式的优点与缺点" class="headerlink" title="15.6 抽象工厂模式的优点与缺点"></a>15.6 抽象工厂模式的优点与缺点</h3><ul><li><p>好处便是易于交换产品系列，由于具体工厂类，例如IFactory factory =new AccessFactory()，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置</p></li><li><p>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</p></li></ul><p><strong>编程是门艺术，大批量的改动，显然是非常丑陋的做法。</strong>所以抽象工厂模式很酷。</p><h3 id="16-5-状态模式"><a href="#16-5-状态模式" class="headerlink" title="16.5 状态模式"></a>16.5 状态模式</h3><p><strong>状态模式（State）</strong>:<mark>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_163" alt="img"></p><p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p><h3 id="16-6-状态模式好处与用处"><a href="#16-6-状态模式好处与用处" class="headerlink" title="16.6 状态模式好处与用处"></a>16.6 状态模式好处与用处</h3><p><mark>状态模式的好处<mark></mark></mark></p><ul><li><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p></li><li><p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。</p></li><li><p>状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖</p></li></ul><p><mark>状态模式的用处<mark></mark></mark></p><p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式</p><h3 id="17-2-适配器模式"><a href="#17-2-适配器模式" class="headerlink" title="17.2 适配器模式"></a>17.2 适配器模式</h3><p><strong>适配器模式（Adapter）</strong>:<mark>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<mark></mark></mark></p><p>用途：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_173" alt="img"></p><p>两种类型：类适配器模式和对象适配器模式</p><h3 id="17-3-何时使用适配器模式"><a href="#17-3-何时使用适配器模式" class="headerlink" title="17.3 何时使用适配器模式"></a>17.3 何时使用适配器模式</h3><ul><li><p>使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。即两个类所做的事情相同或相似，但是具有不同的接口时要使用它。</p></li><li><p>在双方都不太容易修改的时候再使用适配器模式适配。</p></li></ul><h3 id="18-4-备忘录模式基本代码"><a href="#18-4-备忘录模式基本代码" class="headerlink" title="18.4 备忘录模式基本代码"></a>18.4 备忘录模式基本代码</h3><p><strong>备忘录（Memento）</strong>：<mark>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_186" alt="img"></p><p>Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</p><ul><li><p>如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态</p></li><li><p>使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来</p></li><li><p>当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原</p></li></ul><h3 id="19-2-组合模式"><a href="#19-2-组合模式" class="headerlink" title="19.2 组合模式"></a>19.2 组合模式</h3><p><strong>组合模式（Composite）</strong>:<mark>将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_196" alt="img"></p><h3 id="19-3-透明方式与安全方式"><a href="#19-3-透明方式与安全方式" class="headerlink" title="19.3 透明方式与安全方式"></a>19.3 透明方式与安全方式</h3><p><strong>透明方式</strong>，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。</p><p><strong>安全方式</strong>，也就是在Component接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法，这样做就不会出现刚才提到的问题，不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</p><h3 id="19-4-何时使用组合模式"><a href="#19-4-何时使用组合模式" class="headerlink" title="19.4 何时使用组合模式"></a>19.4 何时使用组合模式</h3><p>需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。</p><h3 id="19-6-组合模式好处"><a href="#19-6-组合模式好处" class="headerlink" title="19.6 组合模式好处"></a>19.6 组合模式好处</h3><p>组合模式这样定义了类似包含人力资源部和财务部这些基本对象和分公司、办事处等组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。</p><h3 id="20-2-迭代器模式"><a href="#20-2-迭代器模式" class="headerlink" title="20.2 迭代器模式"></a>20.2 迭代器模式</h3><p><strong>迭代器模式（Iterator）</strong>:<mark>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_203" alt="img"></p><p>当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式</p><p>你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。</p><p>为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。</p><h3 id="20-4-迭代器模式的好处"><a href="#20-4-迭代器模式的好处" class="headerlink" title="20.4 迭代器模式的好处"></a>20.4 迭代器模式的好处</h3><p>迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h3 id="21-3-生还是不生是自己的责任"><a href="#21-3-生还是不生是自己的责任" class="headerlink" title="21.3 生还是不生是自己的责任"></a>21.3 生还是不生是自己的责任</h3><p>所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。</p><h3 id="21-4-单例模式"><a href="#21-4-单例模式" class="headerlink" title="21.4 单例模式"></a>21.4 单例模式</h3><p><strong>单例模式（Singleton）</strong>:<mark>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_220" alt="img"></p><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p><p>单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</p><h3 id="22-2-紧耦合的程序演化"><a href="#22-2-紧耦合的程序演化" class="headerlink" title="22.2 紧耦合的程序演化"></a>22.2 紧耦合的程序演化</h3><p>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p><p>在面向对象设计中，我们还有一个很重要的设计原则，那就是合成／聚合复用原则。即<strong>优先使用对象合成／聚合，而不是类继承。</strong></p><h3 id="22-3-合成／聚合复用原则"><a href="#22-3-合成／聚合复用原则" class="headerlink" title="22.3 合成／聚合复用原则"></a>22.3 合成／聚合复用原则</h3><p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样</p><p><strong>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</strong></p><h3 id="22-5-桥接模式"><a href="#22-5-桥接模式" class="headerlink" title="22.5 桥接模式"></a>22.5 桥接模式</h3><p><strong>桥接模式（Bridge）</strong>:<mark>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<mark></mark></mark></p><p>什么叫抽象与它的实现分离，这并不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_233" alt="img"></p><h3 id="23-6-命令模式"><a href="#23-6-命令模式" class="headerlink" title="23.6 命令模式"></a>23.6 命令模式</h3><p><strong>命令模式（Command）</strong>:<mark>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_246" alt="img"></p><h3 id="23-7-命令模式作用"><a href="#23-7-命令模式作用" class="headerlink" title="23.7 命令模式作用"></a>23.7 命令模式作用</h3><p>第一，它能较容易地设计一个命令队列；</p><p>第二，在需要的情况下，可以较容易地将命令记入日志；</p><p>第三，允许接收请求的一方决定是否要否决请求。</p><p>第四，可以容易地实现对请求的撤销和重做；</p><p>第五，由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。其实还有最关键的优点就是命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</p><p><strong>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。</strong>如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。</p><h3 id="24-3-职责链模式"><a href="#24-3-职责链模式" class="headerlink" title="24.3 职责链模式"></a>24.3 职责链模式</h3><p><strong>职责链模式（Chain of Responsibility）</strong>：<mark>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_249" alt="img"></p><h3 id="24-4-职责链的好处"><a href="#24-4-职责链的好处" class="headerlink" title="24.4 职责链的好处"></a>24.4 职责链的好处</h3><ul><li><p>当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p></li><li><p>接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。</p></li><li><p>随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。</p></li><li><p>需要注意的是：一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理</p></li></ul><h2 id="第25章-世界需要和平——中介者模式"><a href="#第25章-世界需要和平——中介者模式" class="headerlink" title="第25章 世界需要和平——中介者模式"></a>第25章 世界需要和平——中介者模式</h2><h3 id="25-2-中介者模式"><a href="#25-2-中介者模式" class="headerlink" title="25.2 中介者模式"></a>25.2 中介者模式</h3><p><strong>中介者模式（Mediator）</strong>:<mark>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_263" alt="img"></p><h3 id="25-4-中介者模式优缺点"><a href="#25-4-中介者模式优缺点" class="headerlink" title="25.4 中介者模式优缺点"></a>25.4 中介者模式优缺点</h3><ul><li><p>中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了‘多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。</p></li><li><p>Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator</p></li><li><p>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</p></li><li><p>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</p></li></ul><p><mark>应用场景<mark></mark></mark></p><ul><li>中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。</li></ul><h3 id="26-2-享元模式"><a href="#26-2-享元模式" class="headerlink" title="26.2 享元模式"></a>26.2 享元模式</h3><p><strong>享元模式（Flyweight）</strong>:<mark>运用共享技术有效地支持大量细粒度的对象。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_272" alt="img"></p><h3 id="26-4-内部状态与外部状态"><a href="#26-4-内部状态与外部状态" class="headerlink" title="26.4 内部状态与外部状态"></a>26.4 内部状态与外部状态</h3><p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。</p><h3 id="26-5-享元模式应用"><a href="#26-5-享元模式应用" class="headerlink" title="26.5 享元模式应用"></a>26.5 享元模式应用</h3><p>如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</p><p>像围棋，一盘棋理论上有361个空位可以放棋子，那如果用常规的面向对象方式编程，每盘棋都可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，毕竟内存空间还是有限的。如果用了享元模式来处理棋子，那么棋子对象可以减少到只有两个实例，结果……你应该明白的。</p><h3 id="27-2-解释器模式（skip）"><a href="#27-2-解释器模式（skip）" class="headerlink" title="27.2 解释器模式（skip）"></a>27.2 解释器模式（skip）</h3><p><strong>解释器模式（interpreter）</strong>:<mark>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_280" alt="img"></p><p>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题</p><h3 id="27-3-解释器模式好处"><a href="#27-3-解释器模式好处" class="headerlink" title="27.3 解释器模式好处"></a>27.3 解释器模式好处</h3><ul><li><p>当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p></li><li><p>容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写</p></li><li><p>解释器模式也有不足的，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理</p></li></ul><h3 id="28-5-访问者模式"><a href="#28-5-访问者模式" class="headerlink" title="28.5 访问者模式"></a>28.5 访问者模式</h3><p><strong>访问者模式（Visitor）</strong>:<mark>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<mark></mark></mark></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_296" alt="img"></p><p>访问者模式适用于数据结构相对稳定的系统？</p><p>它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化</p><p>访问者模式的目的是要把处理从数据结构分离出来。</p><p>有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。</p><p>访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。</p><p>那访问者的缺点其实也就是使增加新的数据结构变得困难了。</p><p>大多时候你并不需要访问者模式，但当一旦你需要访问者模式时，那就是真的需要它了。</p><h3 id="29-7-行为型模式二组比赛"><a href="#29-7-行为型模式二组比赛" class="headerlink" title="29.7 行为型模式二组比赛"></a>29.7 行为型模式二组比赛</h3><p>如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题</p><p>面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有许多连接。也就是说，有可能每一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难</p><p>访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。</p><p>继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D，从而给它以不同的行为。但这样会将行为硬行编制到父类A当中，而将算法的实现与类A的实现混合起来，从而使得类A难以理解、难以维护和难以扩展，而且还不能动态地改变算法。仔细分析会发现，它们之间的唯一差别是它们所使用的算法或行为，将算法封装在独立的策略Strategy类中使得你可以独立于其类A改变它，使它易于切换、易于理解、易于扩展。</p><p>使用备忘录就不会出现这个问题，它可以避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界。</p><p>迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。</p><h3 id="29-8-决赛"><a href="#29-8-决赛" class="headerlink" title="29.8 决赛"></a>29.8 决赛</h3><p>只要是在做面向对象的开发，创建对象的工作不可避免。创建对象时，负责创建的实体通常需要了解要创建的是哪个具体的对象，以及何时创建这个而非那个对象的规则。而我们如果希望遵循开放-封闭原则、依赖倒转原则和里氏代换原则，那使用对象时，就不应该知道所用的是哪一个特选的对象。此时就需要‘对象管理者’工厂来负责此事。</p><p>在创建对象时，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但它们也更加复杂，通常，设计是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。</p><p>工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂。</p><h1 id="其他好句"><a href="#其他好句" class="headerlink" title="其他好句"></a>其他好句</h1><ul><li>一个程序员如果从来没有熬夜写程序的经历，不能算是一个好程序员，因为他没有痴迷过，所以他不会有大成就。</li><li>面向对象设计其实就是希望做到代码的责任分解。</li><li>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。</li><li>代码无错未必优。</li><li>只要真正深入地理解了设计原则，很多设计模式其实就是原则的应用而已，或许在不知不觉中就在使用设计模式了。</li><li>尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性了。大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。</li><li>MVC是多种模式的综合应用，应该算是一种架构模式</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吴恩达Prompt网课笔记</title>
      <link href="/2023/06/24/%E5%90%B4%E6%81%A9%E8%BE%BEPrompt%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/24/%E5%90%B4%E6%81%A9%E8%BE%BEPrompt%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="吴恩达ChatGPT网课笔记Prompt-Engineering——训练ChatGPT前请先训练自己"><a href="#吴恩达ChatGPT网课笔记Prompt-Engineering——训练ChatGPT前请先训练自己" class="headerlink" title="吴恩达ChatGPT网课笔记Prompt Engineering——训练ChatGPT前请先训练自己"></a>吴恩达ChatGPT网课笔记Prompt Engineering——训练ChatGPT前请先训练自己</h1><p>主要是吴恩达的网课，还有部分github的<a href="https://github.com/datawhalechina/prompt-engineering-for-developers">prompt-engineering-for-developers</a>项目，以及部分自己的经验。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" alt="img1"></p><h1 id="一、常用使用技巧"><a href="#一、常用使用技巧" class="headerlink" title="一、常用使用技巧"></a>一、常用使用技巧</h1><ol><li>prompt最好是英文的，如果是中文的prompt，大概会是英文的1.5~2倍的token数量。一方面成本提升，另一方面对于较长的prompt可能会超过上下文上限。</li></ol><h2 id="原则1：编写简洁和具体的介绍"><a href="#原则1：编写简洁和具体的介绍" class="headerlink" title="原则1：编写简洁和具体的介绍"></a>原则1：编写简洁和具体的介绍</h2><h2 id="策略1：使用分隔符"><a href="#策略1：使用分隔符" class="headerlink" title="策略1：使用分隔符"></a>策略1：使用分隔符</h2><ol><li><p>“””</p></li><li><p><mark>```<mark></mark></mark></p></li><li><p><code>- - -</code></p></li><li><p>&lt; &gt;</p></li><li><p>XML 标签：<code>&lt;tag&gt; &lt;/tag&gt;</code></p></li></ol><p>下图是一个例子，黄色部分其实也是需要总结的内容，不过如果没用三个单引号的分隔符，可能chatGPThuiba 黄色部分当成是一个命令，而不是要总结的文本：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504180941770.png" alt="image-20230504180941770"></p><h2 id="策略2：要求结构化输出"><a href="#策略2：要求结构化输出" class="headerlink" title="策略2：要求结构化输出"></a>策略2：要求结构化输出</h2><p>可以要求html、JSON这样的。在提问的时候可以说</p><blockquote><p>请帮我生成一列编造的书籍名称，作者，书的id，请用JSON的格式提供他们，以下是他们应该包含的键:book_id,title,author,genre.</p></blockquote><h2 id="策略3：要求模型检查是否满足条件"><a href="#策略3：要求模型检查是否满足条件" class="headerlink" title="策略3：要求模型检查是否满足条件"></a>策略3：要求模型检查是否满足条件</h2><p>如果任务存在假设没用满足，我们可以告诉模型首先检查这些假设,还可以考虑一些边界条件。</p><blockquote><p>你将得到一个文本是用”””引用的格式给出的，如果他包含了一系列的解释，请重写为&lt;结构化数据&gt;,如果不包含指示，那么就打印:”没有提供步骤</p></blockquote><h1 id="少量训练提示"><a href="#少量训练提示" class="headerlink" title="少量训练提示"></a>少量训练提示</h1><p>在要求模型执行任务之前，首先提供成功执行任务的示例。比如下图的例子，首先提供了一个child想知道耐心的问题，然后我们给出了grandparent应该回答的示范，因为我们要求回答需要一致性风格，所以当child问关于resilience的时候，chatGPT也应该给出相似的答案。</p><p> <img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504181612462.png" alt="image-20230504181612462"></p><h1 id="原则2：给模型思考的时间"><a href="#原则2：给模型思考的时间" class="headerlink" title="原则2：给模型思考的时间"></a>原则2：给模型思考的时间</h1><h2 id="策略1：具体完成任务的步骤"><a href="#策略1：具体完成任务的步骤" class="headerlink" title="策略1：具体完成任务的步骤"></a>策略1：具体完成任务的步骤</h2><p>如下图的例子，prompt中就给出了他应该执行的步骤。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504181900773.png" alt="image-20230504181900773"></p><p>下面是第二个例子，要求更具体一些：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182214341.png" alt="image-20230504182214341"></p><h2 id="策略2：指示模型在匆忙作出结论之前思考解决方案"><a href="#策略2：指示模型在匆忙作出结论之前思考解决方案" class="headerlink" title="策略2：指示模型在匆忙作出结论之前思考解决方案"></a>策略2：指示模型在匆忙作出结论之前思考解决方案</h2><p>比如下面的这个例子，其实学生算的是错的，但是GPT却看不出来：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182449899.png" alt="image-20230504182449899"></p><p>然后利用策略2进行改良：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182528844.png" alt="image-20230504182528844"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182618587.png" alt="image-20230504182618587"></p><p>经过这么做后，chatGPT就有了“思考能力了”。</p><h1 id="模型局限性"><a href="#模型局限性" class="headerlink" title="模型局限性"></a>模型局限性</h1><h2 id="幻觉（Hallucination"><a href="#幻觉（Hallucination" class="headerlink" title="幻觉（Hallucination)"></a>幻觉（Hallucination)</h2><p>即使模型在训练的过程中有大量的专业知识，但是其实它并没有完全记住它所看到的信息，所以它不了解知识边界，所以他可能会尝试回答关于晦涩主题的问题时，编造一些听起来合理但是实际上是错的的内容。</p><p>​下图是一个例子：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504182953634.png" alt="image-20230504182953634"></p><p>但其实并没有这个产品。</p><p><mark>一种减少幻觉的策略是要求模型首先从文本中找到任何相关的引用，然后要求它使用这些引用来回答问题，当然这只能减少，有时候源文档他也会编。。<mark></mark></mark></p><h1 id="二、迭代"><a href="#二、迭代" class="headerlink" title="二、迭代"></a>二、迭代</h1><p>一般来说，不会第一次尝试就能用到最终在引用程序中采用的提示，一般需要一个良好的迭代过程来改善。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504183445829.png" alt="image-20230504183445829"></p><p>下面是一个具体的示例，这是一个摘要椅子说明书的示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">fact_sheet_chair = """</span><br><span class="line">OVERVIEW</span><br><span class="line">- Part of a beautiful family of mid-century inspired office furniture, </span><br><span class="line">including filing cabinets, desks, bookcases, meeting tables, and more.</span><br><span class="line">- Several options of shell color and base finishes.</span><br><span class="line">- Available with plastic back and front upholstery (SWC-100) </span><br><span class="line">or full upholstery (SWC-110) in 10 fabric and 6 leather options.</span><br><span class="line">- Base finish options are: stainless steel, matte black, </span><br><span class="line">gloss white, or chrome.</span><br><span class="line">- Chair is available with or without armrests.</span><br><span class="line">- Suitable for home or business settings.</span><br><span class="line">- Qualified for contract use.</span><br><span class="line"></span><br><span class="line">CONSTRUCTION</span><br><span class="line">- 5-wheel plastic coated aluminum base.</span><br><span class="line">- Pneumatic chair adjust for easy raise/lower action.</span><br><span class="line"></span><br><span class="line">DIMENSIONS</span><br><span class="line">- WIDTH 53 CM | 20.87”</span><br><span class="line">- DEPTH 51 CM | 20.08”</span><br><span class="line">- HEIGHT 80 CM | 31.50”</span><br><span class="line">- SEAT HEIGHT 44 CM | 17.32”</span><br><span class="line">- SEAT DEPTH 41 CM | 16.14”</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">- Soft or hard-floor caster options.</span><br><span class="line">- Two choices of seat foam densities: </span><br><span class="line"> medium (1.8 lb/ft3) or high (2.8 lb/ft3)</span><br><span class="line">- Armless or 8 position PU armrests </span><br><span class="line"></span><br><span class="line">MATERIALS</span><br><span class="line">SHELL BASE GLIDER</span><br><span class="line">- Cast Aluminum with modified nylon PA6/PA66 coating.</span><br><span class="line">- Shell thickness: 10 mm.</span><br><span class="line">SEAT</span><br><span class="line">- HD36 foam</span><br><span class="line"></span><br><span class="line">COUNTRY OF ORIGIN</span><br><span class="line">- Italy</span><br><span class="line">"""</span><br><span class="line">prompt = f"""</span><br><span class="line">Your task is to help a marketing team create a </span><br><span class="line">description for a retail website of a product based </span><br><span class="line">on a technical fact sheet.</span><br><span class="line"></span><br><span class="line">Write a product description based on the information </span><br><span class="line">provided in the technical specifications delimited by </span><br><span class="line">triple backticks.</span><br><span class="line"></span><br><span class="line">Technical specifications: ```{fact_sheet_chair}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="1-期望句子短点"><a href="#1-期望句子短点" class="headerlink" title="1.期望句子短点"></a>1.期望句子短点</h2><p>直接运行的时候，会发现其摘要太长了，我们可能希望他短一点：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Your task is to help a marketing team create a </span><br><span class="line">description for a retail website of a product based </span><br><span class="line">on a technical fact sheet.</span><br><span class="line"></span><br><span class="line">Write a product description based on the information </span><br><span class="line">provided in the technical specifications delimited by </span><br><span class="line">triple backticks.</span><br><span class="line"></span><br><span class="line">Use at most 50 words.</span><br><span class="line"></span><br><span class="line">Technical specifications: ```{fact_sheet_chair}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>这里我门通过了<code>Use at most 50 words.</code>来进行了长度的限制，可以通过不同的方法来实现。</p><h2 id="2-让结果在我们期望的部分精确"><a href="#2-让结果在我们期望的部分精确" class="headerlink" title="2.让结果在我们期望的部分精确"></a>2.让结果在我们期望的部分精确</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Your task is to help a marketing team create a </span><br><span class="line">description for a retail website of a product based </span><br><span class="line">on a technical fact sheet.</span><br><span class="line"></span><br><span class="line">Write a product description based on the information </span><br><span class="line">provided in the technical specifications delimited by </span><br><span class="line">triple backticks.</span><br><span class="line"></span><br><span class="line">The description is intended for furniture retailers, </span><br><span class="line">so should be technical in nature and focus on the </span><br><span class="line">materials the product is constructed from.</span><br><span class="line"></span><br><span class="line">Use at most 50 words.</span><br><span class="line"></span><br><span class="line">Technical specifications: ```{fact_sheet_chair}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>这里通过下面的来实现的 :</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The description is intended for furniture retailers, </span><br><span class="line">so should be technical in nature and focus on the </span><br><span class="line">materials the product is constructed from.</span><br></pre></td></tr></tbody></table></figure><h1 id="三、摘要"><a href="#三、摘要" class="headerlink" title="三、摘要"></a>三、摘要</h1><p>下面是一个关于熊猫玩具的评论：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">prod_review = """</span><br><span class="line">Got this panda plush toy for my daughter's birthday, \</span><br><span class="line">who loves it and takes it everywhere. It's soft and \ </span><br><span class="line">super cute, and its face has a friendly look. It's \ </span><br><span class="line">a bit small for what I paid though. I think there \ </span><br><span class="line">might be other options that are bigger for the \ </span><br><span class="line">same price. It arrived a day earlier than expected, \ </span><br><span class="line">so I got to play with it myself before I gave it \ </span><br><span class="line">to her.</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>下面是一个生成摘要的评论：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Your task is to generate a short summary of a product \</span><br><span class="line">review from an ecommerce site. </span><br><span class="line"></span><br><span class="line">Summarize the review below, delimited by triple </span><br><span class="line">backticks, in at most 30 words. </span><br><span class="line"></span><br><span class="line">Review: ```{prod_review}```</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="1-生成特定需求的摘要"><a href="#1-生成特定需求的摘要" class="headerlink" title="1.生成特定需求的摘要"></a>1.生成特定需求的摘要</h2><p>通过修改提示，可以让生成一个更适用于自己业务中特定团队的摘要。下面的例子是需要一个运输和产品交付有关的摘要要求。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504184851720.png" alt="image-20230504184851720"></p><h2 id="2-提取信息的摘要"><a href="#2-提取信息的摘要" class="headerlink" title="2.提取信息的摘要"></a>2.提取信息的摘要</h2><p>比如下面的例子，因为我们要求的是提取相关信息，并且也说明是运输部门需要的，所以这里打印的结果没有给其他无用的信息，只说了这个产品的到达比期望的早了一天：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504185227612.png" alt="image-20230504185227612"></p><h2 id="3-总结多个评论"><a href="#3-总结多个评论" class="headerlink" title="3.总结多个评论"></a>3.总结多个评论</h2><p>我们有对于几种产品的评论：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">review_1 = prod_review </span><br><span class="line"></span><br><span class="line"># review for a standing lamp</span><br><span class="line">review_2 = """</span><br><span class="line">Needed a nice lamp for my bedroom, and this one \</span><br><span class="line">had additional storage and not too high of a price \</span><br><span class="line">point. Got it fast - arrived in 2 days. The string \</span><br><span class="line">to the lamp broke during the transit and the company \</span><br><span class="line">happily sent over a new one. Came within a few days \</span><br><span class="line">as well. It was easy to put together. Then I had a \</span><br><span class="line">missing part, so I contacted their support and they \</span><br><span class="line">very quickly got me the missing piece! Seems to me \</span><br><span class="line">to be a great company that cares about their customers \</span><br><span class="line">and products. </span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"># review for an electric toothbrush</span><br><span class="line">review_3 = """</span><br><span class="line">My dental hygienist recommended an electric toothbrush, \</span><br><span class="line">which is why I got this. The battery life seems to be \</span><br><span class="line">pretty impressive so far. After initial charging and \</span><br><span class="line">leaving the charger plugged in for the first week to \</span><br><span class="line">condition the battery, I've unplugged the charger and \</span><br><span class="line">been using it for twice daily brushing for the last \</span><br><span class="line">3 weeks all on the same charge. But the toothbrush head \</span><br><span class="line">is too small. I’ve seen baby toothbrushes bigger than \</span><br><span class="line">this one. I wish the head was bigger with different \</span><br><span class="line">length bristles to get between teeth better because \</span><br><span class="line">this one doesn’t.  Overall if you can get this one \</span><br><span class="line">around the $50 mark, it's a good deal. The manufactuer's \</span><br><span class="line">replacements heads are pretty expensive, but you can \</span><br><span class="line">get generic ones that're more reasonably priced. This \</span><br><span class="line">toothbrush makes me feel like I've been to the dentist \</span><br><span class="line">every day. My teeth feel sparkly clean! </span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line"># review for a blender</span><br><span class="line">review_4 = """</span><br><span class="line">So, they still had the 17 piece system on seasonal \</span><br><span class="line">sale for around $49 in the month of November, about \</span><br><span class="line">half off, but for some reason (call it price gouging) \</span><br><span class="line">around the second week of December the prices all went \</span><br><span class="line">up to about anywhere from between $70-$89 for the same \</span><br><span class="line">system. And the 11 piece system went up around $10 or \</span><br><span class="line">so in price also from the earlier sale price of $29. \</span><br><span class="line">So it looks okay, but if you look at the base, the part \</span><br><span class="line">where the blade locks into place doesn’t look as good \</span><br><span class="line">as in previous editions from a few years ago, but I \</span><br><span class="line">plan to be very gentle with it (example, I crush \</span><br><span class="line">very hard items like beans, ice, rice, etc. in the \ </span><br><span class="line">blender first then pulverize them in the serving size \</span><br><span class="line">I want in the blender then switch to the whipping \</span><br><span class="line">blade for a finer flour, and use the cross cutting blade \</span><br><span class="line">first when making smoothies, then use the flat blade \</span><br><span class="line">if I need them finer/less pulpy). Special tip when making \</span><br><span class="line">smoothies, finely cut and freeze the fruits and \</span><br><span class="line">vegetables (if using spinach-lightly stew soften the \ </span><br><span class="line">spinach then freeze until ready for use-and if making \</span><br><span class="line">sorbet, use a small to medium sized food processor) \ </span><br><span class="line">that you plan to use that way you can avoid adding so \</span><br><span class="line">much ice if at all-when making your smoothie. \</span><br><span class="line">After about a year, the motor was making a funny noise. \</span><br><span class="line">I called customer service but the warranty expired \</span><br><span class="line">already, so I had to buy another one. FYI: The overall \</span><br><span class="line">quality has gone done in these types of products, so \</span><br><span class="line">they are kind of counting on brand recognition and \</span><br><span class="line">consumer loyalty to maintain sales. Got it in about \</span><br><span class="line">two days.</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">reviews = [review_1, review_2, review_3, review_4]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们可以通过一个循环来做提示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(reviews)):</span><br><span class="line">    prompt = f"""</span><br><span class="line">    Your task is to generate a short summary of a product \ </span><br><span class="line">    review from an ecommerce site. </span><br><span class="line"></span><br><span class="line">    Summarize the review below, delimited by triple \</span><br><span class="line">    backticks in at most 20 words. </span><br><span class="line"></span><br><span class="line">    Review: ```{reviews[i]}```</span><br><span class="line">    """</span><br><span class="line"></span><br><span class="line">    response = get_completion(prompt)</span><br><span class="line">    print(i, response, "\n")</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="四、推断"><a href="#四、推断" class="headerlink" title="四、推断"></a>四、推断</h1><p>下面是一个关于灯的例子:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lamp_review = """</span><br><span class="line">Needed a nice lamp for my bedroom, and this one had \</span><br><span class="line">additional storage and not too high of a price point. \</span><br><span class="line">Got it fast.  The string to our lamp broke during the \</span><br><span class="line">transit and the company happily sent over a new one. \</span><br><span class="line">Came within a few days as well. It was easy to put \</span><br><span class="line">together.  I had a missing part, so I contacted their \</span><br><span class="line">support and they very quickly got me the missing piece! \</span><br><span class="line">Lumina seems to me to be a great company that cares \</span><br><span class="line">about their customers and products!!</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><h2 id="1-推断单个情感"><a href="#1-推断单个情感" class="headerlink" title="1.推断单个情感"></a>1.推断单个情感</h2><p>然后这里讲写一个提示来进行情绪分类：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">What is the sentiment of the following product review, </span><br><span class="line">which is delimited with triple backticks?</span><br><span class="line"></span><br><span class="line">Give your answer as a single word, either "positive" \</span><br><span class="line">or "negative".</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p><code>Give your answer as a single word, either "positive" \ or "negative".</code>通过这句话使得了给出简洁的结果(positive)。</p><h2 id="2-推断多个情感（多标签分类）"><a href="#2-推断多个情感（多标签分类）" class="headerlink" title="2.推断多个情感（多标签分类）"></a>2.推断多个情感（多标签分类）</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Identify a list of emotions that the writer of the \</span><br><span class="line">following review is expressing. Include no more than \</span><br><span class="line">five items in the list. Format your answer as a list of \</span><br><span class="line">lower-case words separated by commas.</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h2 id="3-识别愤怒情感"><a href="#3-识别愤怒情感" class="headerlink" title="3.识别愤怒情感"></a>3.识别愤怒情感</h2><p>对于评论的例子来说，可能我们会特别的关注是否有人的评论有特别愤怒倾向的倾斜，那么我们或许需要对这方面做更加特别的注意:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Is the writer of the following review expressing anger?\</span><br><span class="line">The review is delimited with triple backticks. \</span><br><span class="line">Give your answer as either yes or no.</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h2 id="4-信息提取"><a href="#4-信息提取" class="headerlink" title="4.信息提取"></a>4.信息提取</h2><p>下面的提示要求模型来提取购买物品和制造物品的公司名称：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Identify the following items from the review text: </span><br><span class="line">- Item purchased by reviewer</span><br><span class="line">- Company that made the item</span><br><span class="line"></span><br><span class="line">The review is delimited with triple backticks. \</span><br><span class="line">Format your response as a JSON object with \</span><br><span class="line">"Item" and "Brand" as the keys. </span><br><span class="line">If the information isn't present, use "unknown" \</span><br><span class="line">as the value.</span><br><span class="line">Make your response as short as possible.</span><br><span class="line">  </span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190358094-16831982403691.png" alt="image-20230504190358094"></p><h2 id="5-一次提取多个信息（同时做多个任务"><a href="#5-一次提取多个信息（同时做多个任务" class="headerlink" title="5.一次提取多个信息（同时做多个任务)"></a>5.一次提取多个信息（同时做多个任务)</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Identify the following items from the review text: </span><br><span class="line">- Sentiment (positive or negative)</span><br><span class="line">- Is the reviewer expressing anger? (true or false)</span><br><span class="line">- Item purchased by reviewer</span><br><span class="line">- Company that made the item</span><br><span class="line"></span><br><span class="line">The review is delimited with triple backticks. \</span><br><span class="line">Format your response as a JSON object with \</span><br><span class="line">"Sentiment", "Anger", "Item" and "Brand" as the keys.</span><br><span class="line">If the information isn't present, use "unknown" \</span><br><span class="line">as the value.</span><br><span class="line">Make your response as short as possible.</span><br><span class="line">Format the Anger value as a boolean.</span><br><span class="line"></span><br><span class="line">Review text: '''{lamp_review}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190507260.png" alt="image-20230504190507260"></p><h2 id="6-主题推断"><a href="#6-主题推断" class="headerlink" title="6.主题推断"></a>6.主题推断</h2><p>下面是一个虚构的报纸文章，讲政府工作人员对他们所工作的机构的感受：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">story = """</span><br><span class="line">In a recent survey conducted by the government, </span><br><span class="line">public sector employees were asked to rate their level </span><br><span class="line">of satisfaction with the department they work at. </span><br><span class="line">The results revealed that NASA  was the most popular </span><br><span class="line">department with a satisfaction rating of 95%.</span><br><span class="line"></span><br><span class="line">One NASA employee, John Smith, commented on the findings, </span><br><span class="line">stating, "I'm not surprised that NASA came out on top. </span><br><span class="line">It's a great place to work with amazing people and </span><br><span class="line">incredible opportunities. I'm proud to be a part of </span><br><span class="line">such an innovative organization."</span><br><span class="line"></span><br><span class="line">The results were also welcomed by NASA's management team, </span><br><span class="line">with Director Tom Johnson stating, "We are thrilled to </span><br><span class="line">hear that our employees are satisfied with their work at NASA. </span><br><span class="line">We have a talented and dedicated team who work tirelessly </span><br><span class="line">to achieve our goals, and it's fantastic to see that their </span><br><span class="line">hard work is paying off."</span><br><span class="line"></span><br><span class="line">The survey also revealed that the </span><br><span class="line">Social Security Administration had the lowest satisfaction </span><br><span class="line">rating, with only 45% of employees indicating they were </span><br><span class="line">satisfied with their job. The government has pledged to </span><br><span class="line">address the concerns raised by employees in the survey and </span><br><span class="line">work towards improving job satisfaction across all departments.</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>然后，下面的提示可以询问模型确定文本中正在讨论的五个主题：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Determine five topics that are being discussed in the \</span><br><span class="line">following text, which is delimited by triple backticks.</span><br><span class="line"></span><br><span class="line">Make each item one or two words long. </span><br><span class="line"></span><br><span class="line">Format your response as a list of items separated by commas.</span><br><span class="line"></span><br><span class="line">Text sample: '''{story}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190723993.png" alt="image-20230504190723993"></p><p>该应用场景就可以是比如说报纸分类，或者是博客的标签分类，假如我们有这些标签：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">topic_list = [</span><br><span class="line">    "nasa", "local government", "engineering", </span><br><span class="line">    "employee satisfaction", "federal government"</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>那么我们可以通过下面的提示，来确定是否上面的主题列表的每个项目都符合这个文章的主题</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">Determine whether each item in the following list of \</span><br><span class="line">topics is a topic in the text below, which</span><br><span class="line">is delimited with triple backticks.</span><br><span class="line"></span><br><span class="line">Give your answer as list with 0 or 1 for each topic.\</span><br><span class="line"></span><br><span class="line">List of topics: {", ".join(topic_list)}</span><br><span class="line"></span><br><span class="line">Text sample: '''{story}'''</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>那么就会得到这个结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504190918819.png" alt="image-20230504190918819"></p><h2 id="7-新闻提醒"><a href="#7-新闻提醒" class="headerlink" title="7.新闻提醒"></a>7.新闻提醒</h2><p>下面的代码是实现了，如果当前的“新闻”是NASA的话，就会提醒，<mark>可以说是推断的一种应用吧<mark></mark></mark></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">topic_dict = {i.split(': ')[0]: int(i.split(': ')[1]) for i in response.split(sep='\n')}</span><br><span class="line">if topic_dict['nasa'] &lt;mark&gt; 1:</span><br><span class="line">    print("ALERT: New NASA story!")</span><br></pre></td></tr></tbody></table></figure><h1 id="五、转换"><a href="#五、转换" class="headerlink" title="五、转换"></a>五、转换</h1><p>LLM非常擅长将输入转换成不同的格式，例如多语种文本翻译、拼写及语法纠正、语气调整、格式转换等。本章节将介绍如何使用编程的方式，调用API接口来实现“文本转换”功能。</p><h2 id="1-翻译"><a href="#1-翻译" class="headerlink" title="1.翻译"></a>1.翻译</h2><p>下面是一个中文翻译西班牙语的例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">将以下中文翻译成西班牙语: \ </span><br><span class="line">```您好，我想订购一个搅拌机。```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-2识别语种"><a href="#1-2识别语种" class="headerlink" title="1.2识别语种"></a>1.2识别语种</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">请告诉我以下文本是什么语种: </span><br><span class="line">```Combien coûte le lampadaire?```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3多语种翻译"><a href="#1-3多语种翻译" class="headerlink" title="1.3多语种翻译"></a>1.3多语种翻译</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">请将以下文本分别翻译成中文、英文、法语和西班牙语: </span><br><span class="line">```I want to order a basketball.```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4翻译-正式-x2F-非正式语气"><a href="#1-4翻译-正式-x2F-非正式语气" class="headerlink" title="1.4翻译+正式/非正式语气"></a>1.4翻译+正式/非正式语气</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">请将以下文本翻译成中文，分别展示成正式与非正式两种语气: </span><br><span class="line">```Would you like to order a pillow?```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><h3 id="1-5通用翻译器"><a href="#1-5通用翻译器" class="headerlink" title="1.5通用翻译器"></a>1.5通用翻译器</h3><p>交流的用户可能来自各个不同的国家，使用不同的语言，因此我们需要一个通用翻译器，识别各个消息的语种，并翻译成目标用户的母语，从而实现更方便的跨国交流。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">user_messages = [</span><br><span class="line">  "La performance du système est plus lente que d'habitude.",  # System performance is slower than normal         </span><br><span class="line">  "Mi monitor tiene píxeles que no se iluminan.",              # My monitor has pixels that are not lighting</span><br><span class="line">  "Il mio mouse non funziona",                                 # My mouse is not working</span><br><span class="line">  "Mój klawisz Ctrl jest zepsuty",                             # My keyboard has a broken control key</span><br><span class="line">  "我的屏幕在闪烁"                                             # My screen is flashing</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">for issue in user_messages:</span><br><span class="line">    prompt = f"告诉我以下文本是什么语种，直接输出语种，如法语，无需输出标点符号: ```{issue}```"</span><br><span class="line">    lang = get_completion(prompt)</span><br><span class="line">    print(f"原始消息 ({lang}): {issue}\n")</span><br><span class="line"></span><br><span class="line">    prompt = f"""</span><br><span class="line">    将以下消息分别翻译成英文和中文，并写成</span><br><span class="line">    中文翻译：xxx</span><br><span class="line">    英文翻译：yyy</span><br><span class="line">    的格式：</span><br><span class="line">    ```{issue}```</span><br><span class="line">    """</span><br><span class="line">    response = get_completion(prompt)</span><br><span class="line">    print(response, "\n&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;&lt;mark&gt;=")</span><br></pre></td></tr></tbody></table></figure><p>打印结果:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193143390.png" alt="image-20230504193143390"></p><h2 id="2-语气-x2F-风格"><a href="#2-语气-x2F-风格" class="headerlink" title="2.语气/风格"></a>2.语气/风格</h2><p>写作的语气往往会根据受众对象而有所调整。例如，对于工作邮件，我们常常需要使用正式语气与书面用词，而对同龄朋友的微信聊天，可能更多地会使用轻松、口语化的语气。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">将以下文本翻译成商务信函的格式: </span><br><span class="line">```小老弟，我小羊，上回你说咱部门要采购的显示器是多少寸来着？```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193305409.png" alt="image-20230504193305409"></p><h2 id="3-格式转换"><a href="#3-格式转换" class="headerlink" title="3.格式转换"></a>3.格式转换</h2><p>在下述例子中，我们有一个包含餐厅员工姓名和电子邮件的列表的JSON，我们希望将其从JSON转换为HTML。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data_json = { "resturant employees" :[ </span><br><span class="line">    {"name":"Shyam", "email":"shyamjaiswal@gmail.com"},</span><br><span class="line">    {"name":"Bob", "email":"bob32@gmail.com"},</span><br><span class="line">    {"name":"Jai", "email":"jai87@gmail.com"}</span><br><span class="line">]}</span><br><span class="line"></span><br><span class="line">prompt = f"""</span><br><span class="line">将以下Python字典从JSON转换为HTML表格，保留表格标题和列名：{data_json}</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193352603.png" alt="image-20230504193352603"></p><h2 id="4-拼写及语法纠正-强烈推荐"><a href="#4-拼写及语法纠正-强烈推荐" class="headerlink" title="4.拼写及语法纠正(强烈推荐)"></a>4.拼写及语法纠正(强烈推荐)</h2><p>这个功能大佬非常推荐</p><p>以下给了一个例子，有一个句子列表，其中有些句子存在拼写或语法问题，有些则没有，我们循环遍历每个句子，要求模型校对文本，如果正确则输出“未发现错误”，如果错误则输出纠正后的文本。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">text = [ </span><br><span class="line">  "The girl with the black and white puppies have a ball.",  # The girl has a ball.</span><br><span class="line">  "Yolanda has her notebook.", # ok</span><br><span class="line">  "Its going to be a long day. Does the car need it’s oil changed?",  # Homonyms</span><br><span class="line">  "Their goes my freedom. There going to bring they’re suitcases.",  # Homonyms</span><br><span class="line">  "Your going to need you’re notebook.",  # Homonyms</span><br><span class="line">  "That medicine effects my ability to sleep. Have you heard of the butterfly affect?", # Homonyms</span><br><span class="line">  "This phrase is to cherck chatGPT for speling abilitty"  # spelling</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p>那么可以编写如下的提示:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in range(len(text)):</span><br><span class="line">    prompt = f"""请校对并更正以下文本，注意纠正文本保持原始语种，无需输出原始文本。</span><br><span class="line">    如果您没有发现任何错误，请说“未发现错误”。</span><br><span class="line">    </span><br><span class="line">    例如：</span><br><span class="line">    输入：I are happy.</span><br><span class="line">    输出：I am happy.</span><br><span class="line">    ```{text[i]}```"""</span><br><span class="line">    response = get_completion(prompt)</span><br><span class="line">    print(i, response)</span><br></pre></td></tr></tbody></table></figure><p>打印结果:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193553626.png" alt="image-20230504193553626"></p><h2 id="5-基于Readlines的纠错"><a href="#5-基于Readlines的纠错" class="headerlink" title="5.基于Readlines的纠错"></a>5.基于Readlines的纠错</h2><p>下图是一个示例，可以看到，通过使用readlines这个库非常的直观。</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504193932653.png" alt="image-20230504193932653"></p><h2 id="6-一个综合样例：文本翻译-拼写纠正-风格调整-格式转换"><a href="#6-一个综合样例：文本翻译-拼写纠正-风格调整-格式转换" class="headerlink" title="6.一个综合样例：文本翻译+拼写纠正+风格调整+格式转换"></a>6.一个综合样例：文本翻译+拼写纠正+风格调整+格式转换</h2><p>``</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">text = f"""</span><br><span class="line">Got this for my daughter for her birthday cuz she keeps taking \</span><br><span class="line">mine from my room.  Yes, adults also like pandas too.  She takes \</span><br><span class="line">it everywhere with her, and it's super soft and cute.  One of the \</span><br><span class="line">ears is a bit lower than the other, and I don't think that was \</span><br><span class="line">designed to be asymmetrical. It's a bit small for what I paid for it \</span><br><span class="line">though. I think there might be other options that are bigger for \</span><br><span class="line">the same price.  It arrived a day earlier than expected, so I got \</span><br><span class="line">to play with it myself before I gave it to my daughter.</span><br><span class="line">"""</span><br><span class="line"></span><br><span class="line">prompt = f"""</span><br><span class="line">针对以下三个反引号之间的英文评论文本，</span><br><span class="line">首先进行拼写及语法纠错，</span><br><span class="line">然后将其转化成中文，</span><br><span class="line">再将其转化成优质淘宝评论的风格，从各种角度出发，分别说明产品的优点与缺点，并进行总结。</span><br><span class="line">润色一下描述，使评论更具有吸引力。</span><br><span class="line">输出结果格式为：</span><br><span class="line">【优点】xxx</span><br><span class="line">【缺点】xxx</span><br><span class="line">【总结】xxx</span><br><span class="line">注意，只需填写xxx部分，并分段输出。</span><br><span class="line">将结果输出成Markdown格式。</span><br><span class="line">```{text}```</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">display(Markdown(response))</span><br></pre></td></tr></tbody></table></figure><p>打印：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504194051241.png" alt="image-20230504194051241"></p><h1 id="六、扩展"><a href="#六、扩展" class="headerlink" title="六、扩展"></a>六、扩展</h1><p>扩展是将短文本，例如一组说明或主题列表，输入到大型语言模型中，让模型生成更长的文本，例如基于某个主题的电子邮件或论文。这样做有一些很好的用途，例如将大型语言模型用作头脑风暴的伙伴。但这种做法也存在一些问题，例如某人可能会使用它来生成大量垃圾邮件。因此，当你使用大型语言模型的这些功能时，请仅以负责任的方式和有益于人们的方式使用它们。</p><h2 id="1-定制邮件"><a href="#1-定制邮件" class="headerlink" title="1.定制邮件"></a>1.定制邮件</h2><p>我们将根据客户评价和情感撰写自定义电子邮件响应。因此，我们将给定客户评价和情感，并生成自定义响应即使用 LLM 根据客户评价和评论情感生成定制电子邮件。</p><p>我们首先给出一个示例，包括一个评论及对应的情感</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># given the sentiment from the lesson on "inferring",</span><br><span class="line"># and the original customer message, customize the email</span><br><span class="line">sentiment = "negative"</span><br><span class="line"></span><br><span class="line"># review for a blender</span><br><span class="line">review = f"""</span><br><span class="line">So, they still had the 17 piece system on seasonal \</span><br><span class="line">sale for around $49 in the month of November, about \</span><br><span class="line">half off, but for some reason (call it price gouging) \</span><br><span class="line">around the second week of December the prices all went \</span><br><span class="line">up to about anywhere from between $70-$89 for the same \</span><br><span class="line">system. And the 11 piece system went up around $10 or \</span><br><span class="line">so in price also from the earlier sale price of $29. \</span><br><span class="line">So it looks okay, but if you look at the base, the part \</span><br><span class="line">where the blade locks into place doesn’t look as good \</span><br><span class="line">as in previous editions from a few years ago, but I \</span><br><span class="line">plan to be very gentle with it (example, I crush \</span><br><span class="line">very hard items like beans, ice, rice, etc. in the \ </span><br><span class="line">blender first then pulverize them in the serving size \</span><br><span class="line">I want in the blender then switch to the whipping \</span><br><span class="line">blade for a finer flour, and use the cross cutting blade \</span><br><span class="line">first when making smoothies, then use the flat blade \</span><br><span class="line">if I need them finer/less pulpy). Special tip when making \</span><br><span class="line">smoothies, finely cut and freeze the fruits and \</span><br><span class="line">vegetables (if using spinach-lightly stew soften the \ </span><br><span class="line">spinach then freeze until ready for use-and if making \</span><br><span class="line">sorbet, use a small to medium sized food processor) \ </span><br><span class="line">that you plan to use that way you can avoid adding so \</span><br><span class="line">much ice if at all-when making your smoothie. \</span><br><span class="line">After about a year, the motor was making a funny noise. \</span><br><span class="line">I called customer service but the warranty expired \</span><br><span class="line">already, so I had to buy another one. FYI: The overall \</span><br><span class="line">quality has gone done in these types of products, so \</span><br><span class="line">they are kind of counting on brand recognition and \</span><br><span class="line">consumer loyalty to maintain sales. Got it in about \</span><br><span class="line">two days.</span><br><span class="line">"""</span><br><span class="line"># 我们可以在推理那章学习到如何对一个评论判断其情感倾向</span><br><span class="line">sentiment = "negative"</span><br><span class="line"></span><br><span class="line"># 一个产品的评价</span><br><span class="line">review = f"""</span><br><span class="line">他们在11月份的季节性销售期间以约49美元的价格出售17件套装，折扣约为一半。\</span><br><span class="line">但由于某些原因（可能是价格欺诈），到了12月第二周，同样的套装价格全都涨到了70美元到89美元不等。\</span><br><span class="line">11件套装的价格也上涨了大约10美元左右。\</span><br><span class="line">虽然外观看起来还可以，但基座上锁定刀片的部分看起来不如几年前的早期版本那么好。\</span><br><span class="line">不过我打算非常温柔地使用它，例如，\</span><br><span class="line">我会先在搅拌机中将像豆子、冰、米饭等硬物研磨，然后再制成所需的份量，\</span><br><span class="line">切换到打蛋器制作更细的面粉，或者在制作冰沙时先使用交叉切割刀片，然后使用平面刀片制作更细/不粘的效果。\</span><br><span class="line">制作冰沙时，特别提示：\</span><br><span class="line">将水果和蔬菜切碎并冷冻（如果使用菠菜，则轻轻煮软菠菜，然后冷冻直到使用；\</span><br><span class="line">如果制作果酱，则使用小到中号的食品处理器），这样可以避免在制作冰沙时添加太多冰块。\</span><br><span class="line">大约一年后，电机发出奇怪的噪音，我打电话给客服，但保修已经过期了，所以我不得不再买一个。\</span><br><span class="line">总的来说，这些产品的总体质量已经下降，因此它们依靠品牌认可和消费者忠诚度来维持销售。\</span><br><span class="line">货物在两天内到达。</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>这里我们将根据情感定制回复，这里的指令是：假设你是一个客户服务AI助手，你的任务是为客户发送电子邮件回复，根据通过三个反引号分隔的客户电子邮件，生成一封回复以感谢客户的评价：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">你是一位客户服务的AI助手。</span><br><span class="line">你的任务是给一位重要客户发送邮件回复。</span><br><span class="line">根据客户通过“```”分隔的评价，生成回复以感谢客户的评价。提醒模型使用评价中的具体细节</span><br><span class="line">用简明而专业的语气写信。</span><br><span class="line">作为“AI客户代理”签署电子邮件。</span><br><span class="line">客户评论：</span><br><span class="line">```{review}```</span><br><span class="line">评论情感：{sentiment}</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>打印：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504194949096.png" alt="image-20230504194949096"></p><h2 id="2-温度系数的使用（重要参数）"><a href="#2-温度系数的使用（重要参数）" class="headerlink" title="2.温度系数的使用（重要参数）"></a>2.温度系数的使用（重要参数）</h2><p>接下来，我们将使用语言模型的一个称为“温度”的参数，它将允许我们改变模型响应的多样性。您可以<mark>将温度视为模型探索或随机性的程度<mark>。</mark></mark></p><p>例如，在一个特定的短语中，“我的最爱食品”最有可能的下一个词是“比萨”，其次最有可能的是“寿司”和“塔可”。因此，在温度为零时，模型将总是选择最有可能的下一个词，而在较高的温度下，它还将选择其中一个不太可能的词，在更高的温度下，它甚至可能选择塔可，而这种可能性仅为五分之一。您可以想象，随着模型继续生成更多单词的最终响应，“我的最爱食品是比萨”将会与第一个响应“我的最爱食品是塔可”产生差异。因此，随着模型的继续，这两个响应将变得越来越不同。</p><p>一般来说，在构建需要可预测响应的应用程序时，我建议使用温度为零。在所有课程中，我们一直设置温度为零，<mark>如果您正在尝试构建一个可靠和可预测的系统，我认为您应该选择这个温度。如果您尝试以更具创意的方式使用模型，可能需要更广泛地输出不同的结果，那么您可能需要使用更高的温度。<mark></mark></mark></p><p>示例:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># given the sentiment from the lesson on "inferring",</span><br><span class="line"># and the original customer message, customize the email</span><br><span class="line">sentiment = "negative"</span><br><span class="line"></span><br><span class="line"># review for a blender</span><br><span class="line">review = f"""</span><br><span class="line">So, they still had the 17 piece system on seasonal \</span><br><span class="line">sale for around $49 in the month of November, about \</span><br><span class="line">half off, but for some reason (call it price gouging) \</span><br><span class="line">around the second week of December the prices all went \</span><br><span class="line">up to about anywhere from between $70-$89 for the same \</span><br><span class="line">system. And the 11 piece system went up around $10 or \</span><br><span class="line">so in price also from the earlier sale price of $29. \</span><br><span class="line">So it looks okay, but if you look at the base, the part \</span><br><span class="line">where the blade locks into place doesn’t look as good \</span><br><span class="line">as in previous editions from a few years ago, but I \</span><br><span class="line">plan to be very gentle with it (example, I crush \</span><br><span class="line">very hard items like beans, ice, rice, etc. in the \ </span><br><span class="line">blender first then pulverize them in the serving size \</span><br><span class="line">I want in the blender then switch to the whipping \</span><br><span class="line">blade for a finer flour, and use the cross cutting blade \</span><br><span class="line">first when making smoothies, then use the flat blade \</span><br><span class="line">if I need them finer/less pulpy). Special tip when making \</span><br><span class="line">smoothies, finely cut and freeze the fruits and \</span><br><span class="line">vegetables (if using spinach-lightly stew soften the \ </span><br><span class="line">spinach then freeze until ready for use-and if making \</span><br><span class="line">sorbet, use a small to medium sized food processor) \ </span><br><span class="line">that you plan to use that way you can avoid adding so \</span><br><span class="line">much ice if at all-when making your smoothie. \</span><br><span class="line">After about a year, the motor was making a funny noise. \</span><br><span class="line">I called customer service but the warranty expired \</span><br><span class="line">already, so I had to buy another one. FYI: The overall \</span><br><span class="line">quality has gone done in these types of products, so \</span><br><span class="line">they are kind of counting on brand recognition and \</span><br><span class="line">consumer loyalty to maintain sales. Got it in about \</span><br><span class="line">two days.</span><br><span class="line">"""</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以编写prompt:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">prompt = f"""</span><br><span class="line">你是一名客户服务的AI助手。</span><br><span class="line">你的任务是给一位重要的客户发送邮件回复。</span><br><span class="line">根据通过“```”分隔的客户电子邮件生成回复，以感谢客户的评价。</span><br><span class="line">如果情感是积极的或中性的，感谢他们的评价。</span><br><span class="line">如果情感是消极的，道歉并建议他们联系客户服务。</span><br><span class="line">请确保使用评论中的具体细节。</span><br><span class="line">以简明和专业的语气写信。</span><br><span class="line">以“AI客户代理”的名义签署电子邮件。</span><br><span class="line">客户评价：```{review}```</span><br><span class="line">评论情感：{sentiment}</span><br><span class="line">"""</span><br><span class="line">response = get_completion(prompt, temperature=0.7)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>这里设置了温度，得到了下面的结果：</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504195237697.png" alt="image-20230504195237697"></p><p><mark>在温度为零时，每次执行相同的提示时，您应该期望获得相同的完成。而使用温度为0.7，则每次都会获得不同的输出。<mark></mark></mark></p><p>所以，您可以看到它与我们之前收到的电子邮件不同。让我们再次执行它，以显示我们将再次获得不同的电子邮件。</p><p>因此，我建议您自己尝试温度，以查看输出如何变化。总之，在更高的温度下，模型的输出更加随机。您几乎可以将其视为在更高的温度下，助手更易分心，但也许更有创造力。</p><h1 id="七、聊天机器人"><a href="#七、聊天机器人" class="headerlink" title="七、聊天机器人"></a>七、聊天机器人</h1><p>像 ChatGPT 这样的聊天模型实际上是组装成以一系列消息作为输入，并返回一个模型生成的消息作为输出的。虽然聊天格式的设计旨在使这种多轮对话变得容易，但我们通过之前的学习可以知道，它对于没有任何对话的单轮任务也同样有用。</p><p>接下来，我们将定义两个辅助函数。第一个是单轮的，我们将prompt放入看起来像是某种用户消息的东西中。另一个则传入一个消息列表。这些消息可以来自不同的角色，我们会描述一下这些角色。</p><p>第一条消息是一个系统消息，它提供了一个总体的指示，然后在这个消息之后，我们有用户和助手之间的交替。如果你曾经使用过 ChatGPT 网页界面，那么你的消息是用户消息，而 ChatGPT 的消息是助手消息。系统消息则有助于设置助手的行为和角色，并作为对话的高级指示。你可以想象它在助手的耳边低语，引导它的回应，而用户不会注意到系统消息。</p><p>因此，作为用户，如果你曾经使用过 ChatGPT，你可能不知道 ChatGPT 的系统消息是什么，这是有意为之的。<mark>系统消息的好处是为开发者提供了一种方法，在不让请求本身成为对话的一部分的情况下，引导助手并指导其回应。<mark></mark></mark></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import openai</span><br><span class="line"></span><br><span class="line">OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY2")</span><br><span class="line">openai.api_key = OPENAI_API_KEY</span><br><span class="line"></span><br><span class="line">def get_completion(prompt, model="gpt-3.5-turbo"):</span><br><span class="line">    messages = [{"role": "user", "content": prompt}]</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=0, # 控制模型输出的随机程度</span><br><span class="line">    )</span><br><span class="line">    return response.choices[0].message["content"]</span><br><span class="line"></span><br><span class="line">def get_completion_from_messages(messages, model="gpt-3.5-turbo", temperature=0):</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=temperature, # 控制模型输出的随机程度</span><br><span class="line">    )</span><br><span class="line">#     print(str(response.choices[0].message))</span><br><span class="line">    return response.choices[0].message["content"]</span><br></pre></td></tr></tbody></table></figure><p>系统消息说，你是一个说话像莎士比亚的助手。这是我们向助手描述它应该如何表现的方式。然后，第一个用户消息是，给我讲个笑话。接下来的消息是，为什么鸡会过马路？然后最后一个用户消息是，我不知道。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 中文</span><br><span class="line">messages =  [  </span><br><span class="line">{'role':'system', 'content':'你是一个像莎士比亚一样说话的助手。'},    </span><br><span class="line">{'role':'user', 'content':'给我讲个笑话'},   </span><br><span class="line">{'role':'assistant', 'content':'鸡为什么过马路'},   </span><br><span class="line">{'role':'user', 'content':'我不知道'}  ]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response = get_completion_from_messages(messages, temperature=1)</span><br><span class="line">print(response)</span><br><span class="line">#因为它要去找“母鸡”。哈哈哈！（注：此为英文双关语，"chicken"是鸡的意思，也是胆小的意思；"cross the road"是过马路的意思，也是“破坏规则”的意思。</span><br></pre></td></tr></tbody></table></figure><p>每次与语言模型的交互都是一个独立的交互，这意味着我们必须提供所有相关的消息，以便模型在当前对话中进行引用。<mark>如果想让模型引用或 “记住” 对话的早期部分，则必须在模型的输入中提供早期的交流。我们将其称为上下文。<mark></mark></mark></p><h2 id="1-聊天机器人"><a href="#1-聊天机器人" class="headerlink" title="1.聊天机器人"></a>1.聊天机器人</h2><p>现在，我们构建一个 “订餐机器人”，我们需要它自动收集用户信息，接受比萨饼店的订单。</p><p>下面这个函数将收集我们的用户消息，以便我们可以避免手动输入，就像我们在刚刚上面做的那样。这个函数将从我们下面构建的用户界面中收集提示，然后将其附加到一个名为上下文的列表中，并在每次调用模型时使用该上下文。模型的响应也会被添加到上下文中，所以模型消息和用户消息都被添加到上下文中，因此上下文逐渐变长。这样，模型就有了需要的信息来确定下一步要做什么。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def collect_messages(_):</span><br><span class="line">    prompt = inp.value_input</span><br><span class="line">    inp.value = ''</span><br><span class="line">    context.append({'role':'user', 'content':f"{prompt}"})</span><br><span class="line">    response = get_completion_from_messages(context) </span><br><span class="line">    context.append({'role':'assistant', 'content':f"{response}"})</span><br><span class="line">    panels.append(</span><br><span class="line">        pn.Row('User:', pn.pane.Markdown(prompt, width=600)))</span><br><span class="line">    panels.append(</span><br><span class="line">        pn.Row('Assistant:', pn.pane.Markdown(response, width=600, style={'background-color': '#F6F6F6'})))</span><br><span class="line"> </span><br><span class="line">    return pn.Column(*panels)</span><br></pre></td></tr></tbody></table></figure><p>现在，我们将设置并运行这个 UI 来显示订单机器人。初始的上下文包含了包含菜单的系统消息。请注意，上下文会随着时间的推移而不断增长。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!pip install panel</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># 中文</span><br><span class="line">import panel as pn  # GUI</span><br><span class="line">pn.extension()</span><br><span class="line"></span><br><span class="line">panels = [] # collect display </span><br><span class="line"></span><br><span class="line">context = [{'role':'system', 'content':"""</span><br><span class="line">你是订餐机器人，为披萨餐厅自动收集订单信息。</span><br><span class="line">你要首先问候顾客。然后等待用户回复收集订单信息。收集完信息需确认顾客是否还需要添加其他内容。</span><br><span class="line">最后需要询问是否自取或外送，如果是外送，你要询问地址。</span><br><span class="line">最后告诉顾客订单总金额，并送上祝福。</span><br><span class="line"></span><br><span class="line">请确保明确所有选项、附加项和尺寸，以便从菜单中识别出该项唯一的内容。</span><br><span class="line">你的回应应该以简短、非常随意和友好的风格呈现。</span><br><span class="line"></span><br><span class="line">菜单包括：</span><br><span class="line"></span><br><span class="line">菜品：</span><br><span class="line">意式辣香肠披萨（大、中、小） 12.95、10.00、7.00</span><br><span class="line">芝士披萨（大、中、小） 10.95、9.25、6.50</span><br><span class="line">茄子披萨（大、中、小） 11.95、9.75、6.75</span><br><span class="line">薯条（大、小） 4.50、3.50</span><br><span class="line">希腊沙拉 7.25</span><br><span class="line"></span><br><span class="line">配料：</span><br><span class="line">奶酪 2.00</span><br><span class="line">蘑菇 1.50</span><br><span class="line">香肠 3.00</span><br><span class="line">加拿大熏肉 3.50</span><br><span class="line">AI酱 1.50</span><br><span class="line">辣椒 1.00</span><br><span class="line"></span><br><span class="line">饮料：</span><br><span class="line">可乐（大、中、小） 3.00、2.00、1.00</span><br><span class="line">雪碧（大、中、小） 3.00、2.00、1.00</span><br><span class="line">瓶装水 5.00</span><br><span class="line">"""} ]  # accumulate messages</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inp = pn.widgets.TextInput(value="Hi", placeholder='Enter text here…')</span><br><span class="line">button_conversation = pn.widgets.Button(name="Chat!")</span><br><span class="line"></span><br><span class="line">interactive_conversation = pn.bind(collect_messages, button_conversation)</span><br><span class="line"></span><br><span class="line">dashboard = pn.Column(</span><br><span class="line">    inp,</span><br><span class="line">    pn.Row(button_conversation),</span><br><span class="line">    pn.panel(interactive_conversation, loading_indicator=True, height=300),</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dashboard</span><br></pre></td></tr></tbody></table></figure><p>现在我们可以要求模型创建一个 JSON 摘要发送给订单系统。</p><p>所以我们现在追加另一个系统消息，它是另一条prompt，我们说创建一个刚刚订单的 JSON 摘要，列出每个项目的价格，字段应包括1）披萨，包括尺寸，2）配料列表，3）饮料列表，4）辅菜列表，包括尺寸，最后是总价格。这里也可以在这里使用用户消息，不一定是系统消息。</p><p>请注意，这里我们使用了一个较低的temperature，因为对于这些类型的任务，我们希望输出相对可预测。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">messages =  context.copy()</span><br><span class="line">messages.append(</span><br><span class="line">{'role':'system', 'content':'创建上一个食品订单的 json 摘要。\</span><br><span class="line">逐项列出每件商品的价格，字段应该是 1) 披萨，包括大小 2) 配料列表 3) 饮料列表，包括大小 4) 配菜列表包括大小 5) 总价'},    </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">response = get_completion_from_messages(messages, temperature=0)</span><br><span class="line">print(response)</span><br></pre></td></tr></tbody></table></figure><p>输出:</p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/ChatGPTwuendawangkebiji.assets/image-20230504200013220.png" alt="image-20230504200013220"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 自然语言处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Prompt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《软件测试的艺术》原书第3版的3.3节笔记-用于代码检查的错误列表</title>
      <link href="/2023/06/24/%E7%94%A8%E4%BA%8E%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5%E7%9A%84%E9%94%99%E8%AF%AF%E5%88%97%E8%A1%A8/"/>
      <url>/2023/06/24/%E7%94%A8%E4%BA%8E%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF%E6%A3%80%E6%9F%A5%E7%9A%84%E9%94%99%E8%AF%AF%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="用于代码检查的错误列表"><a href="#用于代码检查的错误列表" class="headerlink" title="用于代码检查的错误列表"></a>用于代码检查的错误列表</h1><p>《软件测试的艺术》原书第3版的3.3节笔记。代码检查过程的一个重要部分就是<strong>对照一份错误列表，来检查程序是否存在常见错误。</strong>在写代码的时候还是要小心考虑是否自己的代码也有错误列表中描述的问题。</p><h1 id="表格总结"><a href="#表格总结" class="headerlink" title="表格总结"></a>表格总结</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_17" alt="img"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_18" alt="img"></p><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_35374439_19" alt="img"></p><h4 id="3-3-1-数据引用错误"><a href="#3-3-1-数据引用错误" class="headerlink" title="3.3.1 数据引用错误"></a>3.3.1 数据引用错误</h4><p>1.是否有引用的变量未赋值或未初始化？</p><p>2.对于所有的数组引用，是否每一个下标的值都在相应维规定的界限之内？3.对于所有的数组引用，是否每一个下标的值都是整数？</p><p>4.对于所有的通过指针或引用变量的引用，当前引用的内存单元是否分配？</p><p>5.如果一个内存区域具有不同属性的别名，当通过别名进行引用时，内存区域中的数据值是否具有正确的属性？</p><p>6.变量值的类型或属性是否与编译器所预期的一致？</p><p>7.在使用的计算机上，当内存分配的单元小于内存可寻址的单元大小时，是否存在直接或间接的寻址错误？</p><p>8.当使用指针或引用变量时，被引用的内存的属性是否与编译器所预期的一致？</p><p>9.假如一个数据结构在多个过程或子程序中被引用，那么每个过程或子程序对该结构的定义是否都相同？</p><p>10.如果字符串有索引，当对数组进行索引操作或下标引用，字符串的边界取值是否有“仅差一个”（off-by-one）的错误？</p><p>11.对于面向对象的语言，是否所有的继承需求都在实现类中得到了满足？</p><h4 id="3-3-2-数据声明错误"><a href="#3-3-2-数据声明错误" class="headerlink" title="3.3.2 数据声明错误"></a>3.3.2 数据声明错误</h4><p>1.是否所有的变量都进行了明确的声明？</p><p>2.如果变量所有的属性在声明中没有明确说明，那么默认的属性能否被正确理解？</p><p>3.如果变量在声明语句中被初始化，那么它的初始化是否正确？</p><p>4.是否每个变量都被赋予了正确的长度和数据类型？5.变量的初始化是否与其存储空间的类型一致？</p><p>6.是否存在着相似名称的变量（如VOLT和VOLTS）？</p><h4 id="3-3-3-运算错误"><a href="#3-3-3-运算错误" class="headerlink" title="3.3.3 运算错误"></a>3.3.3 运算错误</h4><p>1.是否存在不一致的数据类型（如非算术类型）的变量间的运算？2.是否有混合模式的运算？例如，将浮点变量与一个整型变量做加法运算。</p><p>3.是否有相同数据类型、不同字长变量间的运算？</p><p>4.赋值语句的目标变量的数据类型是否小于右边表达式的数据类型或结果？</p><p>5.在表达式的运算中是否存在表达式向上或向下溢出的情况？也就是说，最终的结果看起来是个有效值，但中间结果对于编程语言的数据类型可能过大或过小。</p><p>6.除法运算中的除数是否可能为0？</p><p>7.如果计算机表达变量的基本方式是基于二进制的，那么运算结果是否不精确？也就是说，在一个二进制计算机上，10×0.1很少会等于1.0。</p><p>8.在特定场合，变量的值是否超出了有意义的范围？</p><p>9.对于包含一个以上操作符的表达式，赋值顺序和操作符的优先顺序是否正确？</p><p>10.整数的运算是否有使用不当的情况，尤其是除法？举例来说，如果i是一个整型变量，表达式2*i/2<mark>i是否成立，取决于i是奇数还是偶数，或是先运算乘法，还是先运算除法。</mark></p><h4 id="3-3-4-比较错误"><a href="#3-3-4-比较错误" class="headerlink" title="3.3.4 比较错误"></a>3.3.4 比较错误</h4><p>1.是否有不同数据类型的变量之间的比较运算，例如，将字符串与地址、日期或数字相比较？</p><p>2.是否有混合模式的比较运算，或不同长度的变量间的比较运算？如果有，应确保程序能正确理解转换规则。</p><p>3.比较运算符是否正确？程序员经常混淆“至多”、“至少”、“大于”、“不小于”、“小于”和“等于”等比较关系。</p><p>4.每个布尔表达式所叙述的内容是否都正确？在编写涉及“与”、“或”或“非”的表达式时，程序员经常犯错。</p><p>5.布尔运算符的操作数是否是布尔类型的？比较运算符和布尔运算符是否错误地混在了一起？</p><p>6.在二进制的计算机上，是否有用二进制表示的小数或浮点数的比较运算？</p><p>8.编译器计算布尔表达式的方式是否会对程序产生影响？</p><h4 id="3-3-5-控制流程错误"><a href="#3-3-5-控制流程错误" class="headerlink" title="3.3.5 控制流程错误"></a>3.3.5 控制流程错误</h4><p>1.如果程序包含多条分支路径，比如有计算GO TO语句，索引变量的值是否会大于可能的分支数量</p><p>2.是否所有的循环最终都终止了？应设计一个非正式的证据或论据来证明每一个循环都会终止。</p><p>3.程序、模块或子程序是否最终都终止了？</p><p>4.由于实际情况没有满足循环的入口条件，循环体是否有可能从未执行过？如果确实发生这种情况，这里是否是一处疏漏？</p><p>5.如果循环同时由迭代变量和一个布尔条件所控制（如一个搜索循环），如果循环越界（fall-through）了，后果会如何？</p><p>6.是否存在“仅差一个”的错误，如迭代数量恰恰多一次或少一次？</p><p>7.如果编程语言中有语句组或代码块的概念（例如do-while或{……}），是否每一组语句都有一个明确的while语句，并且do语句也与其相应的语句组对应？</p><p>8.是否存在不能穷尽的判断？举例来说，如果一个输入参数的预期值是1，2或3，当参数值不为1或2时，在逻辑上是否假设了参数必定为3？</p><h4 id="3-3-6-接口错误"><a href="#3-3-6-接口错误" class="headerlink" title="3.3.6 接口错误"></a>3.3.6 接口错误</h4><ol><li>被调用模块接收到的形参（parameter）数量是否等于调用模块发送的实参（argument）数量？另外，顺序是否正确？</li></ol><p>2.实参的属性（如数据类型和大小）是否与相应形参的属性相匹配？</p><p>3.实参的量纲是否与对应形参的量纲相匹配？举例来说，是否形参以度为单位而实参以弧度为单位？</p><p>4.此模块传递给彼模块的实参数量，是否等于彼模块期望的形参数量？</p><p>5.此模块传递给彼模块的实参的属性，是否与彼模块相应形参的属性相匹配？</p><p>6.此模块传递给彼模块的实参的量纲，是否与彼模块相应形参的量纲相匹配？</p><p>7.如果调用了内置函数，实参的数量、属性、顺序是否正确？</p><p>8.如果某个模块或类有多个入口点，是否引用了与当前入口点无关的形参？</p><p>9.是否有子程序改变了某个原本仅为输入值的形参？</p><p>10.如果存在全局变量，在所有引用它们的模块中，它们的定义和属性是否相同？</p><p>11.常数是否以实参形式传递过？</p><h4 id="3-3-7-输入-x2F-输出错误"><a href="#3-3-7-输入-x2F-输出错误" class="headerlink" title="3.3.7 输入/输出错误"></a>3.3.7 输入/输出错误</h4><p>1.如果对文件明确声明过，其属性是否正确？</p><p>2.打开文件的语句中各项属性的设置是否正确？</p><p>3.格式规范是否与I/O语句中的信息相吻合？举例来说，在FORTRAN语言中，是否每个FORMAT语句都与相应的READ或WRITE语句相一致（就各项的数量和属性而言）？</p><p>4.是否有足够的可用内存空间，来保留程序将读取的文件？</p><p>5.是否所有的文件在使用之前都打开了？</p><p>6.是否所有的文件在使用之后都关闭了？</p><p>7.是否判断文件结束的条件，并正确处理？</p><p>8.对I/O出错情况处理是否正确？</p><p>9.任何打印或显示的文本信息中是否存在拼写或语法错误？</p><p>10.程序是否正确处理了类似于“File Not Found”这样的错误？</p><h4 id="3-3-8-其他检查"><a href="#3-3-8-其他检查" class="headerlink" title="3.3.8 其他检查"></a>3.3.8 其他检查</h4><p>1.如果编译器建立了一个标识符交叉引用列表，那么对该列表进行检查，查看是否有变量从未引用过，或仅被引用过一次。</p><p>2.如果编译器建立了一个属性列表，那么对每个变量的属性进行检查，确保没有赋予过不希望的默认属性值。</p><p>3.如果程序编译通过了，但计算机提供了一个或多个“警告”或“提示”信息，应对此逐一进行认真检查。“警告”信息指出编译器对程序某些操作的正确性有所怀疑；所有这些疑问都应进行检查。“提示”信息可能会罗列出没有声明的变量，或者是不利于代码优化的用法。</p><p>4.程序或模块是否具有足够的鲁棒性？也就是说，它是否对其输入的合法性进行了检查？</p><p>5.程序是否遗漏了某个功能？</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 技术书籍读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代C++概念笔记</title>
      <link href="/2023/06/24/%E7%8E%B0%E4%BB%A3C++%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/24/%E7%8E%B0%E4%BB%A3C++%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="自己想到的建议"><a href="#自己想到的建议" class="headerlink" title="自己想到的建议"></a>自己想到的建议</h1><ul><li>利用<code>std::numeric_limits&lt;T&gt;::max()</code>和<code>std::numeric_limits&lt;T&gt;::min()</code>的形式来获得某个类型的最大值和最小值,而不是使用宏。</li></ul><h1 id="很小很小的知识点"><a href="#很小很小的知识点" class="headerlink" title="很小很小的知识点"></a>很小很小的知识点</h1><ol><li>数据对齐问题会引起Alignment Fault，《现代c++语言核心特性》</li></ol><h1 id="概念澄清"><a href="#概念澄清" class="headerlink" title="概念澄清"></a>概念澄清</h1><table><thead><tr><th>概念</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>重写（override）</td><td>在C++中是指派生类覆盖了基类的虚函数，这里的覆盖必须满足有相同的函数签名和返回类型，也就是说有相同的函数名、形参列表以及返回类型。</td><td><strong>重写很容易出错，建议加上override的说明符。</strong></td></tr><tr><td>重载（overload）</td><td>指在同一个类中有两个或者两个以上函数，它们的函数名相同，但是函数签名不同，也就是说有不同的形参。</td><td></td></tr><tr><td>隐藏（overwrite）</td><td>隐藏是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时，如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏。另外，如果还想使用基类函数，可以使用using关键字将其引入派生类。</td><td></td></tr><tr><td>“Static Initialization Order Fiasco”</td><td>指的是因为静态初始化顺序错误导致的问题。</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table></body></html>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/18/hello-world/"/>
      <url>/2023/06/18/hello-world/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
