<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《架构整洁之道》笔记 | 寻宝游戏</title><meta name="author" content="寻宝游戏"><meta name="copyright" content="寻宝游戏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="推荐序一我们把这些有“洁癖”、有工匠精精、有修养的程序员叫作工程师，工程师不仅仅是在编写代码，他们会用工程的方法来编写代码，以便让编程开发更为高效和快速。他们把编程当成一种设计，一种工业设计，把代码模块化，让这些模块可以更容易地交互拼装和组织，让代码排列整齐——阅读和维护这些代码就像看阅兵式一样舒心畅快。 推荐序二 久远的教诲，古老的智慧避免随意使用goto，使用if-else、switch-ca">
<meta property="og:type" content="article">
<meta property="og:title" content="《架构整洁之道》笔记">
<meta property="og:url" content="http://example.com/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="寻宝游戏">
<meta property="og:description" content="推荐序一我们把这些有“洁癖”、有工匠精精、有修养的程序员叫作工程师，工程师不仅仅是在编写代码，他们会用工程的方法来编写代码，以便让编程开发更为高效和快速。他们把编程当成一种设计，一种工业设计，把代码模块化，让这些模块可以更容易地交互拼装和组织，让代码排列整齐——阅读和维护这些代码就像看阅兵式一样舒心畅快。 推荐序二 久远的教诲，古老的智慧避免随意使用goto，使用if-else、switch-ca">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg">
<meta property="article:published_time" content="2023-11-22T12:34:48.000Z">
<meta property="article:modified_time" content="2023-11-28T12:20:30.286Z">
<meta property="article:author" content="寻宝游戏">
<meta property="article:tag" content="Robert C. Martin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="shortcut icon" href="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="canonical" href="http://example.com/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《架构整洁之道》笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-28 20:20:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="寻宝游戏"><span class="site-name">寻宝游戏</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《架构整洁之道》笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-22T12:34:48.000Z" title="发表于 2023-11-22 20:34:48">2023-11-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-28T12:20:30.286Z" title="更新于 2023-11-28 20:20:30">2023-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">技术书籍读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《架构整洁之道》笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="推荐序一"><a href="#推荐序一" class="headerlink" title="推荐序一"></a>推荐序一</h2><p>我们把这些有“洁癖”、有工匠精精、有修养的程序员叫作工程师，工程师不仅仅是在编写代码，他们会用工程的方法来编写代码，以便让编程开发更为高效和快速。他们把编程当成一种设计，一种工业设计，把代码模块化，让这些模块可以更容易地交互拼装和组织，让代码排列整齐——阅读和维护这些代码就像看阅兵式一样舒心畅快。</p>
<h2 id="推荐序二-久远的教诲，古老的智慧"><a href="#推荐序二-久远的教诲，古老的智慧" class="headerlink" title="推荐序二 久远的教诲，古老的智慧"></a>推荐序二 久远的教诲，古老的智慧</h2><p>避免随意使用goto，使用if-else、switch-case之类控制语句和函数、子函数组织起来的程序代码，可以保证程序的结构是清楚的，自顶向下层层细化，消灭了杂错，杜绝了混淆。</p>
<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>软件架构学关注的的一个重点是组织结构(structure)。不管是讨论组件(Component)、类(Class)、函数(Function)、模块(Module)，还是层级(Layer)、服务(Service)以及微观与宏观的软件开发过程，软件的组织结构都是我们的主要关注点。</p>
<h3 id="第1章-设计与架构究竟是什么"><a href="#第1章-设计与架构究竟是什么" class="headerlink" title="第1章 设计与架构究竟是什么"></a>第1章 设计与架构究竟是什么</h3><ul>
<li><strong>软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。</strong></li>
<li>一个软件架构的优劣，可以用它满足用户需求所需要的成本来衡量。如果该成本很低，并且在系统的整个生命周期内一直都能维持这样的低成本，那么这个系统的设计就是优良的。</li>
</ul>
<h3 id="第2章-两个价值维度"><a href="#第2章-两个价值维度" class="headerlink" title="第2章 两个价值维度"></a>第2章 两个价值维度</h3><ul>
<li><p>行为价值：大部分程序员认为这就是他们的全部工作。他们的工作是且仅是：按照需求文档编写代码，并且修复任何Bug。这真是大错特错。</p>
</li>
<li><p>架构价值：为了达到软件的本来目的，软件系统必须够“软”——也就是说，软件应该容易被修改。当需求方改变需求的时候，随之所需的软件变更必须可以简单而方便地实现。</p>
</li>
<li><p>如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为0。</p>
</li>
<li><p>软件系统的第一个价值维度：<strong>系统行为</strong>，是紧急的，但是并不总是特别重要。软件系统的第二个价值维度：<strong>系统架构</strong>，是重要的，但是并不总是特别紧急。</p>
</li>
</ul>
<p>==艾森豪威尔矩阵==</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122204108331.png" alt="image-20231122204108331"></p>
<h2 id="第2部分-从基础构件开始：编程范式"><a href="#第2部分-从基础构件开始：编程范式" class="headerlink" title="第2部分 从基础构件开始：编程范式"></a>第2部分 从基础构件开始：编程范式</h2><ul>
<li><strong>编程范式指的是程序的编写模式，与具体的编程语言关系相对较小。这些范式会告诉你应该在什么时候采用什么样的代码结构。</strong></li>
</ul>
<h3 id="第3章-编程范式总览"><a href="#第3章-编程范式总览" class="headerlink" title="第3章 编程范式总览"></a>第3章 编程范式总览</h3><p>三个编程范式，它们分别是**结构化编程(structured programming)<strong>、</strong>面向对象编程(object-oriented programming)<strong>以及</strong>函数式编程(functional programming)**。</p>
<ul>
<li><p>结构化编程对程序控制权的直接转移进行了限制和规范。</p>
</li>
<li><p>面向对象编程对程序控制权的间接转移进行了限制和规范。</p>
</li>
<li><p>函数式编程对程序中的赋值进行了限制和规范。</p>
</li>
<li><p>每个编程范式的目的都是设置限制。这些范式主要是为了告诉我们不能做什么，而不是可以做什么。</p>
</li>
<li><p><strong>这和软件架构的三大关注重点不谋而合：功能性、组件独立性以及数据管理。</strong></p>
</li>
</ul>
<h3 id="第4章-结构化编程"><a href="#第4章-结构化编程" class="headerlink" title="第4章 结构化编程"></a>第4章 结构化编程</h3><ul>
<li>结构化编程范式中最有价值的地方就是，它赋予了我们创造可证伪程序单元的能力。</li>
<li>无论在哪一个层面上，从最小的函数到最大组件，软件开发的过程都和科学研究非常类似，它们都是由证伪驱动的。软件架构师需要定义可以方便地进行证伪（测试）的模块、组件以及服务。</li>
</ul>
<h3 id="第5章-面向对象编程"><a href="#第5章-面向对象编程" class="headerlink" title="第5章 面向对象编程"></a>第5章 面向对象编程</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122204725715.png" alt="image-20231122204725715"></p>
<ul>
<li><p>请注意模块ML1和接口I在源代码上的依赖关系（或者叫继承关系），该关系的方向和控制流正好是相反的，我们称之为依赖反转。这种反转对软件架构设计的影响是非常大的。</p>
</li>
<li><p>通过这种（多态）方法，软件架构师可以完全控制采用了面向对象这种编程方式的系统中所有的源代码依赖关系，而不再受到系统控制流的限制。不管哪个模块调用或者被调用，软件架构师都可以随意更改源代码依赖关系。</p>
</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122205041012.png" alt="image-20231122205041012"></p>
<ul>
<li>面向对象编程到底是什么？然而对一个软件架构师来说，其含义应该是非常明确的：<strong>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力</strong></li>
</ul>
<h3 id="第6章-函数式编程"><a href="#第6章-函数式编程" class="headerlink" title="第6章 函数式编程"></a>第6章 函数式编程</h3><ul>
<li><p>作为一个软件架构师，当然应该要对并发问题保持高度关注。我们需要确保自己设计的系统在多线程、多处理器环境中能稳定工作。</p>
</li>
<li><p>一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量。</p>
</li>
<li><p>如果我们有足够大的存储量和处理能力，应用程序就可以用完全不可变的、纯函数式的方式来编程。</p>
</li>
<li><p>三个编程范式都对程序员提出了新的限制。每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。也就是说，我们过去50年学到的东西主要是——什么不应该做。我们必须面对这种不友好的现实：软件构建并不是一个迅速前进的技术。今天构建软件的规则和1946年阿兰·图灵写下电子计算机的第一行代码时是一样的。尽管工具变化了，硬件变化了，但是软件编程的核心没有变。</p>
</li>
</ul>
<h2 id="第3部分-设计原则"><a href="#第3部分-设计原则" class="headerlink" title="第3部分 设计原则"></a>第3部分 设计原则</h2><blockquote>
<p>一般情况下，我们为软件构建中层结构的主要目标如下：使软件可容忍被改动。使软件更容易被理解。构建可在多个软件系统中复用的组件。</p>
</blockquote>
<ul>
<li><p>SOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类，以及如何将这些类链接起来成为程序。</p>
</li>
<li><p>==SRP：单一职责原则==。该设计原则是基于康威定律(Conway’s Law)[插图]的一个推论——一个软件系统的最佳结构高度依赖于开发这个系统的组织的内部结构。这样，每个软件模块都有且只有一个需要被改变的理由。</p>
</li>
<li><p>==OCP：开闭原则==。该设计原则是由Bertrand Meyer在20世纪80年代大力推广的，其核心要素是：如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。</p>
</li>
<li><p>==LSP：里氏替换原则==。该设计原则是Barbara Liskov在1988年提出的一个著名的子类型定义。简单来说，这项原则的意思是如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换，就是说<strong>任何基类可以出现的地方，子类一定可以出现</strong>。</p>
</li>
<li><p>==ISP：接口隔离原则==。这项设计原则主要告诫软件设计师应该在设计中避免不必要的依赖。</p>
</li>
<li><p>==DIP：依赖反转原则==。该设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。</p>
</li>
</ul>
<h3 id="第7章-SRP：单一职责原则"><a href="#第7章-SRP：单一职责原则" class="headerlink" title="第7章 SRP：单一职责原则"></a>第7章 SRP：单一职责原则</h3><p>以下是三种相同的表述:</p>
<blockquote>
<p>任何一个软件模块都应该有且仅有一个被修改的原因。</p>
<p>任何一个软件模块都应该只对一个用户(User)或系统利益相关者(Stakeholder)负责。</p>
<p>任何一个软件模块都应该只对某一类行为者负责</p>
</blockquote>
<p>单一职责原则主要讨论的是函数和类之间的关系——但是它在两个讨论层面上会以不同的形式出现。在组件层面，我们可以将其称为共同闭包原则(Common Closure Principle)，在软件架构层面，它则是用于奠定架构边界的变更轴心(Axis of Change)。我们在接下来的章节中会深入学习这些原则。</p>
<h3 id="第8章-OCP：开闭原则"><a href="#第8章-OCP：开闭原则" class="headerlink" title="第8章 OCP：开闭原则"></a>第8章 OCP：开闭原则</h3><ul>
<li><p>设计良好的计算机软件应该易于扩展，同时抗拒修改。</p>
</li>
<li><p>一个好的软件架构设计师会努力将旧代码的修改需求量降至最小，甚至为0。</p>
</li>
<li><p>我们可以先将满足不同需求的代码分组（即SRP），然后再来调整这些分组之间的依赖关系（即DIP）</p>
</li>
<li><p>如果A组件不想被B组件上发生的修改所影响，那么就应该让B组件依赖于A组件。</p>
</li>
<li><p>软件架构师可以根据相关函数被修改的原因、修改的方式及修改的时间来对其进行分组隔离，并将这些互相隔离的函数分组整理成组件结构，使得高阶组件不会因低阶组件被修改而受到影响。</p>
</li>
<li><p><strong>OCP是我们进行系统架构设计的主导原则</strong>，其主要目标是让系统易于扩展，同时限制其每次被修改所影响的范围</p>
</li>
</ul>
<h3 id="第9章-LSP：里氏替换原则"><a href="#第9章-LSP：里氏替换原则" class="headerlink" title="第9章 LSP：里氏替换原则"></a>第9章 LSP：里氏替换原则</h3><ul>
<li><p>可替换性：如果对于每个类型是S的对象o1都存在一个类型为T的对象o2，能使操作T类型的程序P在用o2替换o1时行为保持不变，我们就可以将S称为T的子类型。</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210636930.png"></p>
</li>
</ul>
<p>正方形/长方形问题是一个著名（或者说臭名远扬）的违反LSP的设计案例,在这个案例中，Square类并不是Rectangle类的子类型，因为Rectangle类的高和宽可以分别修改，而Square类的高和宽则必须一同修改。</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210751691.png" alt="image-20231122210751691"></p>
<ul>
<li>LSP可以且应该被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。</li>
</ul>
<h3 id="第10章-ISP：接口隔离原则"><a href="#第10章-ISP：接口隔离原则" class="headerlink" title="第10章 ISP：接口隔离原则"></a>第10章 ISP：接口隔离原则</h3><ul>
<li>在一般情况下，任何层次的软件设计如果依赖于不需要的东西，都会是有害的。</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122210912274.png" alt="image-20231122210912274"></p>
<h3 id="第11章-DIP：依赖反转原则"><a href="#第11章-DIP：依赖反转原则" class="headerlink" title="第11章 DIP：依赖反转原则"></a>第11章 DIP：依赖反转原则</h3><ul>
<li><p><strong>如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。</strong></p>
</li>
<li><p>优秀的软件设计师和架构师会花费很大精力来设计接口，以减少未来对其进行改动。毕竟争取在不修改接口的情况下为软件增加新的功能是软件设计的基础常识。</p>
</li>
<li><p>如果想要在软件架构设计上追求稳定，就必须多使用稳定的抽象接口，少依赖多变的具体实现。</p>
</li>
<li><p>应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类。</p>
</li>
<li><p>对象的创建过程也应该受到严格限制，对此，我们通常会选择用抽象工厂(abstract factory)这个设计模式。</p>
</li>
<li><p>不要在具体实现类上创建衍生类。</p>
</li>
<li><p>不要覆盖(override)包含具体实现的函数</p>
</li>
<li><p>应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字</p>
</li>
</ul>
<h2 id="第4部分-组件构建原则"><a href="#第4部分-组件构建原则" class="headerlink" title="第4部分 组件构建原则"></a>第4部分 组件构建原则</h2><p><strong>如果说SOLID原则是用于指导我们如何将砖块砌成墙与房间的，那么组件构建原则就是用来指导我们如何将这些房间组合成房子的。</strong></p>
<h3 id="第12章-组件"><a href="#第12章-组件" class="headerlink" title="第12章 组件"></a>第12章 组件</h3><ul>
<li><p>组件都是该软件在部署过程中的最小单元</p>
</li>
<li><p>设计良好的组件都应该永远保持可被独立部署的特性，这同时也意味着这些组件应该可以被单独开发。</p>
</li>
</ul>
<h3 id="第13章-组件聚合"><a href="#第13章-组件聚合" class="headerlink" title="第13章 组件聚合"></a>第13章 组件聚合</h3><ul>
<li>究竟是哪些类应该被组合成一个组件呢？这是一个非常重要的设计决策，应该遵循优秀的软件工程经验来行事。但不幸的是，很多年以来，我们对于这么重要的决策经常是根据当下面临的实际情况临时拍脑门决定的。</li>
</ul>
<p>三个与构建组件相关的基本原则：</p>
<p>==REP：复用/发布等同原则。CCP：共同闭包原则。CRP：共同复用原则。==</p>
<ul>
<li><p>软件复用的最小粒度应等同于其发布的最小粒度。</p>
</li>
<li><p><strong>REP原则</strong>就是指组件中的类与模块必须是彼此紧密相关的。也就是说，一个组件不能由一组毫无关联的类和模块组成，它们之间应该有一个共同的主题或者大方向。</p>
</li>
<li><p><strong>CCP</strong>的主要作用就是提示我们要将所有可能会被一起修改的类集中在一处。也就是说，如果两个类紧密相关，不管是源代码层面还是抽象理念层面，永远都会一起被修改，那么它们就应该被归属为同一个组件。通过遵守这个原则，我们就可以有效地降低因软件发布、验证及部署所带来的工作压力。</p>
</li>
<li><p>对大部分应用程序来说，可维护性的重要性要远远高于可复用性。</p>
</li>
<li><p><strong>CCP原则</strong>实际上就是SRP原则的组件版。在SRP原则的指导下，我们将会把变更原因不同的函数放入不同的类中。而CCP原则指导我们应该将变更原因不同的类放入不同的组件中。</p>
</li>
<li><p>不要强迫一个组件的用户依赖他们不需要的东西。**共同复用原则(CRP)**是另外一个帮助我们决策类和模块归属于哪一个组件的原则。该原则建议我们将经常共同复用的类和模块放在同一个组件中。</p>
</li>
<li><p>由于这种依赖关系的存在，每当被引用组件发生变更时，引用它的组件一般也需要做出相应的变更。即使它们不需要进行代码级的变更，一般也免不了需要被重新编译、验证和部署。哪怕引用组件根本不关心被引用组件中的变更，也要如此。</p>
</li>
<li><p>在CRP原则中，关于哪些类不应该被放在一起的建议是其更为重要的内容</p>
</li>
<li><p>CRP原则实际上是ISP原则的一个普适版。ISP原则是建议我们不要依赖带有不需要的函数的类，而CRP原则则是建议我们不要依赖带有不需要的类的组件。可以总结为：<strong>不要依赖不需要用到的东西。</strong></p>
</li>
</ul>
<p>==一张组件聚合三大原则的张力图==</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231122211753671.png" alt="image-20231122211753671"></p>
<p>一般来说，一个软件项目的重心会从该三角区域的右侧开始，先期主要牺牲的是复用性。然后，随着项目逐渐成熟，其他项目会逐渐开始对其产生依赖，项目重心就会逐渐向该三角区域的左侧滑动。换句话说，一个项目在组件结构设计上的重心是根据该项目的开发时间和成熟度不断变动的，我们对组件结构的安排主要与项目开发的进度和它被使用的方式有关，与项目本身功能的关系其实很小。</p>
<h3 id="第14章-组件耦合"><a href="#第14章-组件耦合" class="headerlink" title="第14章 组件耦合"></a>第14章 组件耦合</h3><ul>
<li><p><strong>组件依赖关系图中不应该出现环。</strong></p>
</li>
<li><p>“一觉醒来综合征”的解决方法：第一种是“每周构建”，第二种是“无依赖环原则(ADP)”。</p>
</li>
<li><p>每当一个组件发布新版本时，其他依赖这个组件的团队都可以自主决定是否立即采用新版本。若不采用，该团队可以选择继续使用旧版组件，直到他们准备好采用新版本为止。</p>
</li>
<li><p>我们可以打破这些组件中的循环依赖，并将其依赖图转化为DAG。目前有以下两种主要机制可以做到这件事情：1.应用依赖反转原则(DIP)：2.创建一个新的组件；</p>
</li>
<li><p>根据上述讨论，我们可以得出一个无法逃避的结论：组件结构图是不可能自上而下被设计出来的。它必须随着软件系统的变化而变化和扩张，而不可能在系统构建的最初就被完美设计出来。</p>
</li>
<li><p>人们也普遍认为项目粗粒度的组件分组规则所产生的就是组件的依赖结构，也应该在某种程度上与项目的系统功能分解的结果相互对应</p>
</li>
<li><p>组件依赖结构图并不是用来描述应用程序功能的，它更像是应用程序在构建性与维护性方面的一张地图</p>
</li>
<li><p>如果我们在设计具体类之前就来设计组件依赖关系，那么几乎是必然要失败的。</p>
</li>
<li><p><strong>依赖关系必须要指向更稳定的方向。</strong></p>
</li>
<li><p><strong>任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖，否则这个多变的组件也将会变得非常难以被修改。</strong></p>
</li>
<li><p>让软件组件难于修改的一个最直接的办法就是让很多其他组件依赖于它。带有许多入向依赖关系的组件是非常稳定的，因为它的任何变更都需要应用到所有依赖它的组件上，比如下图的X</p>
</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20231128193729125.png" alt="image-20231128193729125"></p>
<ul>
<li><p>稳定性指标：</p>
<ul>
<li><strong>Fan-in：入向依赖</strong>，这个指标指代了组件外部类依赖于组件内部类的数量。</li>
<li><strong>Fan-out：出向依赖</strong>，这个指标指代了组件内部类依赖于组件外部类的数量。</li>
<li>**I：不稳定性，I=Fan-out/(Fan-in+Fan-out)**。该指标的范围是[0,1],I=0意味着组件是最稳定的，I=1意味着组件是最不稳定的。</li>
</ul>
</li>
<li><p><strong>稳定依赖原则(SDP)的要求是让每个组件的I指标都必须大于其所依赖组件的I指标。也就是说，组件结构依赖图中各组件的I指标必须要按其依赖关系方向递减。</strong></p>
</li>
<li><p>我们设计组件架构图的目的就是要决定应该让哪些组件稳定，让哪些组件不稳定。</p>
</li>
<li><p>动态类型语言中的依赖关系是非常简单的，因为其依赖反转的过程并不需要声明和继承接口。</p>
</li>
<li><p>==稳定抽象原则（SAP）==：一个组件的抽象化程度应该与其稳定性保持一致。</p>
</li>
<li><p>抽象程度的衡量：假设A指标是对组件抽象化程度的一个衡量，它的值是组件中抽象类与接口所占的比例。那么：Nc：组件中类的数量。Na：组件中抽象类和接口的数量。A：抽象程度，A=Na÷Nc。A指标的取值范围是从0到1，值为0代表组件中没有任何抽象类，值为1就意味着组件中只有抽象类。</p>
</li>
</ul>
<h2 id="第5部分-软件架构"><a href="#第5部分-软件架构" class="headerlink" title="第5部分 软件架构"></a>第5部分 软件架构</h2><h3 id="第15章-什么是软件架构"><a href="#第15章-什么是软件架构" class="headerlink" title="第15章 什么是软件架构"></a>第15章 什么是软件架构</h3><ul>
<li>软件系统的架构质量是由它的构建者所决定的，软件架构这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式。</li>
</ul>
<blockquote>
<p>如果想设计一个便于推进各项工作的系统，其策略就是要在设计中尽可能长时间地保留尽可能多的可选项。</p>
</blockquote>
<p>==说白了就是要可扩展性要强==</p>
<ul>
<li><p>一个系统的部署成本越高，可用性就越低。</p>
</li>
<li><p>架构应该起到揭示系统运行过程的作用。</p>
</li>
<li><p>系统维护的主要成本集中在“探秘”和“风险”这两件事上。其中，“探秘(spelunking)”的成本主要来自我们对于现有软件系统的挖掘，目的是确定新增功能或被修复问题的最佳位置和最佳方式。而“风险(risk)”，则是指当我们进行上述修改时，总是有可能衍生出新的问题，这种可能性就是风险成本。</p>
</li>
<li><p>软件架构师的目标是创建一种系统形态，该形态会以策略为最基本的元素，并让细节与策略脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容。</p>
</li>
<li><p>如果在开发高层策略时有意地让自己摆脱具体细节的纠缠，我们就可以将与具体实现相关的细节决策推迟或延后，因为越到项目的后期，我们就拥有越多的信息来做出合理的决策。</p>
</li>
<li><p>一个优秀的软件架构师应该致力于最大化可选项数量。</p>
</li>
<li><p>优秀的架构师会小心地将软件的高层策略与其底层实现隔离开，让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖。</p>
</li>
<li><p>优秀的架构师所设计的策略应该允许系统尽可能地推迟与实现细节相关的决策，越晚做决策越好。</p>
</li>
</ul>
<h3 id="第16章-独立性"><a href="#第16章-独立性" class="headerlink" title="第16章 独立性"></a>第16章 独立性</h3><ul>
<li><p>一个设计良好的软件架构必须支持以下几点：系统的用例与正常运行、系统的维护、系 统的开发、系统的部署。</p>
</li>
<li><p>一个设计良好的架构在行为上对系统最重要的作用就是明确和显式地反映系统设计意图的行为，使其在架构层面上可见。</p>
</li>
<li><p>任何一个组织在设计系统时，往往都会复制出一个与该组织内沟通结构相同的系统。</p>
</li>
<li><p>设计目标一定是实现“立刻部署”。一个设计良好的架构通常不会依赖于成堆的脚本与配置文件，也不需要用户手动创建一堆“有严格要求”的目录与文件。总而言之，一个设计良好的软件架构可以让系统在构建完成之后立刻就能部署。</p>
</li>
<li><p><strong>如果我们按照变更原因的不同对系统进行解耦，就可以持续地向系统内添加新的用例，而不会影响旧有的用例。如果我们同时对支持这些用例的UI和数据库也进行了分组，那么每个用例使用的就是不同面向的UI与数据库，因此增加新用例就更不太可能会影响旧有的用例了</strong></p>
</li>
<li><p>为了在不同的服务器上运行，被隔离的组件不能依赖于某个处理器上的同一个地址空间，它们必须是独立的服务，然后通过某种网络来进行通信。许多架构师将上面这种组件称为“服务”或“微服务”，至于是前者还是后者，往往取决于某些非常模糊的代码行数阈值。对于这种基于服务来构建的架构，架构师们通常称之为<strong>面向服务的架构(service-oriented architecture)，即SOA</strong>。</p>
</li>
<li><p>如果有两段看起来重复的代码，它们走的是不同的演进路径，也就是说它们有着不同的变更速率和变更缘由，那么这两段代码就不是真正的重复。</p>
</li>
</ul>
<h3 id="第17章-划分边界"><a href="#第17章-划分边界" class="headerlink" title="第17章 划分边界"></a>第17章 划分边界</h3><ul>
<li><p>软件架构设计本身就是一门划分边界的艺术。</p>
</li>
<li><p>一个系统最消耗人力资源的是什么？答案是系统中存在的耦合——尤其是那些过早做出的、不成熟的决策所导致的耦合。</p>
</li>
<li><p>边界线应该画在那些不相关的事情中间。GUI与业务逻辑无关，所以两者之间应该有一条边界线。数据库与GUI无关，这两者之间也应该有一条边界线。数据库又与业务逻辑无关，所以两者之间也应该有一条边界线。</p>
</li>
<li><p>将系统设计为插件式架构，就等于构建起了一面变更无法逾越的防火墙。</p>
</li>
</ul>
<h3 id="第18章-边界剖析"><a href="#第18章-边界剖析" class="headerlink" title="第18章 边界剖析"></a>第18章 边界剖析</h3><ul>
<li><p>高层进程的源码中不应该包含低层进程的名字、物理内存地址或是注册表键名。</p>
</li>
<li><p>系统架构中最强的边界形式就是服务。</p>
</li>
<li><p>一个系统中通常会同时包含高通信量、低延迟的本地架构边界和低通信量、高延迟的服务边界。</p>
</li>
</ul>
<h3 id="第19章-策略与层次"><a href="#第19章-策略与层次" class="headerlink" title="第19章 策略与层次"></a>第19章 策略与层次</h3><ul>
<li><p>计算机程序不过就是一组仔细描述如何将输入转化为输出的策略语句的集合。</p>
</li>
<li><p>架构设计的工作常常需要将组件重排组合成为一个有向无环图。图中的每一个节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了一种组件之间的依赖关系，它们将不同级别的组件链接起来。</p>
</li>
<li><p>低层组件应该成为高层组件的插件</p>
</li>
</ul>
<h3 id="第20章-业务逻辑"><a href="#第20章-业务逻辑" class="headerlink" title="第20章 业务逻辑"></a>第20章 业务逻辑</h3><ul>
<li><p>业务实体这个概念只要求我们将关键业务数据和关键业务逻辑绑定在一个独立的软件模块内。</p>
</li>
<li><p>用例控制着业务实体之间的交互方式。</p>
</li>
<li><p>业务实体并不会知道是哪个业务用例在控制它们，这也是依赖反转原则(DIP)的另一个应用情景。也就是像业务实体这样的高层概念是无须了解像用例这样的低层概念的。反之，低层的业务用例却需要了解高层的业务实体。</p>
</li>
<li><p>业务逻辑是一个软件系统存在的意义，它们属于核心功能，是系统用来赚钱或省钱的那部分代码，是整个系统中的皇冠明珠。</p>
</li>
</ul>
<h3 id="第21章-尖叫的软件架构"><a href="#第21章-尖叫的软件架构" class="headerlink" title="第21章 尖叫的软件架构"></a>第21章 尖叫的软件架构</h3><p>软件的系统架构应该为该系统的用例提供支持。这就像住宅和图书馆的建筑计划满篇都在非常明显地凸显这些建筑的用例一样，软件系统的架构设计图也应该非常明确地凸显该应用程序会有哪些用例。</p>
<h3 id="第22章-整洁架构"><a href="#第22章-整洁架构" class="headerlink" title="第22章 整洁架构"></a>第22章 整洁架构</h3><ul>
<li><p>按照不同关注点对软件进行切割。也就是说，这些架构都会将软件切割成不同的层，至少有一层是只包含该软件的业务逻辑的，而用户接口、系统接口则属于其他层。</p>
</li>
<li><p>源码中的依赖关系必须只指向同心圆的内层，即由低层机制指向高层策略。</p>
</li>
<li><p>我们不应该让外层圆中发生的任何变更影响到内层圆的代码。</p>
</li>
<li><p>读者必须注意一下这里的依赖关系方向。所有跨边界的依赖线都是指向内的，这很好地遵守了架构的依赖关系规则。</p>
</li>
</ul>
<h3 id="第23章-展示器和谦卑对象"><a href="#第23章-展示器和谦卑对象" class="headerlink" title="第23章 展示器和谦卑对象"></a>第23章 展示器和谦卑对象</h3><ul>
<li>展示器实际上是采用谦卑对象(humble object)模式的一种形式，这种设计模式可以很好地帮助识别和保护系统架构的边界。</li>
</ul>
<h3 id="第24章-不完全边界"><a href="#第24章-不完全边界" class="headerlink" title="第24章 不完全边界"></a>第24章 不完全边界</h3><ul>
<li>构建不完全边界的一种方式就是在将系统分割成一系列可以独立编译、独立部署的组件之后，再把它们构建成一个组件。换句话说，在将系统中所有的接口、用于输入/输出的数据格式等每一件事都设置好之后，仍选择将它们统一编译和部署为一个组件。</li>
</ul>
<h3 id="第28章-测试边界"><a href="#第28章-测试边界" class="headerlink" title="第28章 测试边界"></a>第28章 测试边界</h3><ul>
<li><p>我们可以将测试组件视为系统架构中最外圈的程序。它们始终是向内依赖的，而且系统中没有其他组件依赖于它们。</p>
</li>
<li><p>修改一个通用的系统组件可能会导致成百上千个测试出现问题，我们通常将这类问题称为脆弱的测试问题(fragiletestsproblem)。</p>
</li>
</ul>
<h3 id="第29章-整洁的嵌入式架构"><a href="#第29章-整洁的嵌入式架构" class="headerlink" title="第29章 整洁的嵌入式架构"></a>第29章 整洁的嵌入式架构</h3><ul>
<li><p>“虽然软件本身并不会随时间推移而磨损，但硬件及其固件却会随时间推移而过时，随即也需要对软件做相应改动。”</p>
</li>
<li><p>不要再写固件代码了，让我们的代码活得更久一点！</p>
</li>
</ul>
<h3 id="第32章-应用程序框架是实现细节"><a href="#第32章-应用程序框架是实现细节" class="headerlink" title="第32章 应用程序框架是实现细节"></a>第32章 应用程序框架是实现细节</h3><ul>
<li><p>我们可以使用框架——但要时刻警惕，别被它拖住。我们应该将框架作为架构最外圈的一个实现细节来使用，不要让它们进入内圈。</p>
</li>
<li><p>如果一旦在项目中引入一个框架，很有可能在整个生命周期中都要依赖于它，不管后来情形怎么变化，这个决定都很难更改了。因此，不应该草率地做出决定。</p>
</li>
</ul>
<h3 id="第34章-拾遗"><a href="#第34章-拾遗" class="headerlink" title="第34章 拾遗"></a>第34章 拾遗</h3><ul>
<li>如果不考虑具体实现细节，再好的设计也无法长久。必须要将设计映射到对应的代码结构上，考虑如何组织代码树，以及在编译期和运行期采用哪种解耦合的模式。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">寻宝游戏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/">http://example.com/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">寻宝游戏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Robert-C-Martin/">Robert C. Martin</a></div><div class="post_share"><div class="social-share" data-image="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/22/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《代码整洁之道：程序员的职业素养》笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《代码整洁之道：程序员的职业素养》笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/21/thought_%E5%BC%80%E5%A7%8B%E5%86%99blog/" title="From Now On重新开写！"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">From Now On重新开写！</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/22/%E4%B8%93%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E7%B2%BE%E9%80%9A%E7%9A%84%E4%BA%8B%E9%A1%B9/" title="专业软件开发人员必须精通的事项"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">专业软件开发人员必须精通的事项</div></div></a></div><div><a href="/2023/11/22/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《代码整洁之道：程序员的职业素养》笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-22</div><div class="title">《代码整洁之道：程序员的职业素养》笔记</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">寻宝游戏</div><div class="author-info__description">思维的乐趣。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/enternityFan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Do your own thing...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E5%BA%8F%E4%B8%80"><span class="toc-number">1.</span> <span class="toc-text">推荐序一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E5%BA%8F%E4%BA%8C-%E4%B9%85%E8%BF%9C%E7%9A%84%E6%95%99%E8%AF%B2%EF%BC%8C%E5%8F%A4%E8%80%81%E7%9A%84%E6%99%BA%E6%85%A7"><span class="toc-number">2.</span> <span class="toc-text">推荐序二 久远的教诲，古老的智慧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">序言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">第1章 设计与架构究竟是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%B8%A4%E4%B8%AA%E4%BB%B7%E5%80%BC%E7%BB%B4%E5%BA%A6"><span class="toc-number">3.2.</span> <span class="toc-text">第2章 两个价值维度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E9%83%A8%E5%88%86-%E4%BB%8E%E5%9F%BA%E7%A1%80%E6%9E%84%E4%BB%B6%E5%BC%80%E5%A7%8B%EF%BC%9A%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">第2部分 从基础构件开始：编程范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-number">4.1.</span> <span class="toc-text">第3章 编程范式总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">第4章 结构化编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">第5章 面向对象编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">第6章 函数式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E9%83%A8%E5%88%86-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.</span> <span class="toc-text">第3部分 设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-SRP%EF%BC%9A%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">5.1.</span> <span class="toc-text">第7章 SRP：单一职责原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-OCP%EF%BC%9A%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">第8章 OCP：开闭原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-LSP%EF%BC%9A%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">5.3.</span> <span class="toc-text">第9章 LSP：里氏替换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-ISP%EF%BC%9A%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">5.4.</span> <span class="toc-text">第10章 ISP：接口隔离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-DIP%EF%BC%9A%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-number">5.5.</span> <span class="toc-text">第11章 DIP：依赖反转原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E9%83%A8%E5%88%86-%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="toc-number">6.</span> <span class="toc-text">第4部分 组件构建原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E7%BB%84%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">第12章 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E7%BB%84%E4%BB%B6%E8%81%9A%E5%90%88"><span class="toc-number">6.2.</span> <span class="toc-text">第13章 组件聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E7%BB%84%E4%BB%B6%E8%80%A6%E5%90%88"><span class="toc-number">6.3.</span> <span class="toc-text">第14章 组件耦合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E9%83%A8%E5%88%86-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">第5部分 软件架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">第15章 什么是软件架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">7.2.</span> <span class="toc-text">第16章 独立性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%88%92%E5%88%86%E8%BE%B9%E7%95%8C"><span class="toc-number">7.3.</span> <span class="toc-text">第17章 划分边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-%E8%BE%B9%E7%95%8C%E5%89%96%E6%9E%90"><span class="toc-number">7.4.</span> <span class="toc-text">第18章 边界剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E7%AD%96%E7%95%A5%E4%B8%8E%E5%B1%82%E6%AC%A1"><span class="toc-number">7.5.</span> <span class="toc-text">第19章 策略与层次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91"><span class="toc-number">7.6.</span> <span class="toc-text">第20章 业务逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%B0%96%E5%8F%AB%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">7.7.</span> <span class="toc-text">第21章 尖叫的软件架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC22%E7%AB%A0-%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84"><span class="toc-number">7.8.</span> <span class="toc-text">第22章 整洁架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC23%E7%AB%A0-%E5%B1%95%E7%A4%BA%E5%99%A8%E5%92%8C%E8%B0%A6%E5%8D%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.9.</span> <span class="toc-text">第23章 展示器和谦卑对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC24%E7%AB%A0-%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%BE%B9%E7%95%8C"><span class="toc-number">7.10.</span> <span class="toc-text">第24章 不完全边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC28%E7%AB%A0-%E6%B5%8B%E8%AF%95%E8%BE%B9%E7%95%8C"><span class="toc-number">7.11.</span> <span class="toc-text">第28章 测试边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC29%E7%AB%A0-%E6%95%B4%E6%B4%81%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">7.12.</span> <span class="toc-text">第29章 整洁的嵌入式架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC32%E7%AB%A0-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E6%98%AF%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">7.13.</span> <span class="toc-text">第32章 应用程序框架是实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC34%E7%AB%A0-%E6%8B%BE%E9%81%97"><span class="toc-number">7.14.</span> <span class="toc-text">第34章 拾遗</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/01/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="无题">无题</a><time datetime="2024-07-01T00:56:47.038Z" title="发表于 2024-07-01 08:56:47">2024-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/16/%E9%9D%A2%E8%AF%95%E8%A3%85%E9%80%BC%E6%8C%87%E5%8D%97/" title="无题">无题</a><time datetime="2024-06-16T08:55:44.994Z" title="发表于 2024-06-16 16:55:44">2024-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/16/%E7%8E%B0%E4%BB%A3C++%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2024-06-16T07:09:09.546Z" title="发表于 2024-06-16 15:09:09">2024-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" title="无题">无题</a><time datetime="2024-06-03T00:32:47.295Z" title="发表于 2024-06-03 08:32:47">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/30/%E5%B0%8F%E5%BD%AD%E8%80%81%E5%B8%88%E7%BD%91%E8%AF%BE/" title="无题">无题</a><time datetime="2024-05-30T01:05:56.979Z" title="发表于 2024-05-30 09:05:56">2024-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2020 - 2025 By 寻宝游戏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      id: 'd837ced991c9ed157888a285a80d701a',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/'
    this.page.identifier = '/2023/11/22/%E3%80%8A%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/'
    this.page.title = '《架构整洁之道》笔记'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Gitalk' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="8507814393" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: true,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>