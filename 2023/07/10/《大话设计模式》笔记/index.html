<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《大话设计模式》笔记 | 寻宝游戏</title><meta name="author" content="寻宝游戏"><meta name="copyright" content="寻宝游戏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本书特色如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。  1.11 UML类图继承关系用空心三角形+实线来表示 实现接口用空心三角形+虚线来表示。 关联关系用实线箭头来表示。 聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。聚合关系用空心的菱形+实线箭头来表示。 合成（Composi">
<meta property="og:type" content="article">
<meta property="og:title" content="《大话设计模式》笔记">
<meta property="og:url" content="http://example.com/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="寻宝游戏">
<meta property="og:description" content="本书特色如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。  1.11 UML类图继承关系用空心三角形+实线来表示 实现接口用空心三角形+虚线来表示。 关联关系用实线箭头来表示。 聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。聚合关系用空心的菱形+实线箭头来表示。 合成（Composi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg">
<meta property="article:published_time" content="2023-07-10T12:13:48.000Z">
<meta property="article:modified_time" content="2025-04-05T07:48:39.166Z">
<meta property="article:author" content="寻宝游戏">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="shortcut icon" href="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="canonical" href="http://example.com/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《大话设计模式》笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-05 15:48:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="寻宝游戏"><span class="site-name">寻宝游戏</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《大话设计模式》笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-10T12:13:48.000Z" title="发表于 2023-07-10 20:13:48">2023-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-05T07:48:39.166Z" title="更新于 2025-04-05 15:48:39">2025-04-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">技术书籍读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《大话设计模式》笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="本书特色"><a href="#本书特色" class="headerlink" title="本书特色"></a>本书特色</h3><p>如果想成为一名更优秀的软件设计师，了解优秀软件设计的演变过程比学习优秀设计本身更有价值，因为设计的演变过程中蕴藏着大智慧。</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_323" alt="img"></p>
<h3 id="1-11-UML类图"><a href="#1-11-UML类图" class="headerlink" title="1.11 UML类图"></a>1.11 UML类图</h3><p>继承关系用空心三角形+实线来表示</p>
<p>实现接口用空心三角形+虚线来表示。</p>
<p>关联关系用实线箭头来表示。</p>
<p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。聚合关系用空心的菱形+实线箭头来表示。</p>
<p>合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。</p>
<p>合成关系用实心的菱形+实线箭头来表示</p>
<p>合成关系的连线两端还有一个数字‘1’和数字‘2’，这被称为基数。表明这一端的类可以有几个实例</p>
<p>依赖关系（Dependency），用虚线箭头来表示。</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_24" alt="img"></p>
<h3 id="2-4-策略模式"><a href="#2-4-策略模式" class="headerlink" title="2.4 策略模式"></a>2.4 策略模式</h3><p><strong>策略模式（Strategy）</strong>：<mark>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_47" alt="img"></p>
<h3 id="2-7-策略模式解析"><a href="#2-7-策略模式解析" class="headerlink" title="2.7 策略模式解析"></a>2.7 策略模式解析</h3><ul>
<li><p>策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。</p>
</li>
<li><p>策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能</p>
</li>
<li><p>策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试</p>
</li>
<li><p>当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句</p>
</li>
<li><p>策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性</p>
</li>
<li><p>在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象任何需求的变更都是需要成本的。</p>
</li>
</ul>
<h3 id="3-4-单一职责原则"><a href="#3-4-单一职责原则" class="headerlink" title="3.4 单一职责原则"></a>3.4 单一职责原则</h3><p><strong>单一职责原则（SRP）</strong>：<mark>就一个类而言，应该仅有一个引起它变化的原因。<mark></mark></mark></p>
<h3 id="3-5-单一职责原则说明"><a href="#3-5-单一职责原则说明" class="headerlink" title="3.5 单一职责原则说明"></a>3.5 单一职责原则说明</h3><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏</p>
<p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。</p>
<p>如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。</p>
<h3 id="4-2-开放-封闭原则"><a href="#4-2-开放-封闭原则" class="headerlink" title="4.2 开放-封闭原则"></a>4.2 开放-封闭原则</h3><p><strong>开放-封闭原则</strong>：<mark>对于扩展是开放的（Open for extension）’，另一个是说‘对于更改是封闭的（Closed for modification）。<mark></mark></mark></p>
<p>怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？[ASD]</p>
<h3 id="4-3-开放-封闭原则说明"><a href="#4-3-开放-封闭原则说明" class="headerlink" title="4.3 开放-封闭原则说明"></a>4.3 开放-封闭原则说明</h3><ul>
<li><p>无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化[ASD]。</p>
</li>
<li><p>等到变化发生时立即采取行动</p>
</li>
<li><p>在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[</p>
</li>
<li><p>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。</p>
</li>
<li><p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难[ASD]。</p>
</li>
<li><p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要[ASD]。</p>
</li>
</ul>
<h3 id="5-3-依赖倒转原则"><a href="#5-3-依赖倒转原则" class="headerlink" title="5.3 依赖倒转原则"></a>5.3 依赖倒转原则</h3><p><strong>依赖倒转原则</strong>：<mark>原话解释是抽象不应该依赖细节，细节应该依赖于抽象，这话绕口，说白了，就是要针对接口编程，不要对实现编程。<mark></mark></mark></p>
<p>A．高层模块不应该依赖低层模块。两个都应该依赖抽象。B．抽象不应该依赖细节。细节应该依赖抽象。</p>
<ul>
<li>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了</li>
</ul>
<h3 id="5-4-里氏代换原则"><a href="#5-4-里氏代换原则" class="headerlink" title="5.4 里氏代换原则"></a>5.4 里氏代换原则</h3><p><strong>里氏代换原则</strong>：<mark>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。<mark></mark></mark></p>
<p><strong>里氏代换原则（LSP）：子类型必须能够替换掉它们的父类型。[ASD]</strong></p>
<ul>
<li><p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。</p>
</li>
<li><p>由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p>
</li>
</ul>
<p>依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。</p>
<h3 id="6-4-装饰模式"><a href="#6-4-装饰模式" class="headerlink" title="6.4 装饰模式"></a>6.4 装饰模式</h3><p><strong>装饰模式（Decorator）</strong>:<mark>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_63" alt="img"></p>
<p>Component是定义一个对象接口，可以给这些对象动态地添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。</p>
<p>装饰模式是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中</p>
<p>如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_63" alt="img"></p>
<h3 id="6-6-装饰模式总结"><a href="#6-6-装饰模式总结" class="headerlink" title="6.6 装饰模式总结"></a>6.6 装饰模式总结</h3><ul>
<li><p>装饰模式是为已有功能动态地添加更多功能的一种方式。</p>
</li>
<li><p>当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为，在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，就像你起初的那个‘人’类，而这些新加入的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。而装饰模式却提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了</p>
</li>
<li><p><strong>优点</strong>：1.把类中的装饰功能从类中搬移去除，这样可以简化原有的类。2.有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。</p>
</li>
</ul>
<h3 id="7-5-代理模式"><a href="#7-5-代理模式" class="headerlink" title="7.5 代理模式"></a>7.5 代理模式</h3><p><strong>代理模式（Proxy）</strong>:<mark>为其他对象提供一种代理以控制对这个对象的访问。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_76" alt="img"></p>
<h3 id="7-6-代理模式应用"><a href="#7-6-代理模式应用" class="headerlink" title="7.6 代理模式应用"></a>7.6 代理模式应用</h3><p>以下为几种应用的场合：</p>
<ul>
<li><p><strong>远程代理</strong>，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实</p>
</li>
<li><p><strong>虚拟代理</strong>，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象</p>
</li>
<li><p><strong>安全代理</strong>，用来控制真实对象访问时的权限</p>
</li>
<li><p><strong>智能指引</strong>，是指当调用真实的对象时，代理处理另外一些事</p>
</li>
</ul>
<h3 id="8-4-简单工厂vs-工厂方法"><a href="#8-4-简单工厂vs-工厂方法" class="headerlink" title="8.4 简单工厂vs.工厂方法"></a>8.4 简单工厂vs.工厂方法</h3><p><strong>简单工厂的实现</strong></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_77" alt="img"></p>
<p><strong>工厂方法的实现</strong>（定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。）</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_79" alt="img"></p>
<ul>
<li><p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。</p>
</li>
<li><p>我们把工厂类抽象出一个接口，这个接口只有一个方法，就是创建抽象产品的工厂方法。然后，所有的要生产具体类的工厂，就去实现这个接口，这样，一个简单工厂模式的工厂类，变成了一个工厂抽象接口和多个具体生成对象的工厂</p>
</li>
<li><p>工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端</p>
</li>
</ul>
<h3 id="9-3-原型模式"><a href="#9-3-原型模式" class="headerlink" title="9.3 原型模式"></a>9.3 原型模式</h3><p><strong>原型模式（Prototype）</strong>:<mark>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_86" alt="img"></p>
<p>原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。</p>
<h3 id="9-4原型模式的优点"><a href="#9-4原型模式的优点" class="headerlink" title="9.4原型模式的优点"></a>9.4原型模式的优点</h3><ul>
<li><p>一般在初始化的信息不发生变化的情况下，克隆是最好的办法。这既隐藏了对象创建的细节，又对性能是大大的提高</p>
</li>
<li><p>不用重新初始化对象，而是动态地获得对象运行时的状态。</p>
</li>
</ul>
<h3 id="10-4-模板方法模式"><a href="#10-4-模板方法模式" class="headerlink" title="10.4 模板方法模式"></a>10.4 模板方法模式</h3><p>重复=易错+难改</p>
<p><strong>模板方法模式</strong>:<mark>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_106" alt="img"></p>
<h3 id="10-5-模板方法模式特点"><a href="#10-5-模板方法模式特点" class="headerlink" title="10.5 模板方法模式特点"></a>10.5 模板方法模式特点</h3><ul>
<li><p>模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。</p>
</li>
<li><p>模板方法模式就是提供了一个很好的代码复用平台。</p>
</li>
<li><p>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</p>
</li>
</ul>
<h3 id="11-3-迪米特法则"><a href="#11-3-迪米特法则" class="headerlink" title="11.3 迪米特法则"></a>11.3 迪米特法则</h3><p><strong>迪米特法则（LoD）</strong>:<mark>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。<mark></mark></mark></p>
<ul>
<li><p>迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权。</p>
</li>
<li><p>类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</p>
</li>
</ul>
<h3 id="12-5-何时使用外观模式"><a href="#12-5-何时使用外观模式" class="headerlink" title="12.5 何时使用外观模式"></a>12.5 何时使用外观模式</h3><p><strong>外观模式（Facade）</strong>:<mark>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_114" alt="img"></p>
<p>在设计初期阶段，应该要有意识的将不同的两个层分离</p>
<h2 id="第13章-好菜每回味不同——建造者模式"><a href="#第13章-好菜每回味不同——建造者模式" class="headerlink" title="第13章 好菜每回味不同——建造者模式"></a>第13章 好菜每回味不同——建造者模式</h2><h3 id="13-1-炒面没放盐"><a href="#13-1-炒面没放盐" class="headerlink" title="13.1 炒面没放盐"></a>13.1 炒面没放盐</h3><p>依赖倒转原则？抽象不应该依赖细节，细节应该依赖于抽象</p>
<h3 id="13-4-建造者模式"><a href="#13-4-建造者模式" class="headerlink" title="13.4 建造者模式"></a>13.4 建造者模式</h3><p>如果你需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们需要应用于一个设计模式，‘建造者（Builder）模式’，又叫生成器模式。</p>
<p><strong>建造者模式（Builder）</strong>:<mark>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_123" alt="img"></p>
<p>指挥者（Director）一个很重要的类，用它来控制建造过程，也用它来隔离用户与建造过程的关联。”</p>
<h3 id="13-5-建造者模式应用"><a href="#13-5-建造者模式应用" class="headerlink" title="13.5 建造者模式应用"></a>13.5 建造者模式应用</h3><p>主要是用于创建一些复杂的对象，这些对象内部构建间的建造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。</p>
<h3 id="14-5-观察者模式"><a href="#14-5-观察者模式" class="headerlink" title="14.5 观察者模式"></a>14.5 观察者模式</h3><p><strong>观察者模式</strong>:<mark>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_136" alt="img"></p>
<h3 id="14-6-观察者模式特点"><a href="#14-6-观察者模式特点" class="headerlink" title="14.6 观察者模式特点"></a>14.6 观察者模式特点</h3><ul>
<li><p>动机：将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便</p>
</li>
<li><p>适用场景：当一个对象的改变需要同时改变其他对象的时候，而且它不知道具体有多少对象有待改变时，应该考虑使用观察者模式。另外，当一个抽象模型有两个方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p>
</li>
<li><p>解释：观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p>
</li>
</ul>
<h3 id="14-9-事件委托说明"><a href="#14-9-事件委托说明" class="headerlink" title="14.9 事件委托说明"></a>14.9 事件委托说明</h3><p><strong>委托就是一种引用方法的类型。</strong>一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。</p>
<ul>
<li><p>一个委托可以搭载多个方法，所有方法被依次唤起。更重要的是，它可以使得委托对象所搭载的方法并不需要属于同一个类。</p>
</li>
<li><p>委托对象所搭载的所有方法必须具有相同的原形和形式，也就是拥有相同的参数列表和返回值类型。</p>
</li>
</ul>
<h2 id="第15章-就不能不换DB吗？——抽象工厂模式"><a href="#第15章-就不能不换DB吗？——抽象工厂模式" class="headerlink" title="第15章 就不能不换DB吗？——抽象工厂模式"></a>第15章 就不能不换DB吗？——抽象工厂模式</h2><h3 id="15-5-抽象工厂模式"><a href="#15-5-抽象工厂模式" class="headerlink" title="15.5 抽象工厂模式"></a>15.5 抽象工厂模式</h3><p><strong>抽象工厂模式（Abstract Factory）</strong>:<mark>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_150" alt="img"></p>
<h3 id="15-6-抽象工厂模式的优点与缺点"><a href="#15-6-抽象工厂模式的优点与缺点" class="headerlink" title="15.6 抽象工厂模式的优点与缺点"></a>15.6 抽象工厂模式的优点与缺点</h3><ul>
<li><p>好处便是易于交换产品系列，由于具体工厂类，例如IFactory factory =new AccessFactory()，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具体工厂即可使用不同的产品配置</p>
</li>
<li><p>它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。</p>
</li>
</ul>
<p><strong>编程是门艺术，大批量的改动，显然是非常丑陋的做法。</strong>所以抽象工厂模式很酷。</p>
<h3 id="16-5-状态模式"><a href="#16-5-状态模式" class="headerlink" title="16.5 状态模式"></a>16.5 状态模式</h3><p><strong>状态模式（State）</strong>:<mark>当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_163" alt="img"></p>
<p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p>
<h3 id="16-6-状态模式好处与用处"><a href="#16-6-状态模式好处与用处" class="headerlink" title="16.6 状态模式好处与用处"></a>16.6 状态模式好处与用处</h3><p><mark>状态模式的好处<mark></mark></mark></p>
<ul>
<li><p>将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。</p>
</li>
<li><p>将特定的状态相关的行为都放入一个对象中，由于所有与状态相关的代码都存在于某个ConcreteState中，所以通过定义新的子类可以很容易地增加新的状态和转换。</p>
</li>
<li><p>状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖</p>
</li>
</ul>
<p><mark>状态模式的用处<mark></mark></mark></p>
<p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式</p>
<h3 id="17-2-适配器模式"><a href="#17-2-适配器模式" class="headerlink" title="17.2 适配器模式"></a>17.2 适配器模式</h3><p><strong>适配器模式（Adapter）</strong>:<mark>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<mark></mark></mark></p>
<p>用途：系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_173" alt="img"></p>
<p>两种类型：类适配器模式和对象适配器模式</p>
<h3 id="17-3-何时使用适配器模式"><a href="#17-3-何时使用适配器模式" class="headerlink" title="17.3 何时使用适配器模式"></a>17.3 何时使用适配器模式</h3><ul>
<li><p>使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。即两个类所做的事情相同或相似，但是具有不同的接口时要使用它。</p>
</li>
<li><p>在双方都不太容易修改的时候再使用适配器模式适配。</p>
</li>
</ul>
<h3 id="18-4-备忘录模式基本代码"><a href="#18-4-备忘录模式基本代码" class="headerlink" title="18.4 备忘录模式基本代码"></a>18.4 备忘录模式基本代码</h3><p><strong>备忘录（Memento）</strong>：<mark>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_186" alt="img"></p>
<p>Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator可以根据保存的Memento信息还原到前一状态。</p>
<ul>
<li><p>如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态</p>
</li>
<li><p>使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来</p>
</li>
<li><p>当角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原</p>
</li>
</ul>
<h3 id="19-2-组合模式"><a href="#19-2-组合模式" class="headerlink" title="19.2 组合模式"></a>19.2 组合模式</h3><p><strong>组合模式（Composite）</strong>:<mark>将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_196" alt="img"></p>
<h3 id="19-3-透明方式与安全方式"><a href="#19-3-透明方式与安全方式" class="headerlink" title="19.3 透明方式与安全方式"></a>19.3 透明方式与安全方式</h3><p><strong>透明方式</strong>，也就是说在Component中声明所有用来管理子对象的方法，其中包括Add、Remove等。这样实现Component接口的所有子类都具备了Add和Remove。这样做的好处就是叶节点和枝节点对于外界没有区别，它们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add()、Remove()方法的功能，所以实现它是没有意义的。</p>
<p><strong>安全方式</strong>，也就是在Component接口中不去声明Add和Remove方法，那么子类的Leaf也就不需要去实现它，而是在Composite声明所有用来管理子类对象的方法，这样做就不会出现刚才提到的问题，不过由于不够透明，所以树叶和树枝类将不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。</p>
<h3 id="19-4-何时使用组合模式"><a href="#19-4-何时使用组合模式" class="headerlink" title="19.4 何时使用组合模式"></a>19.4 何时使用组合模式</h3><p>需求中是体现部分与整体层次的结构时，以及你希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑用组合模式了。</p>
<h3 id="19-6-组合模式好处"><a href="#19-6-组合模式好处" class="headerlink" title="19.6 组合模式好处"></a>19.6 组合模式好处</h3><p>组合模式这样定义了类似包含人力资源部和财务部这些基本对象和分公司、办事处等组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，这样不断地递归下去，客户代码中，任何用到基本对象的地方都可以使用组合对象了。</p>
<h3 id="20-2-迭代器模式"><a href="#20-2-迭代器模式" class="headerlink" title="20.2 迭代器模式"></a>20.2 迭代器模式</h3><p><strong>迭代器模式（Iterator）</strong>:<mark>提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_203" alt="img"></p>
<p>当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，你就应该考虑用迭代器模式</p>
<p>你需要对聚集有多种方式遍历时，可以考虑用迭代器模式。</p>
<p>为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一的接口。</p>
<h3 id="20-4-迭代器模式的好处"><a href="#20-4-迭代器模式的好处" class="headerlink" title="20.4 迭代器模式的好处"></a>20.4 迭代器模式的好处</h3><p>迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<h3 id="21-3-生还是不生是自己的责任"><a href="#21-3-生还是不生是自己的责任" class="headerlink" title="21.3 生还是不生是自己的责任"></a>21.3 生还是不生是自己的责任</h3><p>所有类都有构造方法，不编码则系统默认生成空的构造方法，若有显示定义的构造方法，默认的构造方法就会失效。</p>
<h3 id="21-4-单例模式"><a href="#21-4-单例模式" class="headerlink" title="21.4 单例模式"></a>21.4 单例模式</h3><p><strong>单例模式（Singleton）</strong>:<mark>保证一个类仅有一个实例，并提供一个访问它的全局访问点。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_220" alt="img"></p>
<p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</p>
<p>单例模式因为Singleton类封装它的唯一实例，这样它可以严格地控制客户怎样访问它以及何时访问它。简单地说就是对唯一实例的受控访问。</p>
<h3 id="22-2-紧耦合的程序演化"><a href="#22-2-紧耦合的程序演化" class="headerlink" title="22.2 紧耦合的程序演化"></a>22.2 紧耦合的程序演化</h3><p>对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换。这种依赖关系限制了灵活性并最终限制了复用性。</p>
<p>在面向对象设计中，我们还有一个很重要的设计原则，那就是合成／聚合复用原则。即<strong>优先使用对象合成／聚合，而不是类继承。</strong></p>
<h3 id="22-3-合成／聚合复用原则"><a href="#22-3-合成／聚合复用原则" class="headerlink" title="22.3 合成／聚合复用原则"></a>22.3 合成／聚合复用原则</h3><p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样</p>
<p><strong>优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</strong></p>
<h3 id="22-5-桥接模式"><a href="#22-5-桥接模式" class="headerlink" title="22.5 桥接模式"></a>22.5 桥接模式</h3><p><strong>桥接模式（Bridge）</strong>:<mark>将抽象部分与它的实现部分分离，使它们都可以独立地变化。<mark></mark></mark></p>
<p>什么叫抽象与它的实现分离，这并不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_233" alt="img"></p>
<h3 id="23-6-命令模式"><a href="#23-6-命令模式" class="headerlink" title="23.6 命令模式"></a>23.6 命令模式</h3><p><strong>命令模式（Command）</strong>:<mark>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_246" alt="img"></p>
<h3 id="23-7-命令模式作用"><a href="#23-7-命令模式作用" class="headerlink" title="23.7 命令模式作用"></a>23.7 命令模式作用</h3><p>第一，它能较容易地设计一个命令队列；</p>
<p>第二，在需要的情况下，可以较容易地将命令记入日志；</p>
<p>第三，允许接收请求的一方决定是否要否决请求。</p>
<p>第四，可以容易地实现对请求的撤销和重做；</p>
<p>第五，由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。其实还有最关键的优点就是命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。</p>
<p><strong>敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。</strong>如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。</p>
<h3 id="24-3-职责链模式"><a href="#24-3-职责链模式" class="headerlink" title="24.3 职责链模式"></a>24.3 职责链模式</h3><p><strong>职责链模式（Chain of Responsibility）</strong>：<mark>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_249" alt="img"></p>
<h3 id="24-4-职责链的好处"><a href="#24-4-职责链的好处" class="headerlink" title="24.4 职责链的好处"></a>24.4 职责链的好处</h3><ul>
<li><p>当客户提交一个请求时，请求是沿链传递直至有一个ConcreteHandler对象负责处理它。</p>
</li>
<li><p>接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。结果是职责链可简化对象的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。</p>
</li>
<li><p>随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性。</p>
</li>
<li><p>需要注意的是：一个请求极有可能到了链的末端都得不到处理，或者因为没有正确配置而得不到处理</p>
</li>
</ul>
<h2 id="第25章-世界需要和平——中介者模式"><a href="#第25章-世界需要和平——中介者模式" class="headerlink" title="第25章 世界需要和平——中介者模式"></a>第25章 世界需要和平——中介者模式</h2><h3 id="25-2-中介者模式"><a href="#25-2-中介者模式" class="headerlink" title="25.2 中介者模式"></a>25.2 中介者模式</h3><p><strong>中介者模式（Mediator）</strong>:<mark>用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_263" alt="img"></p>
<h3 id="25-4-中介者模式优缺点"><a href="#25-4-中介者模式优缺点" class="headerlink" title="25.4 中介者模式优缺点"></a>25.4 中介者模式优缺点</h3><ul>
<li><p>中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了‘多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思你的系统在设计上是不是合理。</p>
</li>
<li><p>Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator</p>
</li>
<li><p>由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。</p>
</li>
<li><p>由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。</p>
</li>
</ul>
<p><mark>应用场景<mark></mark></mark></p>
<ul>
<li>中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。</li>
</ul>
<h3 id="26-2-享元模式"><a href="#26-2-享元模式" class="headerlink" title="26.2 享元模式"></a>26.2 享元模式</h3><p><strong>享元模式（Flyweight）</strong>:<mark>运用共享技术有效地支持大量细粒度的对象。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_272" alt="img"></p>
<h3 id="26-4-内部状态与外部状态"><a href="#26-4-内部状态与外部状态" class="headerlink" title="26.4 内部状态与外部状态"></a>26.4 内部状态与外部状态</h3><p>享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够受大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度地减少单个实例的数目。</p>
<h3 id="26-5-享元模式应用"><a href="#26-5-享元模式应用" class="headerlink" title="26.5 享元模式应用"></a>26.5 享元模式应用</h3><p>如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。</p>
<p>像围棋，一盘棋理论上有361个空位可以放棋子，那如果用常规的面向对象方式编程，每盘棋都可能有两三百个棋子对象产生，一台服务器就很难支持更多的玩家玩围棋游戏了，毕竟内存空间还是有限的。如果用了享元模式来处理棋子，那么棋子对象可以减少到只有两个实例，结果……你应该明白的。</p>
<h3 id="27-2-解释器模式（skip）"><a href="#27-2-解释器模式（skip）" class="headerlink" title="27.2 解释器模式（skip）"></a>27.2 解释器模式（skip）</h3><p><strong>解释器模式（interpreter）</strong>:<mark>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_280" alt="img"></p>
<p>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题</p>
<h3 id="27-3-解释器模式好处"><a href="#27-3-解释器模式好处" class="headerlink" title="27.3 解释器模式好处"></a>27.3 解释器模式好处</h3><ul>
<li><p>当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。</p>
</li>
<li><p>容易地改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写</p>
</li>
<li><p>解释器模式也有不足的，解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。建议当文法非常复杂时，使用其他的技术如语法分析程序或编译器生成器来处理</p>
</li>
</ul>
<h3 id="28-5-访问者模式"><a href="#28-5-访问者模式" class="headerlink" title="28.5 访问者模式"></a>28.5 访问者模式</h3><p><strong>访问者模式（Visitor）</strong>:<mark>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。<mark></mark></mark></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_41787784_296" alt="img"></p>
<p>访问者模式适用于数据结构相对稳定的系统？</p>
<p>它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化</p>
<p>访问者模式的目的是要把处理从数据结构分离出来。</p>
<p>有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。</p>
<p>访问者模式的优点就是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。</p>
<p>那访问者的缺点其实也就是使增加新的数据结构变得困难了。</p>
<p>大多时候你并不需要访问者模式，但当一旦你需要访问者模式时，那就是真的需要它了。</p>
<h3 id="29-7-行为型模式二组比赛"><a href="#29-7-行为型模式二组比赛" class="headerlink" title="29.7 行为型模式二组比赛"></a>29.7 行为型模式二组比赛</h3><p>如果一种特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题</p>
<p>面向对象设计鼓励将行为分布到各个对象中，这种分布可能会导致对象间有许多连接。也就是说，有可能每一个对象都需要知道其他许多对象。对象间的大量相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何较大的改动都很困难</p>
<p>访问者增加具体的Element是困难的，但增加依赖于复杂对象结构的构件的操作就变得容易。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。</p>
<p>继承提供了一种支持多种算法或行为的方法，我们可以直接生成一个类A的子类B、C、D，从而给它以不同的行为。但这样会将行为硬行编制到父类A当中，而将算法的实现与类A的实现混合起来，从而使得类A难以理解、难以维护和难以扩展，而且还不能动态地改变算法。仔细分析会发现，它们之间的唯一差别是它们所使用的算法或行为，将算法封装在独立的策略Strategy类中使得你可以独立于其类A改变它，使它易于切换、易于理解、易于扩展。</p>
<p>使用备忘录就不会出现这个问题，它可以避免暴露一些只应由对象A管理却又必须存储在对象A之外的信息。备忘录模式把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界。</p>
<p>迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。</p>
<h3 id="29-8-决赛"><a href="#29-8-决赛" class="headerlink" title="29.8 决赛"></a>29.8 决赛</h3><p>只要是在做面向对象的开发，创建对象的工作不可避免。创建对象时，负责创建的实体通常需要了解要创建的是哪个具体的对象，以及何时创建这个而非那个对象的规则。而我们如果希望遵循开放-封闭原则、依赖倒转原则和里氏代换原则，那使用对象时，就不应该知道所用的是哪一个特选的对象。此时就需要‘对象管理者’工厂来负责此事。</p>
<p>在创建对象时，使用抽象工厂、原型、建造者的设计比使用工厂方法要更灵活，但它们也更加复杂，通常，设计是以使用工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。</p>
<p>工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂。</p>
<h1 id="其他好句"><a href="#其他好句" class="headerlink" title="其他好句"></a>其他好句</h1><ul>
<li>一个程序员如果从来没有熬夜写程序的经历，不能算是一个好程序员，因为他没有痴迷过，所以他不会有大成就。</li>
<li>面向对象设计其实就是希望做到代码的责任分解。</li>
<li>所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。</li>
<li>代码无错未必优。</li>
<li>只要真正深入地理解了设计原则，很多设计模式其实就是原则的应用而已，或许在不知不觉中就在使用设计模式了。</li>
<li>尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性了。大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。</li>
<li>MVC是多种模式的综合应用，应该算是一种架构模式</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">寻宝游戏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/">http://example.com/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">寻宝游戏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></div><div class="post_share"><div class="social-share" data-image="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/21/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《软件测试的艺术》笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《软件测试的艺术》笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/24/%E5%90%B4%E6%81%A9%E8%BE%BEPrompt%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/" title="吴恩达Prompt网课笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">吴恩达Prompt网课笔记</div></div></a></div></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">寻宝游戏</div><div class="author-info__description">思维的乐趣。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/enternityFan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Do your own thing...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E4%B9%A6%E7%89%B9%E8%89%B2"><span class="toc-number">1.</span> <span class="toc-text">本书特色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-UML%E7%B1%BB%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">1.11 UML类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">2.4 策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">2.7 策略模式解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">5.</span> <span class="toc-text">3.4 单一职责原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99%E8%AF%B4%E6%98%8E"><span class="toc-number">6.</span> <span class="toc-text">3.5 单一职责原则说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%BC%80%E6%94%BE-%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99"><span class="toc-number">7.</span> <span class="toc-text">4.2 开放-封闭原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%BC%80%E6%94%BE-%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%E8%AF%B4%E6%98%8E"><span class="toc-number">8.</span> <span class="toc-text">4.3 开放-封闭原则说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99"><span class="toc-number">9.</span> <span class="toc-text">5.3 依赖倒转原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E9%87%8C%E6%B0%8F%E4%BB%A3%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">10.</span> <span class="toc-text">5.4 里氏代换原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">6.4 装饰模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">6.6 装饰模式总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">7.5 代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">7.6 代理模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82vs-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">8.4 简单工厂vs.工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">9.3 原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">17.</span> <span class="toc-text">9.4原型模式的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">10.4 模板方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%89%B9%E7%82%B9"><span class="toc-number">19.</span> <span class="toc-text">10.5 模板方法模式特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-number">20.</span> <span class="toc-text">11.3 迪米特法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">21.</span> <span class="toc-text">12.5 何时使用外观模式</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A5%BD%E8%8F%9C%E6%AF%8F%E5%9B%9E%E5%91%B3%E4%B8%8D%E5%90%8C%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">第13章 好菜每回味不同——建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E7%82%92%E9%9D%A2%E6%B2%A1%E6%94%BE%E7%9B%90"><span class="toc-number">1.</span> <span class="toc-text">13.1 炒面没放盐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">13.4 建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">13.5 建造者模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">14.5 观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%89%B9%E7%82%B9"><span class="toc-number">5.</span> <span class="toc-text">14.6 观察者模式特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-9-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E8%AF%B4%E6%98%8E"><span class="toc-number">6.</span> <span class="toc-text">14.9 事件委托说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E5%B0%B1%E4%B8%8D%E8%83%BD%E4%B8%8D%E6%8D%A2DB%E5%90%97%EF%BC%9F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">第15章 就不能不换DB吗？——抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-5-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">15.5 抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-6-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">15.6 抽象工厂模式的优点与缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">16.5 状态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E5%A5%BD%E5%A4%84%E4%B8%8E%E7%94%A8%E5%A4%84"><span class="toc-number">4.</span> <span class="toc-text">16.6 状态模式好处与用处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-2-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">17.2 适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">17.3 何时使用适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-4-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">18.4 备忘录模式基本代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-2-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">19.2 组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-%E9%80%8F%E6%98%8E%E6%96%B9%E5%BC%8F%E4%B8%8E%E5%AE%89%E5%85%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">19.3 透明方式与安全方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-4-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">19.4 何时使用组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-6-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E5%A5%BD%E5%A4%84"><span class="toc-number">11.</span> <span class="toc-text">19.6 组合模式好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">20.2 迭代器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">13.</span> <span class="toc-text">20.4 迭代器模式的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-3-%E7%94%9F%E8%BF%98%E6%98%AF%E4%B8%8D%E7%94%9F%E6%98%AF%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A3%E4%BB%BB"><span class="toc-number">14.</span> <span class="toc-text">21.3 生还是不生是自己的责任</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-4-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">21.4 单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-2-%E7%B4%A7%E8%80%A6%E5%90%88%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%BC%94%E5%8C%96"><span class="toc-number">16.</span> <span class="toc-text">22.2 紧耦合的程序演化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-%E5%90%88%E6%88%90%EF%BC%8F%E8%81%9A%E5%90%88%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">17.</span> <span class="toc-text">22.3 合成／聚合复用原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">22.5 桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-6-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">23.6 命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-7-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%BD%9C%E7%94%A8"><span class="toc-number">20.</span> <span class="toc-text">23.7 命令模式作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-3-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">21.</span> <span class="toc-text">24.3 职责链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-4-%E8%81%8C%E8%B4%A3%E9%93%BE%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">22.</span> <span class="toc-text">24.4 职责链的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC25%E7%AB%A0-%E4%B8%96%E7%95%8C%E9%9C%80%E8%A6%81%E5%92%8C%E5%B9%B3%E2%80%94%E2%80%94%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">第25章 世界需要和平——中介者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#25-2-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">25.2 中介者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-4-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">25.4 中介者模式优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-2-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">26.2 享元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-4-%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81%E4%B8%8E%E5%A4%96%E9%83%A8%E7%8A%B6%E6%80%81"><span class="toc-number">4.</span> <span class="toc-text">26.4 内部状态与外部状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-5-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">26.5 享元模式应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-2-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88skip%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">27.2 解释器模式（skip）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-3-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%A5%BD%E5%A4%84"><span class="toc-number">7.</span> <span class="toc-text">27.3 解释器模式好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-5-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">28.5 访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-7-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%BA%8C%E7%BB%84%E6%AF%94%E8%B5%9B"><span class="toc-number">9.</span> <span class="toc-text">29.7 行为型模式二组比赛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-8-%E5%86%B3%E8%B5%9B"><span class="toc-number">10.</span> <span class="toc-text">29.8 决赛</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%A5%BD%E5%8F%A5"><span class="toc-number"></span> <span class="toc-text">其他好句</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/06/%E9%9D%A2%E8%AF%95%E8%A3%85%E9%80%BC%E6%8C%87%E5%8D%97/" title="无题">无题</a><time datetime="2025-04-06T02:35:04.454Z" title="发表于 2025-04-06 10:35:04">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/05/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/" title="活着读后感">活着读后感</a><time datetime="2025-04-05T07:39:27.443Z" title="发表于 2025-04-05 15:39:27">2025-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/16/%E7%8E%B0%E4%BB%A3C++%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2024-06-16T07:09:09.546Z" title="发表于 2024-06-16 15:09:09">2024-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" title="左程云算法复习">左程云算法复习</a><time datetime="2024-06-03T12:13:48.000Z" title="发表于 2024-06-03 20:13:48">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="左程云经典面试题">左程云经典面试题</a><time datetime="2024-06-03T12:13:48.000Z" title="发表于 2024-06-03 20:13:48">2024-06-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2020 - 2025 By 寻宝游戏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      id: '00856c9190670a34a766aa2339edbfdf',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/'
    this.page.identifier = '/2023/07/10/%E3%80%8A%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E7%AC%94%E8%AE%B0/'
    this.page.title = '《大话设计模式》笔记'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Gitalk' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="8507814393" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: true,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>