<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cppcon视频观看笔记 | 寻宝游戏</title><meta name="author" content="寻宝游戏"><meta name="copyright" content="寻宝游戏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STL105为什么要了解STL105个算法？还要很好的了解？ 可以让代码表达的更好。 一般抽象级别更高。 有时非常壮观。 避免常见的错误，比如说off-by-one,empty loops,naive complexity. 被很多人使用，他们是c+++标准，并且一般和complier关系不大。  heaps123456789101112vector<int> v = {5, 3, 8">
<meta property="og:type" content="article">
<meta property="og:title" content="cppcon视频观看笔记">
<meta property="og:url" content="http://example.com/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="寻宝游戏">
<meta property="og:description" content="STL105为什么要了解STL105个算法？还要很好的了解？ 可以让代码表达的更好。 一般抽象级别更高。 有时非常壮观。 避免常见的错误，比如说off-by-one,empty loops,naive complexity. 被很多人使用，他们是c+++标准，并且一般和complier关系不大。  heaps123456789101112vector<int> v = {5, 3, 8">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg">
<meta property="article:published_time" content="2024-05-08T12:13:48.000Z">
<meta property="article:modified_time" content="2025-04-05T07:52:23.944Z">
<meta property="article:author" content="寻宝游戏">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="shortcut icon" href="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="canonical" href="http://example.com/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cppcon视频观看笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-05 15:52:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="寻宝游戏"><span class="site-name">寻宝游戏</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">cppcon视频观看笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-08T12:13:48.000Z" title="发表于 2024-05-08 20:13:48">2024-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-05T07:52:23.944Z" title="更新于 2025-04-05 15:52:23">2025-04-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E8%AF%BE%E5%AD%A6%E4%B9%A0/">网课学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="cppcon视频观看笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STL105"><a href="#STL105" class="headerlink" title="STL105"></a>STL105</h1><h2 id="为什么要了解STL105个算法？还要很好的了解？"><a href="#为什么要了解STL105个算法？还要很好的了解？" class="headerlink" title="为什么要了解STL105个算法？还要很好的了解？"></a>为什么要了解STL105个算法？还要很好的了解？</h2><ol>
<li>可以让代码表达的更好。</li>
<li>一般抽象级别更高。</li>
<li>有时非常壮观。</li>
<li>避免常见的错误，比如说off-by-one,empty loops,naive complexity.</li>
<li>被很多人使用，他们是c+++标准，并且一般和complier关系不大。</li>
</ol>
<h2 id="heaps"><a href="#heaps" class="headerlink" title="heaps"></a>heaps</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">make_heap(begin(v), end(v));</span><br><span class="line">display(v);</span><br><span class="line"></span><br><span class="line">v.push_back(10);</span><br><span class="line">push_heap(begin(v), end(v));</span><br><span class="line">display(v);</span><br><span class="line">pop_heap(begin(v), end(v)); // 此时并不会删除，而是给他放到了最后。</span><br><span class="line">display(v);</span><br><span class="line">// 注意，使用sort_heap()函数会使序列失去堆的属性。</span><br><span class="line">sort_heap(begin(v), end(v));</span><br><span class="line">display(v);</span><br></pre></td></tr></tbody></table></figure>



<h2 id="sorting"><a href="#sorting" class="headerlink" title="sorting"></a>sorting</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void display(vector&lt;int&gt; &amp;v)</span><br><span class="line">{</span><br><span class="line">    for (auto i = 0; i &lt; v.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; " ";</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    vector&lt;int&gt; v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">    display(v);</span><br><span class="line">    // 部分排序</span><br><span class="line">    partial_sort(v.begin(), v.begin() + 5, v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    // 对第n个进行排序，用于将序列中的第 n 个元素（按升序或降序排列）</span><br><span class="line">    // 放置在其在完全排序后应该处于的位置，而不必对整个序列进行排序。</span><br><span class="line">    nth_element(v.begin(), v.begin() + 3, v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    sort_heap(v.begin(), v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    printf("======================\n");</span><br><span class="line">    v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">    display(v);</span><br><span class="line">    //用于在给定范围内执行原地归并操作，即将两个已经</span><br><span class="line">    //有序的序列合并成一个有序序列，将结果存储在原始范围内。</span><br><span class="line">    inplace_merge(v.begin(), v.begin() + 3, v.end());</span><br><span class="line">    display(v);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="partitioning"><a href="#partitioning" class="headerlink" title="partitioning"></a>partitioning</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void display(vector&lt;int&gt; &amp;v)</span><br><span class="line">{</span><br><span class="line">    for (auto i = 0; i &lt; v.size(); i++)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt; " ";</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    vector&lt;int&gt; v = {5, 3, 8, 1, 9, 2, 6, 7, 4};</span><br><span class="line">    display(v);</span><br><span class="line">    // 当你需要将一个序列划分成满足某个条件的元素和</span><br><span class="line">    // 不满足该条件的元素两部分时，std::partition 是一个很有用的算法。</span><br><span class="line">    //  将偶数放在前面，奇数放在后面</span><br><span class="line">    std::partition(v.begin(), v.end(), [](int n)</span><br><span class="line">                   { return n % 2 == 0; });</span><br><span class="line">    display(v);</span><br><span class="line">    sort(v.begin(), v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    // 循环的给rotate到后面</span><br><span class="line">    rotate(v.begin(), v.begin() + 3, v.end());</span><br><span class="line">    display(v);</span><br><span class="line">    // 使用默认的随机数引擎来打乱向量中的元素</span><br><span class="line">    std::random_device rd;                             // 获取随机设备</span><br><span class="line">    std::mt19937 gen(rd());                            // 使用随机设备生成种子</span><br><span class="line">    std::shuffle(v.begin(), v.end(), gen); // 打乱向量中的元素</span><br><span class="line">    display(v);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>





<h2 id="query"><a href="#query" class="headerlink" title="query"></a>query</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240510091252496.png" alt="image-20240510091252496"></p>
<h1 id="Templates-in-C-Nicolai-Josuttis-cppcon2022"><a href="#Templates-in-C-Nicolai-Josuttis-cppcon2022" class="headerlink" title="Templates in C++ Nicolai Josuttis (cppcon2022)"></a>Templates in C++ Nicolai Josuttis (cppcon2022)</h1><p>在模板中，总是存在一些隐式的要求，例如说下面是一个非常典型的例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 下面内容隐含了T支持比较，二是支持拷贝赋值。</span><br><span class="line">auto mymax(const auto &amp;a, const auto &amp;b)</span><br><span class="line">{</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但是对于下面的这个例子来说，就更加的不容易看出来了,下面的print函数其实隐含了对 &lt;&lt;的要求，所以对于右边的Stack&lt;pair&lt;int,double&gt;&gt;来说，<strong>其实如果不调用print也是没有太大问题的</strong>：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512165230165.png" alt="image-20240512165230165"></p>
<p>构造函数模板参数自动推导(cpp17):</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; v{0,8,15}; // cpp11</span><br><span class="line">std::vector v{0,8,15} // cpp 17</span><br></pre></td></tr></tbody></table></figure>

<p>对于上面的第二行代码，在实例化时会经历overload resolution的几个阶段来找到最终匹配的构造函数，这个过程编译器做的其实很快的。:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512170140531.png" alt="image-20240512170140531"></p>
<p>这个功能有的时候会出现问题，如下面的这个case:</p>
<p>对于v4,可能我们并不是想这样用的，得到了错误的推断，那么这个时候，鼓励最好使用v5.</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512170252545.png" alt="image-20240512170252545"></p>
<p>so,==<strong>Dont use CTAD unless deduction is obvious</strong>==</p>
<p>CTAD比如说下面的场景就很有用:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512170252545.png"></p>
<p>std::array&lt;&gt;is aTemplified Aggregate:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T,size_t SZ&gt;</span><br><span class="line">struct array{</span><br><span class="line">	T elems[SZ];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>



<p>NTTP Types:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512174526924.png" alt="image-20240512174526924"></p>
<p>下面是编译时if constexpr的一个妙用:<br><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512175344469.png" alt="image-20240512175344469"></p>
<h1 id="Back-To-Basics-Standard-Library-Containers-RAINER-GRIMM"><a href="#Back-To-Basics-Standard-Library-Containers-RAINER-GRIMM" class="headerlink" title="Back To Basics Standard Library Containers RAINER GRIMM"></a>Back To Basics Standard Library Containers RAINER GRIMM</h1><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512175652691.png" alt="image-20240512175652691"></p>
<h2 id="Container的接口"><a href="#Container的接口" class="headerlink" title="Container的接口"></a>Container的接口</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180007321.png" alt="image-20240512180007321"></p>
<p>一般来说，我们应该把string看做是vector<char>。</char></p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180135151.png" alt="image-20240512180135151"></p>
<h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180154634.png" alt="image-20240512180154634"></p>
<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p>empty()</p>
<p>size()</p>
<p>max_size()</p>
<h3 id="Assignment-and-swap"><a href="#Assignment-and-swap" class="headerlink" title="Assignment and swap"></a>Assignment and swap</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180346509.png" alt="image-20240512180346509"></p>
<h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180418451.png" alt="image-20240512180418451"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>支持range-base for</li>
<li>list有特殊的成员函数对指针的操作</li>
<li>forward_list只用于极个别特殊的case</li>
</ul>
<h2 id="Sequence-Containers"><a href="#Sequence-Containers" class="headerlink" title="Sequence Containers"></a>Sequence Containers</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512180618281.png" alt="image-20240512180618281"></p>
<h1 id="Object-Oriented-Programming-Amir-Kirsh"><a href="#Object-Oriented-Programming-Amir-Kirsh" class="headerlink" title="Object Oriented Programming Amir Kirsh"></a>Object Oriented Programming Amir Kirsh</h1><p>在面向对象编程中，<strong>我们要以数据为中心</strong>，所有的成员函数，所有的操作符，说白了也都是围绕着数据进行的。</p>
<ul>
<li>成员函数不占用类的大小。</li>
<li>类的大小包括所有的数据成员，可能会有虚函数指针，也可能包含padding的部分。</li>
<li>Ctor init list的使用场景1.高效、正确，但是在某些场景下你必须这样做：1.包含了没有提供默认构造函数和no initializaion on declaration的，2.含常数据成员和引用数据成员的，因为他们必须初始化，4.基类没有默认构造的。</li>
<li>A&amp; A::operator=(A a)可以吗？可以，这东西可以处理复制和移动，额，写笔记的时候我现在是不细究的，这玩意可以免去一些编码的麻烦，但是效率低，不推荐。</li>
<li>单参数推荐用explicit，并且如果构造函数他正在获取对象的完整状态，最好用显式构造。</li>
<li>临时对象在语句的末尾死亡。</li>
<li><strong>零原则：如果类不需要任何管理资源的方式是最好的。</strong>也就意味着不需要dtor,copy ctor,assignment operator,defaults do the job, defaults for move operations.为了实现它，使用恰当的管理数据的方法,如string,std的containers,unique_ptr,shared_ptr.</li>
<li>“<strong>三原则：如果你需要一个析构函数，那么首先就是把copy ctor和assigment operator给block掉</strong>“。一定要立即删除，就算是觉得以后可能会用，那么就先写todo。主要是这俩东西可能会导致两个对象指向同一个资源。</li>
<li><strong>五原则</strong>：如果实现了5个中的任何一个，<strong>那一定要保证移动语义相关的也要被实现。</strong></li>
<li><strong>在性能面前，要考虑我们需要的是数据的结构，还是结构的数据。</strong></li>
<li>状态模式可以用来避免一些丑陋的集成，很好使，当我们的类的继承关系变得丑陋的话，<strong>那可以考虑用状态模式进行重构，这是一个很重要的模式</strong>：</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512202444348.png" alt="image-20240512202444348"></p>
<ul>
<li>stragegy模式也很好。</li>
<li></li>
</ul>
<p>下面是一个较好的总结：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512202731901.png" alt="image-20240512202731901"></p>
<p>OO的低层的设计原则：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512201942460.png" alt="image-20240512201942460"></p>
<p>继承的设计原则:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512202822916.png" alt="image-20240512202822916"></p>
<p>代替继承的一些手段:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512203203496.png" alt="image-20240512203203496"></p>
<h1 id="Master-C-Value-Categories-With-Standard-Tools-Inbal-Levi"><a href="#Master-C-Value-Categories-With-Standard-Tools-Inbal-Levi" class="headerlink" title="Master C++ Value Categories With Standard Tools - Inbal Levi"></a>Master C++ Value Categories With Standard Tools - Inbal Levi</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512204151842.png" alt="image-20240512204151842"></p>
<p>我用compiler测也是这样:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512204709444.png" alt="image-20240512204709444"></p>
<p>对于d4调用两次ctor，是因为由于 <code>getData(42)</code> 返回的是 <code>const Data</code> 类型的临时对象，它不能被直接移动，因为右值引用不能绑定到 <code>const</code> 对象。所以编译器会忽略 <code>std::move</code>，而调用复制构造函数来创建 <code>d4</code>，<strong>chatgpt牛逼。</strong></p>
<ul>
<li>我们可以使用move来显示的把对象变为“灰色”，但是有些条件也可以隐式的把对象变为灰色。（灰色意味着编译器知道它可以直接从对象里进行“偷”。</li>
<li><strong>值类别是一个表达式的性质</strong>，在不同的上下文中可能有不同的值类别。</li>
<li>左值的常引用可以延长生命周期。</li>
<li>右值引用也可以延长临时对象的生命周期。</li>
<li></li>
</ul>
<p>什么是值类别：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512205657063.png" alt="image-20240512205657063"></p>
<p>下面是一个有意思的例子</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512210307119.png" alt="image-20240512210307119"></p>
<p>下面是一个值类型的总结：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512210731715.png" alt="image-20240512210731715"></p>
<p>常见的初始化时的绑定规则:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512211334313.png" alt="image-20240512211334313"></p>
<p>function call的绑定规则：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512212021801.png" alt="image-20240512212021801"></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512212044319.png" alt="image-20240512212044319"></p>
<h2 id="Tools-for-handling-value-categories"><a href="#Tools-for-handling-value-categories" class="headerlink" title="Tools for handling value categories"></a>Tools for handling value categories</h2><p>以下几种，据说Deducing this是一个很好的特性：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240512212440507.png" alt="image-20240512212440507"></p>
<h1 id="Declarations-in-C-BenSaks"><a href="#Declarations-in-C-BenSaks" class="headerlink" title="Declarations in C++ BenSaks"></a>Declarations in C++ BenSaks</h1><p>一个计算机程序必备实体，和涉及这些实体的行为，在c++中，一个实体可以是函数，命名空间，物体，模板，类型，值。c++程序可以声明指定实体的名称,声明的名称可以具有关联的属性如，类型，范围，储存持续时间，链接：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514081528990.png" alt="image-20240514081528990"></p>
<ul>
<li>所有的定义都是声明，但不是所有的声明，都是定义。</li>
<li>非定义声明将名称引入程序，表明了：这个存在，但不是这。</li>
<li>每一个声明说明符都要么是一个类型说明符，要么是非类型说明符，非类型说明符是指extern,static,virtual，friend。</li>
<li><strong>const是一个类型说明符，很像long 或者说 unsigned,修饰同一个声明中的其他的类型说明符。*const和*有相同的操作符优先级。</strong></li>
<li>一个声明是由声明id(declarator-id)组成的，可能会被操作符包围，比如说*,&amp;,&amp;&amp;,[],().</li>
<li>在声明的操作符中，我们有以下的优先级,所以对于<code>*X[N]</code>来说，他是一个指针数组，因为[]的优先级更高。:</li>
<li><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514082428594.png" alt="image-20240514082428594"></li>
</ul>
<p><code>*f(int)</code>代表是一个接受int，返回*的一个函数，<code>(*f)int</code>代表是一个函数指针，接收int返回somthing，他们的区别是因为()改变的优先级。</p>
<ul>
<li><p>constexpr的表现更像一个non-type specifier,比如说<code>constexpr unsigned long int *x[N]</code>这里的constexpr其实修饰的是x。</p>
</li>
<li><p><strong>Two-phase transition：</strong>在编译模板的时候，第一阶段，由于不知道类型T到底是什么，编译器不能检测出所有的错误，但是它仍然尽可能的去对错误进行探测，第二阶段，当这个模板函数被调用的时候，如<code>foo(i)</code>,编译器会推导出T的实际类型，或者说这里被显式指定了，然后将推导的类型替换为T，并执行完整的语法和语义分析。<strong>第二阶段可能会执行多次，因为模板可能会被多个不同类型进行实例化。</strong></p>
</li>
<li><p>如果T::size_type是一个type，并且T::nppos是一个type，<code>T::size_type *i(T::npos)</code>比如说对于这个case，我们其实是想生命一个i，用T::npos进行初始化，但是呢，由于上面所提到的规则，最终他会被当做是一个接受T::npos类型，返回T::size_type * 类型的函数i.</p>
</li>
<li><p>如果T::size_type不是一个type，并且T::nppos不是一个type，那么编译器可能会把<code>T::size_type *i(T::npos)</code>当做一个乘法表达式。</p>
</li>
<li><p>如果T::size_type是一个type，T::npos是一个常数，object，或者function，那么<code>T::size_type *i(T::npos)</code>会被当做对象定义。</p>
</li>
<li><p>出现在模板中的名称,其含义必取决于一个或多个横板参数的叫做dependent name.对于这种情况，我们需要在前面再加上typenam关键字修饰。</p>
</li>
<li><p>下面这个case中，T&amp;&amp;是一个右值引用：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void dispath(T&amp;&amp; arg){</span><br><span class="line">	T&amp;&amp; temp = f(arg); // 这个temp是个右值引用，而arg是一个forwarding reference.</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h1 id="Cpp-Value-Semantics-Klaus-lglberger"><a href="#Cpp-Value-Semantics-Klaus-lglberger" class="headerlink" title="Cpp Value Semantics - Klaus lglberger"></a>Cpp Value Semantics - Klaus lglberger</h1><p>下面这种编程风格有一些缺点,注意下面图里的classic应该是翻译为传统的。:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514091840291.png" alt="image-20240514091840291"></p>
<p>现在确实有更好的解决方式，通常用基于值语义的解决方案，比如说<strong>std::variant</strong>,<strong>我们应该积极的去拥抱，variant。</strong>比如说，上面我们就可以直接<code>using shape = std::variant&lt;Circle,Square&gt;;</code>这种方式的优点:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240514092313762.png" alt="image-20240514092313762"></p>
<ul>
<li>Modern Visitor Style就是用值语义去做，这会让代码更容易去理解（代码量少），让代码更容易去写，让代码更正确。让代码更快，比<strong>引用语义</strong>更好。</li>
<li>引用语义是通过span来实现的，如果长时间使用是可能有风险的：</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240515083440242.png" alt="image-20240515083440242"></p>
<ul>
<li>C+应该认真考虑值语义。比如说optional,any,function,expected,STL库的设计等。</li>
<li>用optional做返回值有下面这些好处，首先是没有所有权的问题，语义的问题，异常开销，很高效简单。</li>
<li>这个talk最主要的是，值语义比引用语义更好。</li>
</ul>
<h1 id="C-API-Design-Jason-Turner"><a href="#C-API-Design-Jason-Turner" class="headerlink" title="C++ API Design Jason Turner"></a>C++ API Design Jason Turner</h1><p>这个topic的重点是：Make your API Hard To Use Wrong.</p>
<p>下面是一个简单的例子:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>; <span class="comment">// easy to use wrong.</span></span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>; <span class="comment">// hard to use wrong.</span></span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>[[nodiscard]]应该被广泛使用，任何非mutating（getter/accessor/const)的函数都应该被设置为nodiscard。他可以传递一个message[[nodiscard(“XXX should never be discard”]].从cpp20开始也可以被用于构造函数。</li>
<li>noexcept通知用户（和编译器）该函数可能不会抛出异常。如果从该函数抛出异常，必须调用terminate。</li>
<li>下面是一种很好的工厂函数的写法:<code>[[nodiscard]]std::unique_ptr&lt;Widget&gt; make_weight(WidgetType type)</code>,不容易出错。</li>
<li>**never return  a raw pointer.**因为有很多问题，谁拥有这个指针？谁把它删除了？他是全局的单例吗？考虑使用<code>owning_ptr</code>或者<code>no_owning_ptr</code>,或者一些零成本的包装在指针外面做一些，如果你必须的话。</li>
<li><strong>设计一致的错误处理策略。</strong>并且要强烈避免外带的错误报告，如errno，因为这会破坏了多线程友好的环境。所以我们要尽量让错误不能忽略，而不是返回一个错误代码。不要用optional来指示错误条件，它没有传递错误的理由，可以考虑用std::expected(cpp23)</li>
<li>下面是一个综合了上面的一些建议，对fopen重写的一个示例:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520085151221.png" alt="image-20240520085151221"></p>
<ul>
<li><strong>避免容易交换的参数。</strong>首先，两个相同类型的参数容易被交换，其次，就是<strong>避免隐式类型转换，或者使用强类型。</strong>下面是一个有趣的示例，可以避免char*的隐式转换带来的问题，就是为其多写一个重载,<strong>如果您=删除模板，它将成为任何非精确模板的匹配项参数和防止隐式转换</strong>,或者就是我们主动的明确的进行删除某个类型的<code>void func(double data)=delete</code>:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520085658505.png" alt="image-20240520085658505"></p>
<ul>
<li>为了验证我们的API设计的是否健壮，<strong>可以使用fuzzer进行测试，他会随机的对API进行一些输入然后去测试。</strong></li>
</ul>
<h1 id="RAII-in-Cpp-Andre-Kostur"><a href="#RAII-in-Cpp-Andre-Kostur" class="headerlink" title="RAII in Cpp Andre Kostur"></a>RAII in Cpp Andre Kostur</h1><p>额。。没咋认真看，感觉有用的东西不多。</p>
<h1 id="Smart-Pointers-David-Olsen"><a href="#Smart-Pointers-David-Olsen" class="headerlink" title="Smart Pointers David Olsen"></a>Smart Pointers David Olsen</h1><ul>
<li>对于unique_ptr，如果想把所有权转移到另外一个独占指针，不要使用<code>a.reset(b.release())</code>的形式，而是应该使用移动语义：<code>a = str::move(b);</code></li>
<li>当我们要把所有权转移到函数中，通过传值的方式传入std::unique_ptr。当我们要把所有权从函数中传出时，通过return std::unique_ptr的方式。</li>
<li><strong>不要通过指针来创建unique_ptr，除非知道该指针的来向并且他需要一个owner。</strong></li>
<li>unique_ptr不解决悬空指针的问题:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520213948099.png" alt="image-20240520213948099"></p>
<ul>
<li><strong>shared_ptr的use_count线程不安全。噢噢噢因为当我们使用use_count的返回值的时候，可能多线程中已经改变了计数了，那么此时我们使用的返回值已经滞后了的。所以不应该在多线程的生产环境中使用。</strong></li>
<li>若要共享所有权，必须创建额外的共享PTR对象或从一个现有的共享PTR，而不是原始指针：</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520215756656.png" alt="image-20240520215756656"></p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520215916734.png" alt="image-20240520215916734"></p>
<ul>
<li><strong>从不同的线程更新相同的控制块，是线程安全的:</strong></li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520220032937.png" alt="image-20240520220032937"></p>
<ul>
<li>但是不同的线程更新管理的对象是线程不安全的:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520220231080.png" alt="image-20240520220231080"></p>
<ul>
<li>cpp17时shared_ptr才支持array类型，cpp20才支持make_shared类型。</li>
<li>如果不知道改用shared_ptr还是unique_ptr，那么最好用unique_ptr，因为后面就算要改shared_ptr也会容易很多。</li>
<li>weak_ptr可以用来做缓存，其通过保持了一个“引用”使得可以获得对对象的快速访问，同时也可以使得不去让对象一直存活（如果用shared_ptr的话就会一直活)。还有就是可以解决悬空引用的问题。</li>
<li>自定义删除器来自动调用fclose:<code>struct fclose_deleter(){ void operator()(FILE* fp){fclose(fp);}; using unique_FILE = std::unique_ptr&lt;FILE,fclose_deleter&gt;;}</code></li>
<li>别名构造函数，可以实现两个智能指针使用相同的控制块，但是有不同的对象指针：</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520221439507.png" alt="image-20240520221439507"></p>
<ul>
<li>shared_from_this:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240520221537834.png" alt="image-20240520221537834"></p>
<h1 id="Testing-Amir-Kirsh"><a href="#Testing-Amir-Kirsh" class="headerlink" title="Testing - Amir Kirsh"></a>Testing - Amir Kirsh</h1><ul>
<li>单元测试是对函数，类的测试，如果我们可以单独的测试每一个函数和类，那么也可以尽快的在系统准备就绪之前发现bug。单元测试是重点，<strong>因为此时还处于项目的早期。</strong></li>
<li>好的单元测试可维护性强，可读性强，可依赖性强。</li>
<li>这个会议还是讲了很多gtest的使用的，不过没咋认真听。。额。。</li>
</ul>
<h1 id="Debugging-in-C-Mike-Shah"><a href="#Debugging-in-C-Mike-Shah" class="headerlink" title="Debugging in C++ Mike Shah"></a>Debugging in C++ Mike Shah</h1><ul>
<li><p>常见的普通的策略:</p>
<ol>
<li>Scan and look:如果对软件很熟悉，可能可以直接find bug.另外就是依赖编译器进行扫描，编译选项加上<code>-Wall -Wextra</code>。</li>
<li>printf调试策略。</li>
<li>delta调试策略。可以快速的帮忙找到错误发生的大致位置，就算没有源码，比如说<code>square(5) == 25</code>这行代码有bug，那么我们可以快速的定位到是square，也就是说通过先前拥有的专业知识进行定位的。</li>
<li>printf调试策略的加强：利用语言特性进行加强，如宏定义、文本替换，预处理指令等。通过这种方式我们可以让程序干净一点，</li>
<li>linux可以研究一下ptrace。</li>
<li>gdb清空终端打印利用ctrl L实现，或者refresh命令也可以。</li>
<li>target record-full 可以回退debuging，需要是新的调试器才行。</li>
<li>我们可以通过whatis object_name来知道object的类型，并且通过info vtbl来查看虚函数表。</li>
</ol>
<h1 id="Move-Semantics-Andreas-Fertig"><a href="#Move-Semantics-Andreas-Fertig" class="headerlink" title="Move Semantics - Andreas Fertig"></a>Move Semantics - Andreas Fertig</h1><p>移动和复制的示例:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="C:\Users\14064\AppData\Roaming\Typora\typora-user-images\image-20240522090932085.png" alt="image-20240522090932085"></p>
<p>值域:<br><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240522091658478.png" alt="image-20240522091658478"></p>
<ul>
<li><p><strong>使用exchange来实现移动的操作(cpp17)，面试的时候就写这个代码，加分项</strong>:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240522092024609.png" alt="image-20240522092024609"></p>
<ul>
<li><strong>被move后的对象会处于有效但未知的状态。这是因为cpp实现的是non-destructive move.</strong></li>
<li>两个规则：一般来说我们遵循simple rule，剩下的10%的时间，我们遵循第二条:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240522092703163.png" alt="image-20240522092703163"></p>
</li>
</ul>
<h1 id="Memory-Model-from-C-11-to-C-23"><a href="#Memory-Model-from-C-11-to-C-23" class="headerlink" title="Memory Model from C++11 to C++23"></a>Memory Model from C++11 to C++23</h1></li>
</ul>
<h2 id="Memory-Barrier"><a href="#Memory-Barrier" class="headerlink" title="Memory Barrier"></a>Memory Barrier</h2><p>他会限制中间的东西不会移动出去，但是中间的东西还是可能会发生重排的:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524075921689.png" alt="image-20240524075921689"></p>
<h2 id="c-并发"><a href="#c-并发" class="headerlink" title="c++并发"></a>c++并发</h2><ul>
<li>在X86系统上，atomic的load只是load，没有额外的性能开销。对于其他的机子的话可能会有加锁，加屏障的开销。</li>
<li>在x86系统上，atomic存储使用xchg，这是全屏障，需要开销。</li>
<li>c++20  std::atomic&lt; std::shared_ptr &gt;&gt;</li>
<li>jthread</li>
</ul>
<h1 id="以上的视频大都是cppcon2022的back-to-basics-以下是2023的"><a href="#以上的视频大都是cppcon2022的back-to-basics-以下是2023的" class="headerlink" title="以上的视频大都是cppcon2022的back to basics 以下是2023的"></a>以上的视频大都是cppcon2022的back to basics 以下是2023的</h1><h1 id="Range-Algorithms-in-C-Klaus-lglberger"><a href="#Range-Algorithms-in-C-Klaus-lglberger" class="headerlink" title="(Range) Algorithms in C++ Klaus lglberger"></a>(Range) Algorithms in C++ Klaus lglberger</h1><p>min_element():</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524082539055.png" alt="image-20240524082539055"></p>
<p>在这里学到了一个tip就是可以在cppreference中看到这个STL函数实现的源码:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524082615205.png" alt="image-20240524082615205"></p>
<p>在c++20中，我们可以使用std::ranges::min_element()再对上面进行简化:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524082708699.png" alt="image-20240524082708699"></p>
<p>下面是用ranges::partition()进行优化的例子:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524083334451.png" alt="image-20240524083334451"></p>
<p>下面是关于accumulate的一个很好的例子:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524085021856.png" alt="image-20240524085021856"></p>
<p>这里提供double的话，就不会出错，如果提供的是0的话，由于vector中的元素类型的double，那么会有问题的对于accumulate，在模板推导的时候。</p>
<ul>
<li><strong>accumulate保证从左到右的进行累加。</strong></li>
</ul>
<h1 id="C-Concurrency-David-Olsen"><a href="#C-Concurrency-David-Olsen" class="headerlink" title="C++ Concurrency - David Olsen"></a>C++ Concurrency - David Olsen</h1><p>cpp并行算法：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524091558591.png" alt="image-20240524091558591"></p>
<ul>
<li>数据竞争是未定义行为。</li>
<li>不要调用互斥锁的unlock()、lock()、try_lock()，永远用lock_guard。</li>
<li>std::scoped_lock的构造函数会调用每一个锁的lock()，析构函数会调用每一个锁的unlock()。</li>
<li>unique_lock是想要在作用域中取消几次解锁使用的。</li>
<li>由于没有同步机制，对于下面的这个case，<strong>编译器可能会把子线程中的while改为无限循环！或者也可能直接跳过了while循环，不等flag=true的设置。</strong>compile的连接:<a target="_blank" rel="noopener" href="https://godbolt.org/z/Gj8dsq9n6">https://godbolt.org/z/Gj8dsq9n6</a></li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525092608796.png" alt="image-20240525092608796"></p>
<ul>
<li>少更新的示例，下图不是一个很好的方法，因为更新的太频繁了:</li>
<li><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525093131596.png" alt="image-20240525093131596"></li>
</ul>
<p>我们可以给他优化成下面的这种形式:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525093156389.png" alt="image-20240525093156389"></p>
<h1 id="Back-to-Basics-Functions-in-C-Mike-Shah"><a href="#Back-to-Basics-Functions-in-C-Mike-Shah" class="headerlink" title="Back to Basics- Functions in C++ Mike Shah"></a>Back to Basics- Functions in C++ Mike Shah</h1><ul>
<li>把函数定义封装到几个文件中的好处，比如说隐藏实现细节，潜在的加速编译，可以循环利用代码</li>
<li>传引用的好处:1.想修改传入的值。2.避免拷贝。3.比指针更加安全。 </li>
<li>高阶函数:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525102654605.png" alt="image-20240525102654605"></p>
<ul>
<li>函数表:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525102731519.png" alt="image-20240525102731519"></p>
<h1 id="Initialization-in-C-Ben-Saks"><a href="#Initialization-in-C-Ben-Saks" class="headerlink" title="Initialization in C++ Ben Saks"></a>Initialization in C++ Ben Saks</h1><p>==看这个会议让我明白了聚合体很大概率是为了初始化？==</p>
<ul>
<li><p>copy-initializaiton:  <code>int x = 3;int* p = &amp;x;</code>，以下是其他的一些发生的情景：</p>
</li>
<li><p>aggregate-initialization:<code>struct widget{int id;double price;};widget w1 = {1000,6.5};int values[3] = {1,2,3};</code></p>
</li>
<li><p>zero-initialization: <code>widget w2 = {100}; // equal {100,0,0}</code></p>
</li>
<li><p>direct-Initialization:为了让用户自定义类型和内置类型统一，cpp支持像构造函数一样初始化scalar types:<code>int x(5);</code>cpp20开始支持direct-initialization初始化聚合体:<code>demo_str ds1("hello",5);demo_str ds2(ds1);</code>,<strong>实际上，以上两种都被当做 了direct-initialization.但是下面的被当做了copy-initialization，虽然他和ds2(ds1)一样调用的都是拷贝构造函数:<code>demo_str ds3 = ds2;</code></strong></p>
</li>
<li></li>
<li><p>因为类不变量(class invariant)的存在，所以就有一个很重要的规则:<strong>如果一个类c有任何用户提供的构造函数，那么类c就不再是聚合的，并且不支持聚合初始化。</strong></p>
</li>
<li><p>(cpp03)聚合类的定义:1.没有用户提供的构造函数，没有私有或者保护的非静态数据成员，没有基类，没有虚函数。</p>
</li>
<li><p>(cpp03-cpp20)聚合类的定义：没有用户定义的构造函数或者继承的构造函数u，没有私有或保护的direct non-static data members，没有虚的、私有、保护继承的基类，没有虚函数。</p>
</li>
<li><p>vacuous initialization:<code>int x;// initializationed</code>虽然you生命了，但是没有初始化。。</p>
</li>
<li><p>value-initialization: <code>demo_str* pds = new demo_str();</code>这就是值初始化。值初始化取决于type T,如果是用户定义的类，那么就会调用默认构造函数，如果T是数组，那么就会值初始化他的所有元素，如果是简单的scalar，就会零初始化。不然的话，除了上面的情况，值初始化只在没有用户提供的构造函数的场景才有效，对于每一个数据成员T，会调用他的零初始化，然后默认初始化。</p>
</li>
<li><p>Roundabout Value-Initialization:在cpp17之前<code>C c = C();</code>如果C没有拷贝构造函数，这个value-initializaiton会失败。</p>
</li>
<li><p>cpp03的一些问题：1.没有统一的初始化，这就导致在模板函数的编写时可能有问题，第二个问题是可能存在的窄型转换。第三个问题是值初始化很困难：</p>
</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525113524233.png" alt="image-20240525113524233"></p>
<ul>
<li>==brace-inialization: modern cpp的所有类型都支持{}初始化==</li>
<li>copy-list-initialization的例子,但是如果我们定义了一个接受std::initializaer_list的构造函数，那么就没有下面的问题了:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525114128214.png" alt="image-20240525114128214"></p>
<ul>
<li>init_initialization的一些想法注意点:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240525114859895.png" alt="image-20240525114859895"></p>
<p>* </p>
<h1 id="Debuggin-in-Cpp-Greg-Law"><a href="#Debuggin-in-Cpp-Greg-Law" class="headerlink" title="Debuggin in Cpp - Greg Law"></a>Debuggin in Cpp - Greg Law</h1><ul>
<li>几种bug的主要形式：逻辑错误、指针错误、错误处理、条件竞争、接口假设（我们对接口的功能进行了错误的假设）。</li>
</ul>
<h2 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h2><ul>
<li>write down:一般遇到错误，是我们觉得这个错误是不可能出现的，这个时候可能我们复盘了很多次都觉得没有问题，<strong>我们可以尝试把它写下来。因为写的速度很慢，就能让我们花费更多的时间，更细心的去复盘一下。</strong></li>
<li>when you smell smoke,act. 当你意识到问题了，那就要往下一直查下去。</li>
<li>Lots and lots of assertions. 多加断言。</li>
<li>**write a test case, or panic.**这句话直接就是绝杀。</li>
<li></li>
</ul>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="C:\Users\14064\AppData\Roaming\Typora\typora-user-images\image-20240527084810027.png" alt="image-20240527084810027"></p>
<ul>
<li>LLDB的话一般苹果用的多。。</li>
<li>pstack也很好用。</li>
</ul>
<h1 id="Testing-in-C-Phil-Nash"><a href="#Testing-in-C-Phil-Nash" class="headerlink" title="Testing in C++ -Phil Nash"></a>Testing in C++ -Phil Nash</h1><p>什么是测试？<strong>说白了就是输入，然后操作，然后和期望的输出对比。</strong>：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528084030018.png" alt="image-20240528084030018"></p>
<p>上面的加粗的字就是最底层的测试的意思，假如说我们做了下面的操作，这也属于是测试：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528084153038.png" alt="image-20240528084153038"></p>
<p>当然编译器也可以是的。。我们用编译器，输入了我们的代码，然后期望编译没有问题。。</p>
<ul>
<li>有三类测试最重要：单元测试、集成测试、系统测试。</li>
</ul>
<p>满足以下条件的不属于单元测试:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528084422804.png" alt="image-20240528084422804"></p>
<ul>
<li>单元测试的最佳实践:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528090806229.png" alt="image-20240528090806229"></p>
<ul>
<li>测试的最佳实践:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240528091157873.png" alt="image-20240528091157873"></p>
<ul>
<li>测试常见的陷阱和挑战：Flakey tests、Slow tests、Brittle tests、Hard to write.</li>
</ul>
<h1 id="Iterators-in-C"><a href="#Iterators-in-C" class="headerlink" title="Iterators in C++"></a>Iterators in C++</h1><ul>
<li>cpp20新增了一个连续迭代器:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530083320028.png" alt="image-20240530083320028"></p>
<ul>
<li>STL的组合:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530083653577.png" alt="image-20240530083653577"></p>
<ul>
<li>iter 的陷阱：1.迭代器可能会失效（eg: push_back后，或者erase后。。）</li>
<li>使用inserters:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530084239568.png" alt="image-20240530084239568"></p>
<ul>
<li>Filter View的UB:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530085125485.png" alt="image-20240530085125485"></p>
<ul>
<li>下面是另外一个例子:</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240530085222404.png" alt="image-20240530085222404"></p>
<h1 id="Expert’s-advice"><a href="#Expert’s-advice" class="headerlink" title="Expert’s advice"></a>Expert’s advice</h1><p>“ifyou want to improve code quality in your organization, I would say, take all your coding guidelines and replace them with the one goal. . No Raw Loops. This will make the biggest change in code quality within your organization.(Sean Parent, C++ Seasoning, Going Native 2013)</p>
<ul>
<li>并发的定义：“Multiple logical threads of execution with unknown inter-task dependencies Daisy Hollman, “A Unifying Abstraction for Async,” CppCon 2019</li>
<li>并行的定义：Multiple logical threads of execution with no inter-task dependencies<br>Daisy Hollman, “A Unifying Abstraction for Async,” CppCon 2019</li>
</ul>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="ITM-Initialize-Then-Modify"><a href="#ITM-Initialize-Then-Modify" class="headerlink" title="ITM: (Initialize Then Modify)"></a>ITM: (Initialize Then Modify)</h2><p>下面的age就是这个例子:</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/image-20240524084429836.png" alt="image-20240524084429836"></p>
<h2 id="most-vexing-parse"><a href="#most-vexing-parse" class="headerlink" title="most vexing parse"></a>most vexing parse</h2><p>C++中的”Most Vexing Parse”（最令人烦恼的解析问题）是一种特殊的语法解析现象，它源于C++编译器在解析源代码时的一种歧义性。这个问题通常发生在尝试声明一个对象并初始化它时，但编译器却错误地将其解析为函数声明的情况。这种解析歧义通常会让程序员感到困惑，因为它并不直观，并且可能导致难以察觉的错误:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj();  // 这可能被解析为一个函数声明，而不是对象实例化</span><br></pre></td></tr></tbody></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">寻宝游戏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/">http://example.com/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">寻宝游戏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post_share"><div class="social-share" data-image="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/30/%E5%B0%8F%E5%BD%AD%E8%80%81%E5%B8%88%E7%BD%91%E8%AF%BE/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/05/06/c++core%20guidelines%E7%AC%94%E8%AE%B0/" title="C++Core Guidelines笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++Core Guidelines笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/06/c++core%20guidelines%E7%AC%94%E8%AE%B0/" title="C++Core Guidelines笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-06</div><div class="title">C++Core Guidelines笔记</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">寻宝游戏</div><div class="author-info__description">思维的乐趣。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/enternityFan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Do your own thing...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STL105"><span class="toc-number">1.</span> <span class="toc-text">STL105</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BA%86%E8%A7%A3STL105%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%9F%E8%BF%98%E8%A6%81%E5%BE%88%E5%A5%BD%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">为什么要了解STL105个算法？还要很好的了解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heaps"><span class="toc-number">1.2.</span> <span class="toc-text">heaps</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sorting"><span class="toc-number">1.3.</span> <span class="toc-text">sorting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partitioning"><span class="toc-number">1.4.</span> <span class="toc-text">partitioning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#query"><span class="toc-number">1.5.</span> <span class="toc-text">query</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Templates-in-C-Nicolai-Josuttis-cppcon2022"><span class="toc-number">2.</span> <span class="toc-text">Templates in C++ Nicolai Josuttis (cppcon2022)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Back-To-Basics-Standard-Library-Containers-RAINER-GRIMM"><span class="toc-number">3.</span> <span class="toc-text">Back To Basics Standard Library Containers RAINER GRIMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Container%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.</span> <span class="toc-text">Container的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">3.1.1.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#size"><span class="toc-number">3.1.3.</span> <span class="toc-text">size</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assignment-and-swap"><span class="toc-number">3.1.4.</span> <span class="toc-text">Assignment and swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparison"><span class="toc-number">3.1.5.</span> <span class="toc-text">Comparison</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.1.6.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sequence-Containers"><span class="toc-number">3.2.</span> <span class="toc-text">Sequence Containers</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object-Oriented-Programming-Amir-Kirsh"><span class="toc-number">4.</span> <span class="toc-text">Object Oriented Programming Amir Kirsh</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Master-C-Value-Categories-With-Standard-Tools-Inbal-Levi"><span class="toc-number">5.</span> <span class="toc-text">Master C++ Value Categories With Standard Tools - Inbal Levi</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Motivation"><span class="toc-number">5.1.</span> <span class="toc-text">Motivation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tools-for-handling-value-categories"><span class="toc-number">5.2.</span> <span class="toc-text">Tools for handling value categories</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Declarations-in-C-BenSaks"><span class="toc-number">6.</span> <span class="toc-text">Declarations in C++ BenSaks</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cpp-Value-Semantics-Klaus-lglberger"><span class="toc-number">7.</span> <span class="toc-text">Cpp Value Semantics - Klaus lglberger</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-API-Design-Jason-Turner"><span class="toc-number">8.</span> <span class="toc-text">C++ API Design Jason Turner</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RAII-in-Cpp-Andre-Kostur"><span class="toc-number">9.</span> <span class="toc-text">RAII in Cpp Andre Kostur</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Smart-Pointers-David-Olsen"><span class="toc-number">10.</span> <span class="toc-text">Smart Pointers David Olsen</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Testing-Amir-Kirsh"><span class="toc-number">11.</span> <span class="toc-text">Testing - Amir Kirsh</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Debugging-in-C-Mike-Shah"><span class="toc-number">12.</span> <span class="toc-text">Debugging in C++ Mike Shah</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Move-Semantics-Andreas-Fertig"><span class="toc-number">13.</span> <span class="toc-text">Move Semantics - Andreas Fertig</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Memory-Model-from-C-11-to-C-23"><span class="toc-number">14.</span> <span class="toc-text">Memory Model from C++11 to C++23</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Barrier"><span class="toc-number">14.1.</span> <span class="toc-text">Memory Barrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E5%B9%B6%E5%8F%91"><span class="toc-number">14.2.</span> <span class="toc-text">c++并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8A%E7%9A%84%E8%A7%86%E9%A2%91%E5%A4%A7%E9%83%BD%E6%98%AFcppcon2022%E7%9A%84back-to-basics-%E4%BB%A5%E4%B8%8B%E6%98%AF2023%E7%9A%84"><span class="toc-number">15.</span> <span class="toc-text">以上的视频大都是cppcon2022的back to basics 以下是2023的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Range-Algorithms-in-C-Klaus-lglberger"><span class="toc-number">16.</span> <span class="toc-text">(Range) Algorithms in C++ Klaus lglberger</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-Concurrency-David-Olsen"><span class="toc-number">17.</span> <span class="toc-text">C++ Concurrency - David Olsen</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Back-to-Basics-Functions-in-C-Mike-Shah"><span class="toc-number">18.</span> <span class="toc-text">Back to Basics- Functions in C++ Mike Shah</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Initialization-in-C-Ben-Saks"><span class="toc-number">19.</span> <span class="toc-text">Initialization in C++ Ben Saks</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Debuggin-in-Cpp-Greg-Law"><span class="toc-number">20.</span> <span class="toc-text">Debuggin in Cpp - Greg Law</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#advise"><span class="toc-number">20.1.</span> <span class="toc-text">advise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tools"><span class="toc-number">20.2.</span> <span class="toc-text">Tools</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Testing-in-C-Phil-Nash"><span class="toc-number">21.</span> <span class="toc-text">Testing in C++ -Phil Nash</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Iterators-in-C"><span class="toc-number">22.</span> <span class="toc-text">Iterators in C++</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Expert%E2%80%99s-advice"><span class="toc-number">23.</span> <span class="toc-text">Expert’s advice</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">24.</span> <span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ITM-Initialize-Then-Modify"><span class="toc-number">24.1.</span> <span class="toc-text">ITM: (Initialize Then Modify)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#most-vexing-parse"><span class="toc-number">24.2.</span> <span class="toc-text">most vexing parse</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/05/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/" title="活着读后感">活着读后感</a><time datetime="2025-04-05T07:39:27.443Z" title="发表于 2025-04-05 15:39:27">2025-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/16/%E9%9D%A2%E8%AF%95%E8%A3%85%E9%80%BC%E6%8C%87%E5%8D%97/" title="无题">无题</a><time datetime="2024-06-16T08:55:44.994Z" title="发表于 2024-06-16 16:55:44">2024-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/16/%E7%8E%B0%E4%BB%A3C++%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2024-06-16T07:09:09.546Z" title="发表于 2024-06-16 15:09:09">2024-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" title="左程云算法复习">左程云算法复习</a><time datetime="2024-06-03T12:13:48.000Z" title="发表于 2024-06-03 20:13:48">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="左程云经典面试题">左程云经典面试题</a><time datetime="2024-06-03T12:13:48.000Z" title="发表于 2024-06-03 20:13:48">2024-06-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2020 - 2025 By 寻宝游戏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      id: 'edf343058317a47ed3c4d382e56b0b2e',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/'
    this.page.identifier = '/2024/05/08/concpp%E8%A7%86%E9%A2%91%E8%A7%82%E7%9C%8B%E8%AE%B0%E5%BD%95/'
    this.page.title = 'cppcon视频观看笔记'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Gitalk' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="8507814393" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: true,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>