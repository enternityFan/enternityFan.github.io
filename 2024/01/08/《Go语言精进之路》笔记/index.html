<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《Go语言精进之路》笔记 | 寻宝游戏</title><meta name="author" content="寻宝游戏"><meta name="copyright" content="寻宝游戏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2.1 Go语言的先祖Go的基本语法参考了C语言，Go是“C家族语言”的一个分支；而Go的声明语法、包概念则受到了Pascal、Modula、Oberon的启发；一些并发的思想则来自受到Tony Hoare教授CSP理论[1]影响的编程语言，比如Newsqueak和Limbo。 第3条 Go语言设计哲学 ==追求简单，少即是多==：Go设计者推崇“最小方式”思维，即一件事情仅有一种方式或数量尽可能">
<meta property="og:type" content="article">
<meta property="og:title" content="《Go语言精进之路》笔记">
<meta property="og:url" content="http://example.com/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="寻宝游戏">
<meta property="og:description" content="2.1 Go语言的先祖Go的基本语法参考了C语言，Go是“C家族语言”的一个分支；而Go的声明语法、包概念则受到了Pascal、Modula、Oberon的启发；一些并发的思想则来自受到Tony Hoare教授CSP理论[1]影响的编程语言，比如Newsqueak和Limbo。 第3条 Go语言设计哲学 ==追求简单，少即是多==：Go设计者推崇“最小方式”思维，即一件事情仅有一种方式或数量尽可能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg">
<meta property="article:published_time" content="2024-01-08T12:13:48.000Z">
<meta property="article:modified_time" content="2025-04-06T03:14:25.125Z">
<meta property="article:author" content="寻宝游戏">
<meta property="article:tag" content="GoLang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="shortcut icon" href="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg"><link rel="canonical" href="http://example.com/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《Go语言精进之路》笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-06 11:14:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="寻宝游戏"><span class="site-name">寻宝游戏</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/thought/"><i class="fa-fw fa fa-comments-o"></i><span> 杂思</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fa fa-book"></i><span> 读书笔记</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《Go语言精进之路》笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-08T12:13:48.000Z" title="发表于 2024-01-08 20:13:48">2024-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-06T03:14:25.125Z" title="更新于 2025-04-06 11:14:25">2025-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">技术书籍读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《Go语言精进之路》笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="2-1-Go语言的先祖"><a href="#2-1-Go语言的先祖" class="headerlink" title="2.1 Go语言的先祖"></a>2.1 Go语言的先祖</h4><p>Go的基本语法参考了C语言，Go是“C家族语言”的一个分支；而Go的声明语法、包概念则受到了Pascal、Modula、Oberon的启发；一些并发的思想则来自受到Tony Hoare教授CSP理论[1]影响的编程语言，比如Newsqueak和Limbo。</p>
<h1 id="第3条-Go语言设计哲学"><a href="#第3条-Go语言设计哲学" class="headerlink" title="第3条 Go语言设计哲学"></a>第3条 Go语言设计哲学</h1><ul>
<li>==追求简单，少即是多==：Go设计者推崇“最小方式”思维，即一件事情仅有一种方式或数量尽可能少的方式去完成，这大大减少了开发人员在选择路径方式及理解他人所选路径方式上的心智负担。</li>
<li>==偏好组合，正交解耦==：在通过新类型实例调用方法时，方法的匹配取决于方法名字，而不是类型。这种组合方式，笔者称之为“垂直组合”，即通过类型嵌入，快速让一个新类型复用其他类型已经实现的能力，实现功能的垂直扩展。通过interface将程序各个部分组合在一起的方法，笔者称之为“水平组合”。</li>
<li>==原生并发，轻量高效==：Go语言采用轻量级协程并发模型，使得Go应用在面向多核硬件时更具可扩展性，goroutine占用的资源非常少，Go运行时默认为每个goroutine分配的栈空间仅2KB。goroutine调度的切换也不用陷入（trap）操作系统内核层完成，代价很低。一个Go程序对于操作系统来说只是一个用户层程序。操作系统的眼中只有线程，它甚至不知道goroutine的存在。goroutine的调度全靠Go自己完成，实现Go程序内goroutine之间公平地竞争CPU资源的任务就落到了Go运行时头上。而将这些goroutine按照一定算法放到CPU上执行的程序就称为goroutine调度器（goroutine scheduler）。并发程序的结构设计不要局限于在单核情况下处理能力的高低，而要以在多核情况下充分提升多核利用率、获得性能的自然提升为最终目的。</li>
<li>==面向工程，“自带电池“==，自带电池，主要是指Go的标准库非常的丰富：<ul>
<li>构建和运行：go build/go run</li>
<li>依赖包查看与获取：go list/go get/go mod xx</li>
<li>编辑辅助格式化：go fmt/gofmt</li>
<li>文档查看：go doc/godoc</li>
<li>单元测试/基准测试/测试覆盖率：go test</li>
<li>代码静态分析：go vet</li>
<li>性能剖析与跟踪结果查看：go tool pprof/go tool trace</li>
<li>升级到新Go版本API的辅助工具：go tool fix</li>
<li>报告Go语言bug：go bug</li>
</ul>
</li>
<li>简单是Go语言贯穿语言设计和应用的主旨设计哲学。“高内聚、低耦合”是软件开发领域亘古不变的管理复杂性的准则。</li>
</ul>
<h1 id="第4条-使用Go语言原生编程思维来写Go代码"><a href="#第4条-使用Go语言原生编程思维来写Go代码" class="headerlink" title="第4条　使用Go语言原生编程思维来写Go代码"></a>第4条　使用Go语言原生编程思维来写Go代码</h1><ul>
<li>C语言相信程序员，提供了指针和指针运算，让C程序员天马行空地发挥，接近底层的直接内存操作让C程序拥有很高的性能；C++支持多范式（命令式、OO和泛型），虽不强迫程序员使用某个特定的范式，但推荐使用最新代表现代语言发展特色的泛型等高级范式；Python语言更是形成了Pythonic规则来指导Python程序员写出符合Python思维或惯用法的代码。</li>
</ul>
<h1 id="第5条-使用得到公认且广泛使用的项目结构"><a href="#第5条-使用得到公认且广泛使用的项目结构" class="headerlink" title="第5条　使用得到公认且广泛使用的项目结构"></a>第5条　使用得到公认且广泛使用的项目结构</h1><p>1）代码构建的脚本源文件放在src下面的顶层目录下。</p>
<p>2）src下的二级目录cmd下面存放着Go工具链相关的可执行文件（比如go、gofmt等）的主目录以及它们的main包源文件。</p>
<p>3）src下的二级目录pkg下面存放着上面cmd下各工具链程序依赖的包、Go运行时以及Go标准库的源文件。</p>
<h1 id="第6条-提交前使用gofmt格式化源码"><a href="#第6条-提交前使用gofmt格式化源码" class="headerlink" title="第6条　提交前使用gofmt格式化源码"></a>第6条　提交前使用gofmt格式化源码</h1><ol>
<li><p>使用gofmt -s选项简化代码</p>
</li>
<li><p>使用gofmt -r执行代码“微重构”</p>
</li>
</ol>
<p>下面是-r选项的用法：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gofmt -r 'pattern -&gt; replacement' [other flags] [path ...]</span><br><span class="line">$gofmt -r 'a[3:len(a)] -&gt; a[3:]' -w chapter2/sources/gofmt_demo.go</span><br><span class="line">//上面gofmt -r命令执行的意图就是先将源码文件gofmt_demo.go中能与a[3:len(a)]匹配的代码替换为a[3:]，然后重新格式化。</span><br></pre></td></tr></tbody></table></figure>



<p>使用gofmt -l按格式要求输出满足条件的文件列表。</p>
<h3 id="第7条-使用Go命名惯例对标识符进行命名"><a href="#第7条-使用Go命名惯例对标识符进行命名" class="headerlink" title="第7条 使用Go命名惯例对标识符进行命名"></a>第7条 使用Go命名惯例对标识符进行命名</h3><ul>
<li>计算机科学中只有两件难事：缓存失效和命名。一个好笑话，如果你必须解释它，那就不好笑了。好的命名也类似。要想做好Go标识符的命名（包括对包的命名），至少要遵循两个原则：<strong>简单且一致；利用上下文辅助命名。</strong></li>
<li>对于Go中的包（package），一般建议以小写形式的单个单词命名。</li>
<li>包名应尽量与包导入路径（import path）的最后一个路径分段保持一致。</li>
<li><strong>Go语言官方要求标识符命名采用驼峰命名法</strong>（CamelCase），以变量名为例，如果变量名由一个以上的词组合构成，那么这些词之间紧密相连，不使用任何连接符（如下划线）。驼峰命名法有两种形式：一种是第一个词的首字母小写，后面每个词的首字母大写，叫作“小骆峰拼写法”（lowerCamelCase），这也是在Go中最常见的标识符命名法；而第一个词的首字母以及后面每个词的首字母都大写，叫作“大驼峰拼写法”（UpperCamelCase），又称“帕斯卡拼写法”（PascalCase）。由于首字母大写的标识符在Go语言中被视作包导出标识符，因此<strong>只有在涉及包导出的情况下才会用到大驼峰拼写法</strong>。不过如果缩略词的首字母是大写的，那么其他字母也要保持全部大写，比如HTTP（Hypertext Transfer Protocol）、CBC（Cipher Block Chaining）等。</li>
<li>带有类型信息的命名只是让变量看起来更长，并没有给开发者阅读代码带来任何好处。</li>
<li>保持变量声明与使用之间的距离越近越好，或者在第一次使用变量之前声明该变量。</li>
<li>在Go语言中，对于接口类型优先以单个单词命名。<strong>对于拥有唯一方法（method）或通过多个拥有唯一方法的接口组合而成的接口，Go语言的惯例是用“方法名+er”命名</strong>。</li>
</ul>
<h3 id="第8条-使用一致的变量声明形式"><a href="#第8条-使用一致的变量声明形式" class="headerlink" title="第8条 使用一致的变量声明形式"></a>第8条 使用一致的变量声明形式</h3><ul>
<li><p>Go语言沿袭了静态编译型语言的传统：使用变量之前需要先进行变量的声明</p>
</li>
<li><p>Go语言有两类变量。包级变量（package variable）：在package级别可见的变量。如果是导出变量，则该包级变量也可以被视为全局变量。局部变量（local variable）：函数或方法体内声明的变量，仅在函数或方法体内可见。</p>
</li>
</ul>
<h4 id="8-1-包级变量的声明形式"><a href="#8-1-包级变量的声明形式" class="headerlink" title="8.1 包级变量的声明形式"></a>8.1 包级变量的声明形式</h4><ul>
<li><p>我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中；或者将延迟初始化的变量声明放在一个var块，而将声明并显式初始化的变量放在另一个var块中。笔者称之为“声明聚类”</p>
</li>
<li><p>变量声明最佳实践中还有一条：<strong>就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。</strong>就近原则实际上是变量的作用域最小化的一种实现手段。</p>
</li>
</ul>
<h4 id="8-2-局部变量的声明形式"><a href="#8-2-局部变量的声明形式" class="headerlink" title="8.2 局部变量的声明形式"></a>8.2 局部变量的声明形式</h4><ol>
<li><p>对于延迟初始化的局部变量声明，采用带有var关键字的声明形式</p>
</li>
<li><p>对于声明且显式初始化的局部变量，建议使用短变量声明形式</p>
</li>
<li><p>尽量在分支控制时应用短变量声明形式</p>
</li>
</ol>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_21" alt="img"></p>
<h1 id="第9条-使用无类型常量简化代码"><a href="#第9条-使用无类型常量简化代码" class="headerlink" title="第9条　使用无类型常量简化代码"></a>第9条　使用无类型常量简化代码</h1><ul>
<li>Go语言中的const整合了C语言中宏定义常量、const只读变量和枚举常量三种形式，并消除了每种形式的不足，使得Go常量成为类型安全且对编译器优化友好的语法元素。</li>
<li>有类型常量带来的烦恼：Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算，Go在处理不同类型的变量间的运算时不支持隐式的类型转换。Go的设计者认为，隐式转换带来的便利性不足以抵消其带来的诸多问题</li>
<li>Go的无类型常量恰恰就拥有像字面值这样的特性，该特性使得无类型常量在参与变量赋值和计算过程时无须显式类型转换，从而达到简化代码的目的</li>
<li>无类型常量是Go语言推荐的实践，它拥有和字面值一样的灵活特性，可以直接用于更多的表达式而不需要进行显式类型转换，从而简化了代码编写。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a  = <span class="number">5</span></span><br><span class="line">    pi = <span class="number">3.1415926</span></span><br><span class="line">    s  = <span class="string">"Hello, Gopher"</span></span><br><span class="line">    c  = <span class="string">'a'</span></span><br><span class="line">    b  = <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<h3 id="第10条-使用iota实现枚举常量"><a href="#第10条-使用iota实现枚举常量" class="headerlink" title="第10条 使用iota实现枚举常量"></a>第10条 使用iota实现枚举常量</h3><p>Go的const语法提供了“隐式重复前一个非空表达式”的机制</p>
<h1 id="第11条-尽量定义零值可用的类型"><a href="#第11条-尽量定义零值可用的类型" class="headerlink" title="第11条　尽量定义零值可用的类型"></a>第11条　尽量定义零值可用的类型</h1><ul>
<li><p>当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，<strong>Go会为变量或值提供默认值</strong>。</p>
</li>
<li><p>Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）:</p>
<ul>
<li>所有整型类型：0</li>
<li>浮点类型：0.0</li>
<li>布尔类型：false</li>
<li>字符串类型：””</li>
<li>指针、interface、切片（slice）、channel、map、function：nil</li>
</ul>
</li>
<li><p>Go的零值初始是递归的，<strong>即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</strong></p>
</li>
</ul>
<h4 id="11-2-零值可用"><a href="#11-2-零值可用" class="headerlink" title="11.2 零值可用"></a>11.2 零值可用</h4><p>==两个例子：1.零值的切片可以直接append；2.零值仍可以调用自身的方法；==</p>
<p><strong>零值可用的类型要注意尽量避免值复制</strong></p>
<h1 id="第12条-使用复合字面值作为初值构造器"><a href="#第12条-使用复合字面值作为初值构造器" class="headerlink" title="第12条 使用复合字面值作为初值构造器"></a>第12条 使用复合字面值作为初值构造器</h1><p>复合字面值由两部分组成：一部分是类型，比如上述示例代码中赋值操作符右侧的myStruct、[5]int、[]int和map[int]string；另一部分是由大括号{}包裹的字面值。</p>
<ul>
<li><p>结构体复合字面值:Go推荐使用field:value的复合字面值形式对struct类型变量进行值构造，这种值构造方式可以降低结构体类型使用者与结构体类型设计者之间的耦合，这也是Go语言的惯用法。</p>
</li>
<li><p>数组/切片复合字面值：数组/切片由于其固有的特性，采用index:value为其构造初值，主要应用在少数场合，比如为非连续（稀疏）元素构造初值</p>
</li>
<li><p>map复合字面值:对于数组/切片类型而言，当元素为复合类型时，可以省去元素复合字面量中的类型。</p>
</li>
</ul>
<p>总结：对于不同复合类型，我们要记住下面几点：使用field:value形式的复合字面值为结构体类型的变量赋初值；在为稀疏元素赋值或让编译器推导数组大小的时候，多使用index:value的形式为数组/切片类型变量赋初值；使用key:value形式的复合字面值为map类型的变量赋初值。（Go 1.5版本后，复合字面值中的key和value类型均可以省略不写。）</p>
<h1 id="第13条-了解切片实现原理并高效使用"><a href="#第13条-了解切片实现原理并高效使用" class="headerlink" title="第13条 了解切片实现原理并高效使用"></a>第13条 了解切片实现原理并高效使用</h1><ul>
<li><strong>在Go语言中传递数组是纯粹的值拷贝</strong>，对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗。<strong>切片之于数组就像是文件描述符之于文件。</strong>在Go语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色；而切片则走向“前台”，为底层的存储（数组）打开了一个访问的“窗口”。</li>
<li>我们可以称切片是数组的“描述符”</li>
<li>我们可以通过语法u[low: high]创建对已存在数组进行操作的切片，这被称为数组的切片化（slicing）：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u := [10]byte{11, 12, 13, 14, 15, 16, 17, 18, 19, 20}</span><br><span class="line">s := u[3:7]</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>**切片的高级特性,动态扩容:**新数组建立后，append会把旧数组中的数据复制到新数组中，之后新数组便成为切片的底层数组，旧数组后续会被垃圾回收掉。</li>
</ul>
<h1 id="第14条-了解map实现原理并高效使用"><a href="#第14条-了解map实现原理并高效使用" class="headerlink" title="第14条　了解map实现原理并高效使用"></a>第14条　了解map实现原理并高效使用</h1><ul>
<li>map对value的类型没有限制，但是对key的类型有严格要求：<strong>key的类型应该严格定义了作为“==”和“!=”两个操作符的操作数时的行为</strong>，因此函数、map、切片不能作为map的key类型。</li>
<li><strong>map类型不支持“零值可用”</strong>，未显式赋初值的map类型变量的零值为nil。对处于零值状态的map变量进行操作将会导致运行时panic,必须对map类型变量进行显式初始化后才能使用它。</li>
<li><strong>和切片一样，map也是引用类型，将map类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对map变量的修改在函数外部也是可见的。</strong></li>
<li>Go语言的一个最佳实践是总是使用“comma ok”惯用法读取map中的值。</li>
<li>即便要删除的数据在map中不存在，delete也不会导致panic。这是因为Go运行时在初始化map迭代器时对起始位置做了随机处理。</li>
<li>千万不要依赖遍历map所得到的元素次序。因为map的遍历是乱序的，可以通过向数组中存放key的方式然后遍历数组来得到有序的遍历结果。</li>
<li>1.9版本中引入了支持并发写安全的sync.Map类型，可以用来在并发读写的场景下替换掉map。</li>
<li>考虑到map可以自动扩容，map中数据元素的value位置可能在这一过程中发生变化，因此Go不允许获取map中value的地址</li>
</ul>
<p><strong>小结：</strong>不要依赖map的元素遍历顺序；map不是线程安全的，不支持并发写；不要尝试获取map中元素（value）的地址；尽量使用cap参数创建map，以提升map平均访问性能，减少频繁扩容带来的不必要损耗。</p>
<h1 id="第15条-了解string实现原理并高效使用"><a href="#第15条-了解string实现原理并高效使用" class="headerlink" title="第15条　了解string实现原理并高效使用"></a>第15条　了解string实现原理并高效使用</h1><ul>
<li><p><strong>（1）string类型的数据是不可变的：一旦声明了一个string类型的标识符，无论是常量还是变量，该标识符所指代的数据在整个程序的生命周期内便无法更改。</strong></p>
</li>
<li><p><strong>（2）零值可用：Go string类型支持“零值可用”的理念。Go字符串无须像C语言中那样考虑结尾’\0’字符，因此其零值为””，长度为0。</strong></p>
</li>
<li><p><strong>（3）获取长度的时间复杂度是O(1)级别。</strong></p>
</li>
<li><p><strong>（4）支持通过+/+=操作符进行字符串连接。</strong></p>
</li>
<li><p><strong>（5）支持各种比较关系操作符：==、!= 、&gt;=、&lt;=、&gt;和&lt;。</strong>如果长度相同，则要进一步判断数据指针是否指向同一块底层存储数据。如果相同，则两个字符串是等价的；如果不同，则还需进一步比对实际的数据内容。</p>
</li>
<li><p><strong>（6）对非ASCII字符提供原生支持。</strong></p>
</li>
<li><p><strong>（7）原生支持多行字符串。</strong>Go语言直接提供了通过反引号构造“所见即所得”的多行字符串的方法：</p>
</li>
</ul>
 <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// chapter3/sources/string_multilines.go</span><br><span class="line"></span><br><span class="line">const s = `好雨知时节，当春乃发生。</span><br><span class="line">随风潜入夜，润物细无声。</span><br><span class="line">野径云俱黑，江船火独明。</span><br><span class="line">晓看红湿处，花重锦官城。`</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">$go run string_multilines.go</span><br><span class="line">好雨知时节，当春乃发生。</span><br><span class="line">随风潜入夜，润物细无声。</span><br><span class="line">野径云俱黑，江船火独明。</span><br><span class="line">晓看红湿处，花重锦官城。</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>直接将string类型通过函数/方法参数传入也不会有太多的损耗，因为传入的仅仅是一个“描述符”，而不是真正的字符串数据。</li>
<li>字符串相关的高效转换:无论是string转slice还是slice转string，转换都是要付出代价的，这些代价的根源在于string是不可变的，运行时要为转换后的类型分配新内存.</li>
<li>Go编译器对用在for-range循环中的string到[]byte的转换也有优化处理，它不会为[]byte进行额外的内存分配，而是直接使用string的底层数据。</li>
</ul>
<h1 id="第16条-理解Go语言的包导入"><a href="#第16条-理解Go语言的包导入" class="headerlink" title="第16条　理解Go语言的包导入"></a>第16条　理解Go语言的包导入</h1><ul>
<li>Go程序的构建简单来讲也是由编译（compile）和链接（link）两个阶段组成的。</li>
<li>在使用第三方包的时候，在第三方包源码存在且对应的.a已安装的情况下，编译器链接的仍是根据第三方包最新源码编译出的.a文件，而不是之前已经安装到$GOPATH/pkg/darwin_amd64下的目标文件。</li>
<li>所谓的使用第三方包源码，实际上是链接了以该最新包源码编译的、存放在临时目录下的包的.a文件而已。</li>
<li>源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段也不是包名。</li>
<li>包导入路径的最后一段目录名最好与包名一致,当包名与包导入路径中的最后一个目录名不同时，最好用下面的语法将包名显式放入包导入语句</li>
</ul>
<h1 id="第17条-理解Go语言表达式的求值顺序"><a href="#第17条-理解Go语言表达式的求值顺序" class="headerlink" title="第17条 理解Go语言表达式的求值顺序"></a>第17条 理解Go语言表达式的求值顺序</h1><ul>
<li><p>支持在同一行声明和初始化多个变量（不同类型也可以）</p>
</li>
<li><p>在Go包中，<strong>包级别变量的初始化按照变量声明的先后顺序进行</strong>。</p>
</li>
<li><p>未初始化的且不含有对应初始化表达式或初始化表达式不依赖任何未初始化变量的变量，我们称之为“ready for initialization”变量。包级别变量的初始化是逐步进行的，每一步就是按照变量声明顺序找到下一个“ready for initialization”变量并对其进行初始化的过程。反复重复这一步骤，直到没有“ready for initialization”变量为止。</p>
</li>
<li><p>当多个变量在声明语句左侧且右侧为单一表达式时的表达式求值情况。在这种情况下，无论左侧哪个变量被初始化，同一行的其他变量也会被一并初始化。</p>
</li>
<li><p><strong>switch-case语句中的表达式求值，这类求值属于“惰性求值”范畴。</strong>惰性求值指的就是需要进行求值时才会对表达值进行求值，这样做的目的是让计算机少做事，从而降低程序的消耗，对性能提升有一定帮助。</p>
</li>
</ul>
<p><strong>小结：</strong>包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高。表达式操作数中的函数、方法及channel操作按普通求值顺序，即从左到右的次序进行求值。赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按从左到右的顺序对变量进行赋值。重点关注switch-case和select-case语句中的表达式“惰性求值”规则。</p>
<h1 id="第18条-理解Go语言代码块与作用域"><a href="#第18条-理解Go语言代码块与作用域" class="headerlink" title="第18条　理解Go语言代码块与作用域"></a>第18条　理解Go语言代码块与作用域</h1><h4 id="18-1-Go代码块与作用域简介"><a href="#18-1-Go代码块与作用域简介" class="headerlink" title="18.1 Go代码块与作用域简介"></a>18.1 Go代码块与作用域简介</h4><ul>
<li>代码块是代码执行流流转的基本单元，代码执行流总是从一个代码块跳到另一个代码块。</li>
<li><strong>Go规范定义了如下几种隐式代码块</strong>。<strong>宇宙（Universe）代码块</strong>：所有Go源码都在该隐式代码块中，就相当于所有Go代码的最外层都存在一对大括号。<strong>包代码块</strong>：每个包都有一个包代码块，其中放置着该包的所有Go源码。<strong>文件代码块</strong>：每个文件都有一个文件代码块，其中包含着该文件中的所有Go源码。</li>
<li>每个if、for和switch语句均被视为位于其自己的隐式代码块中；switch或select语句中的每个子句都被视为一个隐式代码块。</li>
</ul>
<h1 id="第19条-了解Go语言控制语句惯用法及使用注意事项"><a href="#第19条-了解Go语言控制语句惯用法及使用注意事项" class="headerlink" title="第19条　了解Go语言控制语句惯用法及使用注意事项"></a>第19条　了解Go语言控制语句惯用法及使用注意事项</h1><ul>
<li>使用if控制语句时应遵循“快乐路径”原则，所谓“快乐路径”即成功逻辑的代码执行路径，这个原则要求：当出现错误时，快速返回；成功逻辑不要嵌入if-else语句中；“快乐路径”的执行逻辑在代码布局上始终靠左，这样读者可以一眼看到该函数的正常逻辑流程；“快乐路径”的返回值一般在函数最后一行，就像上面伪代码段1中的那样。</li>
</ul>
<h4 id="19-2-for-range的避“坑”指南（重要）"><a href="#19-2-for-range的避“坑”指南（重要）" class="headerlink" title="19.2 for range的避“坑”指南（重要）"></a>19.2 for range的避“坑”指南（重要）</h4><ul>
<li><strong>参与循环的是range表达式的副本。</strong></li>
<li><strong>切片与数组还有一个不同点，就是其len在运行时可以被改变，而数组的长度可认为是一个常量，不可改变。</strong></li>
<li>range表达式的类型为切片或数组指针的性能相近，消耗都接近数组类型的1/2。</li>
<li><strong>对于range后面的其他表达式类型，比如string、map和channel，for range依旧会制作副本。</strong></li>
<li>如果在循环体中新创建一个map元素项，那么该项元素可能出现在后续循环中，也可能不出现：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// chapter3/sources/control_structure_idiom_4.go</span><br><span class="line">m["tony"] = 21</span><br><span class="line">counter = 0</span><br><span class="line"></span><br><span class="line">for k, v := range m {</span><br><span class="line">    if counter == 0 {</span><br><span class="line">        m["lucy"] = 24</span><br><span class="line">    }</span><br><span class="line">    counter++</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">}</span><br><span class="line">fmt.Println("counter is ", counter)</span><br><span class="line"></span><br><span class="line">//执行结果</span><br><span class="line">tony 21</span><br><span class="line">tom 22</span><br><span class="line">jim 23</span><br><span class="line">lucy 24</span><br><span class="line">counter is  4</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">tony 21</span><br><span class="line">tom 22</span><br><span class="line">jim 23</span><br><span class="line">counter is  3</span><br></pre></td></tr></tbody></table></figure>



<ul>
<li>当channel作为range表达式类型时，for range最终以阻塞读的方式阻塞在channel表达式上，即便是带缓冲的channel亦是如此：当channel中无数据时，for range也会阻塞在channel上，直到channel关闭</li>
<li>Go语言规范中明确规定break语句（不接label的情况下）结束执行并跳出的是同一函数内break语句所在的最内层的for、switch或select的执行。Go语言为for提供的一项高级能力：break [label]</li>
<li>尽量用case表达式列表替代fallthrough</li>
</ul>
<p><strong>小结：</strong>使用if语句时遵循“快乐路径”原则；小心for range的循环变量重用，明确真实参与循环的是range表达式的副本；明确break和continue执行后的真实“目的地”；使用fallthrough关键字前，考虑能否用更简洁、清晰的case表达式列表替代。</p>
<h1 id="第20条-在init函数中检查包级变量的初始状态"><a href="#第20条-在init函数中检查包级变量的初始状态" class="headerlink" title="第20条　在init函数中检查包级变量的初始状态"></a>第20条　在init函数中检查包级变量的初始状态</h1><ul>
<li>一个Go包可以拥有多个init函数，每个组成Go包的Go源文件中可以定义多个init函数。</li>
<li>一般来说，先被传递给Go编译器的源文件中的init函数先被执行，同一个源文件中的多个init函数按声明顺序依次执行。但Go语言的惯例告诉我们：不要依赖init函数的执行次序。</li>
<li><strong>init函数的执行顺位排在其所在包的包级变量之后。</strong></li>
<li>使用init函数检查包级变量的初始状态：1). 重置包级变量值。2).对包级变量进行初始化，保证其后续可用。3).init函数中的注册模式。</li>
<li><strong>空别名方式导入lib/pq的副作用就是Go运行时会将lib/pq作为main包的依赖包并会初始化pq包，于是pq包的init函数得以执行。</strong></li>
<li>一旦init函数在检查包数据初始状态时遇到失败或错误的情况（尽管极少出现），则说明对包的“质检”亮了红灯，如果让包“出厂”，那么只会导致更为严重的影响。因此，在这种情况下，快速失败是最佳选择。我们一般建议直接调用panic或者通过log.Fatal等函数记录异常日志，然后让程序快速退出。</li>
</ul>
<h3 id="第21条-让自己习惯于函数是“一等公民”"><a href="#第21条-让自己习惯于函数是“一等公民”" class="headerlink" title="第21条 让自己习惯于函数是“一等公民”"></a>第21条 让自己习惯于函数是“一等公民”</h3><p>Go语言的函数具有如下特点：以func关键字开头；支持多返回值；支持具名返回值；支持递归调用；支持同类型的可变参数；支持defer，实现函数优雅返回。</p>
<h4 id="21-1-什么是“一等公民”"><a href="#21-1-什么是“一等公民”" class="headerlink" title="21.1 什么是“一等公民”"></a>21.1 什么是“一等公民”</h4><p>如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值（value）一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”，Go中的函数可以像普通整型值那样被创建和使用。</p>
<h4 id="21-2-函数作为“一等公民”的特殊运用"><a href="#21-2-函数作为“一等公民”的特殊运用" class="headerlink" title="21.2 函数作为“一等公民”的特殊运用"></a>21.2 函数作为“一等公民”的特殊运用</h4><ol>
<li>像对整型变量那样对函数进行显式类型转换。函数也可以被显式类型转换，并且这样的类型转换在特定的领域具有奇妙的作用。最为典型的示例就是http.HandlerFunc这个类型。</li>
<li>函数式编程：<ol>
<li>柯里化是把接受多个参数的函数变换成接受一个单一参数（原函数的第一个参数）的函数，并返回接受余下的参数和返回结果的新函数的技术。</li>
<li>闭包是在函数内部定义的匿名函数，并且允许该匿名函数访问定义它的外部函数的作用域。</li>
<li>函子需要满足两个条件：函子本身是一个容器类型，以Go语言为例，这个容器可以是切片、map甚至channel；该容器类型需要实现一个方法，该方法接受一个函数类型参数，并在容器的每个元素上应用那个函数，得到一个新函子，原函子容器内部的元素值不受影响。</li>
</ol>
</li>
</ol>
<p><strong>小结：</strong>让自己习惯于函数是“一等公民”，请牢记本条要点：Go函数可以像变量值那样被赋值给变量、作为参数传递、作为返回值返回和在函数内部创建等；函数可以像变量那样被显式类型转换；基于函数特质，了解Go中的几种有用的函数式编程风格，如柯里化、函子等；不要为了符合特定风格而滥用函数特质。</p>
<h1 id="第22条-使用defer让函数更简洁、更健壮"><a href="#第22条-使用defer让函数更简洁、更健壮" class="headerlink" title="第22条　使用defer让函数更简洁、更健壮"></a>第22条　使用defer让函数更简洁、更健壮</h1><p>在Go中，只有在函数和方法内部才能使用defer；defer关键字后面只能接函数或方法，这些函数被称为deferred函数。defer将它们注册到其所在goroutine用于存放deferred函数的栈数据结构中，这些<strong>deferred函数将在执行defer的函数退出前被按后进先出（LIFO）的顺序调度执行。</strong></p>
<ul>
<li>defer的常见用法：<ul>
<li>拦截panic：deferred函数虽然可以拦截绝大部分的panic，但无法拦截并恢复一些运行时之外的致命问题。比如下面代码中通过C代码“制造”的崩溃，deferred函数便无能为力。</li>
<li>修改函数的具名返回值</li>
<li>输出调试信息</li>
<li>还原变量旧值</li>
</ul>
</li>
</ul>
<h4 id="22-3-关于defer的几个关键问题"><a href="#22-3-关于defer的几个关键问题" class="headerlink" title="22.3 关于defer的几个关键问题"></a>22.3 关于defer的几个关键问题</h4><ol>
<li>明确哪些函数可以作为deferred函数对于自定义的函数或方法，defer可以给予无条件的支持，但是<strong>对于有返回值的自定义函数或方法，返回值会在deferred函数被调度执行的时候被自动丢弃。</strong></li>
<li>append、cap、len、make、new等内置函数是不可以直接作为deferred函数的，而close、copy、delete、print、recover等可以。对于那些不能直接作为deferred函数的内置函数，我们可以使用一个包裹它的匿名函数来间接满足要求。以append为例：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">defer func() {</span><br><span class="line">    _ = append(sl, 11)</span><br><span class="line">}()</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>把握好defer关键字后表达式的求值时机,defer关键字后面的表达式是在将deferred函数注册到deferred函数栈的时候进行求值的</li>
<li>==从Go1.14开始，带来的性能负担不太多了。==</li>
</ol>
<h3 id="第23条-理解方法的本质以选择正确的receiver类型"><a href="#第23条-理解方法的本质以选择正确的receiver类型" class="headerlink" title="第23条 理解方法的本质以选择正确的receiver类型"></a>第23条 理解方法的本质以选择正确的receiver类型</h3><ul>
<li><p>和函数相比，Go语言中的方法在声明形式上仅仅多了一个参数，Go称之为receiver参数。receiver参数是方法与类型之间的纽带。</p>
</li>
<li><p>Go方法具有如下特点。</p>
<ul>
<li>1）方法名的首字母是否大写决定了该方法是不是导出方法。</li>
<li>2）方法定义要与类型定义放在同一个包内。由此我们可以推出：<strong>不能为原生类型（如int、float64、map等）添加方法，只能为自定义类型定义方法,不能横跨Go包为其他包内的自定义类型定义方法。</strong></li>
<li>3）每个方法只能有一个receiver参数，不支持多receiver参数列表或变长receiver参数。一个方法只能绑定一个基类型，Go语言不支持同时绑定多个类型的方法。</li>
<li>4）receiver参数的基类型本身不能是指针类型或接口类型</li>
</ul>
</li>
<li><p>Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。这种直接以类型名T调用方法的表达方式被称为方法表达式（Method Expression）。类型T只能调用T的方法集合（Method Set）中的方法，同理，<code>*T只能调用*T</code>的方法集合中的方法。</p>
</li>
<li><p>receiver类型选用的初步结论。如果要对类型实例进行修改，那么为receiver选择<code>*T</code>类型。如果没有对类型实例修改的需求，那么为receiver选择T类型或<em>T类型均可；但考虑到Go方法调用时，receiver是以值复制的形式传入方法中的，如果类型的size较大，以值形式传入会导致较大损耗，这时选择</em>T作为receiver类型会更好些。关于receiver类型的选择其实还有一个重要因素，那就是类型是否要实现某个接口</p>
</li>
</ul>
<p><strong>小结：</strong>Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。Go语法糖使得我们在通过类型实例调用类型方法时无须考虑实例类型与receiver参数类型是否一致，编译器会为我们做自动转换。在选择receiver参数类型时要看是否要对类型实例进行修改。如有修改需求，则选择*T；如无修改需求，T类型receiver传值的性能损耗也是考量因素之一。</p>
<h1 id="第24条-方法集合决定接口实现"><a href="#第24条-方法集合决定接口实现" class="headerlink" title="第24条　方法集合决定接口实现"></a>第24条　方法集合决定接口实现</h1><h4 id="24-1-方法集合"><a href="#24-1-方法集合" class="headerlink" title="24.1 方法集合"></a>24.1 方法集合</h4><ul>
<li><p>自定义类型与接口之间的实现关系是松耦合的：如果某个自定义类型T的方法集合是某个接口类型的方法集合的超集，那么就说类型T实现了该接口，并且类型T的变量可以被赋值给该接口类型的变量，即我们说的方法集合决定接口实现。</p>
</li>
<li><p><strong>对于非接口类型的自定义类型T，其方法集合由所有receiver为T类型的方法组成；而类型<code>*T</code>的方法集合则包含所有receiver为T和<code>*T</code>类型的方法。也正因为如此，pt才能成功赋值给Interface类型变量。</strong></p>
</li>
<li><p>与接口类型和结构体类型相关的类型嵌入有三种组合：<strong>在接口类型中嵌入接口类型、在结构体类型中嵌入接口类型及在结构体类型中嵌入结构体类型。</strong></p>
</li>
<li><p>嵌入了其他接口类型的结构体类型的实例在调用方法时，Go选择方法的次序。1）优先选择结构体自身实现的方法。2）如果结构体自身并未实现，那么将查找结构体中的嵌入接口类型的方法集合中是否有该方法，如果有，则提升（promoted）为结构体的方法。</p>
</li>
<li><p>如果结构体嵌入了多个接口类型且这些接口类型的方法集合存在交集，那么Go编译器将报错，除非结构体自己实现了交集中的所有方法。</p>
</li>
<li><p>结构体类型在嵌入某接口类型的同时，也实现了这个接口。</p>
</li>
<li><p>外部的结构体类型T可以“继承”嵌入的结构体类型的所有方法的实现，并且无论是T类型的变量实例还是*T类型变量实例，都可以调用所有“继承”的方法。</p>
</li>
<li><p>T类型的方法集合 = T1的方法集合 + <code>*T2</code>的方法集合；<code>*T</code>类型的方法集合 = <code>*T1</code>的方法集合 + <code>*T2</code>的方法集合。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// chapter4/sources/method_set_10.go</span><br><span class="line"></span><br><span class="line">type T1 struct{}</span><br><span class="line"></span><br><span class="line">func (T1) T1M1()   { println("T1's M1") }</span><br><span class="line">func (T1) T1M2()   { println("T1's M2") }</span><br><span class="line">func (*T1) PT1M3() { println("PT1's M3") }</span><br><span class="line"></span><br><span class="line">type T2 struct{}</span><br><span class="line"></span><br><span class="line">func (T2) T2M1()   { println("T2's M1") }</span><br><span class="line">func (T2) T2M2()   { println("T2's M2") }</span><br><span class="line">func (*T2) PT2M3() { println("PT2's M3") }</span><br><span class="line"></span><br><span class="line">type T struct {</span><br><span class="line">    T1</span><br><span class="line">    *T2</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>已有的类型（比如上面的I、T）被称为underlying类型，而新类型被称为defined类型，而基于自定义非接口类型创建的defined类型则并没有“继承”原类型的方法集合，新的defined类型的方法集合是空的。</li>
<li><strong>类型别名与原类型拥有完全相同的方法集合，无论原类型是接口类型还是非接口类型。</strong></li>
</ul>
<p><strong>小结：</strong>方法集合是类型与接口间隐式关系的纽带，只有当类型的方法集合是某接口类型的超集时，我们才说该类型实现了某接口；类型T的方法集合是以T为receiver类型的所有方法的集合，类型<code>*T</code>的方法集合是以<code>*T</code>为receiver类型的所有方法的集合与类型T的方法集合的并集；了解类型嵌入对接口类型和自定义结构体类型的方法集合的影响；基于接口类型创建的defined类型与原类型具有相同的方法集合，而基于自定义非接口类型创建的defined类型的方法集合为空；类型别名与原类型拥有完全相同的方法集合。</p>
<h1 id="第25条-了解变长参数函数的妙用"><a href="#第25条-了解变长参数函数的妙用" class="headerlink" title="第25条　了解变长参数函数的妙用"></a>第25条　了解变长参数函数的妙用</h1><ul>
<li><code>... interface{}</code>。这种接受“…T”类型形式参数的函数就被称为变长参数函数。</li>
<li>一个变长参数函数只能有一个“…T”类型形式参数，并且该形式参数应该为函数参数列表中的最后一个形式参数</li>
<li>虽然string类型变量可以直接赋值给interface{}类型变量，但是[]string类型变量并不能直接赋值给[]interface{}类型变量。</li>
</ul>
<h4 id="25-2-模拟函数重载"><a href="#25-2-模拟函数重载" class="headerlink" title="25.2 模拟函数重载"></a>25.2 模拟函数重载</h4><p>Go语言不允许在同一个作用域下定义名字相同但函数原型不同的函数，如果定义这样的函数</p>
<p>如果要重载的函数的参数都是相同类型的，仅参数的个数是变化的，那么变长参数函数可以轻松对应；如果参数类型不同且个数可变，那么我们还要结合interface{}类型的特性。我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// chapter4/sources/variadic_function_5.go</span><br><span class="line"></span><br><span class="line">func concat(sep string, args ...interface{}) string {</span><br><span class="line">    var result string</span><br><span class="line">    for i, v := range args {</span><br><span class="line">        if i != 0 {</span><br><span class="line">            result += sep</span><br><span class="line">        }</span><br><span class="line">        switch v.(type) {</span><br><span class="line">        case int, int8, int16, int32, int64,</span><br><span class="line">            uint, uint8, uint16, uint32, uint64:</span><br><span class="line">            result += fmt.Sprintf("%d", v)</span><br><span class="line">        case string:</span><br><span class="line">            result += fmt.Sprintf("%s", v)</span><br><span class="line">        case []int:</span><br><span class="line">            ints := v.([]int)</span><br><span class="line">            for i, v := range ints {</span><br><span class="line">                if i != 0 {</span><br><span class="line">                    result += sep</span><br><span class="line">                }</span><br><span class="line">                result += fmt.Sprintf("%d", v)</span><br><span class="line">            }</span><br><span class="line">        case []string:</span><br><span class="line">            strs := v.([]string)</span><br><span class="line">            result += strings.Join(strs, sep)</span><br><span class="line">        default:</span><br><span class="line">            fmt.Printf("the argument type [%T] is not supported", v)</span><br><span class="line">            return ""</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    return result</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">    println(concat("-", 1, 2))</span><br><span class="line">    println(concat("-", "hello", "gopher"))</span><br><span class="line">    println(concat("-", "hello", 1, uint32(2),</span><br><span class="line">        []int{11, 12, 13}, 17,</span><br><span class="line">        []string{"robot", "ai", "ml"},</span><br><span class="line">        "hacker", 33))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="25-3-模拟实现函数的可选参数与默认参数"><a href="#25-3-模拟实现函数的可选参数与默认参数" class="headerlink" title="25.3 模拟实现函数的可选参数与默认参数"></a>25.3 模拟实现函数的可选参数与默认参数</h4><p>如果参数在传入时有隐式要求的固定顺序（这点由调用者保证），我们还可以利用变长参数函数模拟实现函数的可选参数和默认参数。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter4/sources/variadic_function_6.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> record <span class="keyword">struct</span> {</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    gender  <span class="type">string</span></span><br><span class="line">    age     <span class="type">uint16</span></span><br><span class="line">    city    <span class="type">string</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enroll</span><span class="params">(args ...<span class="keyword">interface</span>{} /* name, gender, age, city = "Beijing", country = "China" */)</span></span> (*record, <span class="type">error</span>) {</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">5</span> || <span class="built_in">len</span>(args) &lt; <span class="number">3</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"the number of arguments passed is wrong"</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    r := &amp;record{</span><br><span class="line">        city:    <span class="string">"Beijing"</span>, <span class="comment">// 默认值：Beijing</span></span><br><span class="line">        country: <span class="string">"China"</span>,   <span class="comment">// 默认值：China</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> args {</span><br><span class="line">        <span class="keyword">switch</span> i {</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// name</span></span><br><span class="line">            name, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"name is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.name = name</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// gender</span></span><br><span class="line">            gender, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"gender is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.gender = gender</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// age</span></span><br><span class="line">            age, ok := v.(<span class="type">int</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"age is not passed as int"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.age = <span class="type">uint16</span>(age)</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// city</span></span><br><span class="line">            city, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"city is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.city = city</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// country</span></span><br><span class="line">            country, ok := v.(<span class="type">string</span>)</span><br><span class="line">            <span class="keyword">if</span> !ok {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"country is not passed as string"</span>)</span><br><span class="line">            }</span><br><span class="line">            r.country = country</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unknown argument passed"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    r, _ := enroll(<span class="string">"小明"</span>, <span class="string">"male"</span>, <span class="number">23</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, _ = enroll(<span class="string">"小红"</span>, <span class="string">"female"</span>, <span class="number">13</span>, <span class="string">"Hangzhou"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, _ = enroll(<span class="string">"Leo Messi"</span>, <span class="string">"male"</span>, <span class="number">33</span>, <span class="string">"Barcelona"</span>, <span class="string">"Spain"</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, *r)</span><br><span class="line"></span><br><span class="line">    r, err := enroll(<span class="string">"小吴"</span>, <span class="number">21</span>, <span class="string">"Suzhou"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> {</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="25-4-实现功能选项模式"><a href="#25-4-实现功能选项模式" class="headerlink" title="25.4 实现功能选项模式"></a>25.4 实现功能选项模式</h4><p>在设计和实现类似NewFinishedHouse这样带有配置选项的函数或方法时，功能选项模式让我们可以收获如下好处：更漂亮的、不随时间变化的公共API；参数可读性更好；配置选项高度可扩展；提供使用默认选项的最简单方式；使用更安全。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter4/sources/variadic_function_9.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FinishedHouse <span class="keyword">struct</span> {</span><br><span class="line">    style                  <span class="type">int</span>    <span class="comment">// 0: Chinese; 1: American; 2: European</span></span><br><span class="line">    centralAirConditioning <span class="type">bool</span>   <span class="comment">// true或false</span></span><br><span class="line">    floorMaterial          <span class="type">string</span>  <span class="comment">// "ground-tile"或"wood"</span></span><br><span class="line">    wallMaterial           <span class="type">string</span> <span class="comment">// "latex"或"paper"或"diatom-mud"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*FinishedHouse)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFinishedHouse</span><span class="params">(options ...Option)</span></span> *FinishedHouse {</span><br><span class="line">    h := &amp;FinishedHouse{</span><br><span class="line">        <span class="comment">// default options</span></span><br><span class="line">        style:                  <span class="number">0</span>,</span><br><span class="line">        centralAirConditioning: <span class="literal">true</span>,</span><br><span class="line">        floorMaterial:          <span class="string">"wood"</span>,</span><br><span class="line">        wallMaterial:           <span class="string">"paper"</span>,</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, option := <span class="keyword">range</span> options {</span><br><span class="line">        option(h)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStyle</span><span class="params">(style <span class="type">int</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.style = style</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithFloorMaterial</span><span class="params">(material <span class="type">string</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.floorMaterial = material</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithWallMaterial</span><span class="params">(material <span class="type">string</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.wallMaterial = material</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCentralAirConditioning</span><span class="params">(centralAirConditioning <span class="type">bool</span>)</span></span> Option {</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(h *FinishedHouse)</span></span> {</span><br><span class="line">        h.centralAirConditioning = centralAirConditioning</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, NewFinishedHouse()) <span class="comment">// 使用默认选项</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, NewFinishedHouse(WithStyle(<span class="number">1</span>),</span><br><span class="line">        WithFloorMaterial(<span class="string">"ground-tile"</span>),</span><br><span class="line">        WithCentralAirConditioning(<span class="literal">false</span>)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h3 id="第26条-了解接口类型变量的内部表示"><a href="#第26条-了解接口类型变量的内部表示" class="headerlink" title="第26条 了解接口类型变量的内部表示"></a>第26条 了解接口类型变量的内部表示</h3><p>接口是Go这门静态类型语言中唯一“动静兼备”的语言特性。接口的静态特性 接口类型变量具有静态类型，比如：var e error中变量e的静态类型为error。支持在编译阶段的类型检查：当一个接口类型变量被赋值时，编译器会检查右值的类型是否实现了该接口方法集合中的所有方法。接口的动态特性 接口类型变量兼具动态类型，即在运行时存储在接口类型变量中的值的真实类型。比如：var i interface{} = 13中接口变量i的动态类型为int。接口类型变量在程序运行时可以被赋值为不同的动态类型变量，从而支持运行时多态。</p>
<ul>
<li>nil error值!= nil</li>
</ul>
<h4 id="26-2-接口类型变量的内部表示"><a href="#26-2-接口类型变量的内部表示" class="headerlink" title="26.2 接口类型变量的内部表示"></a>26.2 接口类型变量的内部表示</h4><p>eface：用于表示没有方法的空接口（empty interface）类型变量，即interface{}类型的变量。iface：用于表示其余拥有方法的接口（interface）类型变量。</p>
<p>Go运行时会为程序内的全部类型建立只读的共享_type信息表，因此拥有相同动态类型的同类接口类型变量的_type/tab信息是相同的。而接口类型变量的data部分则指向一个动态分配的内存空间，该内存空间存储的是赋值给接口类型变量的动态类型变量的值。未显式初始化的接口类型变量的值为nil，即该变量的_type/tab和data都为nil。这样，我们要判断两个接口类型变量是否相同，只需判断_type/tab是否相同以及data指针所指向的内存空间所存储的数据值是否相同（注意：不是data指针的值）。</p>
<p>无论是空接口类型变量还是非空接口类型变量，一旦变量值为nil，那么它们内部表示均为(0x0,0x0)，即类型信息和数据信息均为空。</p>
<p>对于空接口类型变量，只有在_type和data所指数据内容一致（注意：不是数据指针的值一致）的情况下，两个空接口类型变量之间才能画等号。</p>
<p>从returnsError返回的error接口类型变量e的数据指针虽然为空，但其类型信息（iface.tab）并不为空（而是*MyError对应的类型信息），因此与nil(0x0,0x0)自然不相等，这就是那个问题的答案。</p>
<p>空接口类型变量和非空接口类型变量内部表示的结构有所不同（第一个字段：_type vs. tab），似乎一定不能相等。但Go在进行等值比较时，类型比较使用的是eface的_type和iface的tab._type，因此就像我们在这个例子中看到的那样，当eif和err都被赋值为T(5)时，两者之间是可以画等号的。</p>
<h4 id="26-4-接口类型的装箱原理"><a href="#26-4-接口类型的装箱原理" class="headerlink" title="26.4 接口类型的装箱原理"></a>26.4 接口类型的装箱原理</h4><ul>
<li><strong>装箱（boxing）是编程语言领域的一个基础概念，一般是指把值类型转换成引用类型。</strong></li>
<li>在Go语言中，将任意类型赋值给一个接口类型变量都是装箱操作。接口类型的装箱实则就是创建一个eface或iface的过程。</li>
<li>接口类型变量在运行时表示为eface和iface，eface用于表示空接口类型变量，iface用于表示非空接口类型变量；当且仅当两个接口类型变量的类型信息（eface._type/iface.tab._type）相同，且数据指针（eface.data/iface.data）所指数据相同时，两个接口类型才是相等的；通过println可以输出接口类型变量的两部分指针变量的值；可通过复制runtime包eface和iface相关类型源码，自定义输出eface/iface详尽信息的函数；接口类型变量的装箱操作由Go编译器和运行时共同完成。</li>
</ul>
<h3 id="第27条-尽量定义小接口"><a href="#第27条-尽量定义小接口" class="headerlink" title="第27条 尽量定义小接口"></a>第27条 尽量定义小接口</h3><ul>
<li><p>接口越大，抽象程度越低。</p>
</li>
<li><p>小契约：契约繁了便束缚了手脚，降低了灵活性，抑制了表现力。Go选择使用小契约，表现在代码上便是尽量定义小接口。</p>
</li>
<li><p>小接口的优势</p>
<ol>
<li><p>接口越小，抽象程度越高，被接纳度越高</p>
</li>
<li><p>易于实现和测试</p>
</li>
<li><p>契约职责单一，易于复用组合</p>
</li>
</ol>
</li>
</ul>
<h4 id="27-3-定义小接口可以遵循的一些点"><a href="#27-3-定义小接口可以遵循的一些点" class="headerlink" title="27.3 定义小接口可以遵循的一些点"></a>27.3 定义小接口可以遵循的一些点</h4><ul>
<li><p>初期不要在意接口的大小，因为对问题域的理解是循序渐进的，期望在第一版代码中直接定义出小接口可能并不现实。</p>
</li>
<li><p>有了接口后，我们就会看到接口被用在代码的各个地方。一段时间后，我们来分析哪些场合使用了接口的哪些方法，是否可以将这些场合使用的接口的方法提取出来放入一个新的小接口中</p>
</li>
<li><p>接口是将对象的行为进行抽象而形成的契约；<strong>Go青睐定义小接口，即方法数量为1～3个、通常为1个的接口</strong>（这种最佳实践被Go社区项目广泛采纳）；小接口抽象程度高，被接纳度高，易于实现和测试，易于复用组合；先抽象出接口，再拆分为小接口，另外接口的契约职责应尽可能保持单一。</p>
</li>
</ul>
<h3 id="第28条-尽量避免使用空接口作为函数参数类型"><a href="#第28条-尽量避免使用空接口作为函数参数类型" class="headerlink" title="第28条 尽量避免使用空接口作为函数参数类型"></a>第28条 尽量避免使用空接口作为函数参数类型</h3><ul>
<li><p>在函数或方法参数中使用空接口类型，意味着你没有为编译器提供关于传入实参数据的任何信息，因此，你将失去静态类型语言类型安全检查的保护屏障，你需要自己检查类似的错误，并且直到运行时才能发现此类错误。</p>
</li>
<li><p><strong>尽量不要使用可以逃过编译器类型安全检查的空接口类型（interface{}）</strong>。</p>
</li>
<li><p>仅在处理未知类型数据时使用空接口类型；在其他情况下，尽可能将你需要的行为抽象成带有方法的接口，并使用这样的非空接口类型作为函数或方法的参数。</p>
</li>
</ul>
<h1 id="第29条-使用接口作为程序水平组合的连接点"><a href="#第29条-使用接口作为程序水平组合的连接点" class="headerlink" title="第29条　使用接口作为程序水平组合的连接点"></a>第29条　使用接口作为程序水平组合的连接点</h1><p>Go语言无类型体系（type hierarchy），类型定义正交独立；方法和类型是正交的，每种类型都可以拥有自己的方法集合；接口与其实现者之间无显式关联。正交性为“组合”哲学的落地提供了前提，而组合就像本条开头引用的Rob Pike的观点那样，是Go程序内各组件间的主要耦合方式，也是搭建Go程序静态结构的主要方式。</p>
<ul>
<li><p>Go语言中主要有两种组合方式。垂直组合（类型组合）：Go语言主要通过类型嵌入机制实现垂直组合，进而实现方法实现的复用、接口定义重用等。水平组合：通常Go程序以接口类型变量作为程序水平组合的连接点。接口是水平组合的关键，它就好比程序肌体上的关节，给予连接关节的两个部分或多个部分各自自由活动的能力，而整体又实现了某种功能。</p>
</li>
<li><p>Go语言通过类型嵌入实现垂直组合。组合方式莫过于以下3种。</p>
<ul>
<li>（1）通过嵌入接口构建接口</li>
<li>（2）通过嵌入接口构建结构体</li>
<li>（3）通过嵌入结构体构建新结构体</li>
</ul>
</li>
<li><p>水平组合的基本形式是接受接口类型参数的函数或方法</p>
</li>
<li><p>函数/方法参数中的接口类型作为连接点，将位于多个包中的多个类型“编织”到一起，共同形成一幅程序“骨架”。同时接口类型与其实现者之间隐式的关系在不经意间满足了依赖抽象、里氏替换原则、接口隔离等代码设计原则，这在其他语言中是需要刻意设计和谋划的，但对Go接口来看，这一切却是自然而然的。</p>
</li>
<li><p>包裹函数（wrapper function）的形式是这样的：它接受接口类型参数，并返回与其参数类型相同的返回值。通过包裹函数可以实现对输入数据的过滤、装饰、变换等操作，并将结果再次返回给调用者。由于包裹函数的返回值类型与参数类型相同，因此我们可以将多个接受同一接口类型参数的包裹函数组合成一条链来调用</p>
</li>
<li><p>适配器函数类型（adapter function type）是一个辅助水平组合实现的“工具”类型。强调一下，它是一个类型。它可以将一个满足特定函数签名的普通函数显式转换成自身类型的实例，转换后的实例同时也是某个单方法接口类型的实现者。</p>
</li>
<li><p>“中间件”（middleware）这个词的含义可大可小，在Go Web编程中，它常常指的是一个实现了http.Handler接口的http.HandlerFunc类型实例。实质上，这里的中间件就是包裹函数和适配器函数类型结合的产物。</p>
</li>
</ul>
<h3 id="第30条-使用接口提高代码的可测试性"><a href="#第30条-使用接口提高代码的可测试性" class="headerlink" title="第30条 使用接口提高代码的可测试性"></a>第30条 使用接口提高代码的可测试性</h3><p><strong>Go语言有一个惯例是让单元测试代码时刻伴随着你编写的Go代码。</strong></p>
<ul>
<li>使用接口来降低耦合，接口本是契约，天然具有降低耦合的作用。</li>
<li>代码的可测试性已经成为判定Go代码是否优秀的一条重要标准。适当抽取接口，让接口成为好代码与单元测试之间的桥梁是Go语言的一种最佳实践。</li>
<li>并行方案就是在处理器核数充足的情况下启动多个单线程应用的实例，这样每个实例“运行”在一个核上（如图中的CPU核1～CPU核N），尽可能多地利用多核计算资源。</li>
<li>简单来说，并发就是重新做应用结构设计，即将应用分解成多个在基本执行单元（图中这样的执行单元为操作系统线程）中执行的、可能有一定关联关系的代码片段（图中的模块1～模块N）。</li>
</ul>
<h1 id="第31条-优先考虑并发设计"><a href="#第31条-优先考虑并发设计" class="headerlink" title="第31条　优先考虑并发设计"></a>第31条　优先考虑并发设计</h1><ul>
<li><strong>goroutine相比传统操作系统线程而言具有如下优势。</strong>1）资源占用小，每个goroutine的初始栈大小仅为2KB。[插图]2）由Go运行时而不是操作系统调度，goroutine上下文切换代价较小。3）语言原生支持：goroutine由go关键字接函数或方法创建，函数或方法返回即表示goroutine退出，开发体验更佳。4）语言内置channel作为goroutine间通信原语，为并发设计提供强大支撑。</li>
</ul>
<h1 id="第32条-了解goroutine的调度原理"><a href="#第32条-了解goroutine的调度原理" class="headerlink" title="第32条　了解goroutine的调度原理"></a>第32条　了解goroutine的调度原理</h1><p>直接看书。有GMP模型。</p>
<h3 id="第33条-掌握Go并发模型和常见并发模式（重要）"><a href="#第33条-掌握Go并发模型和常见并发模式（重要）" class="headerlink" title="第33条 掌握Go并发模型和常见并发模式（重要）"></a>第33条 掌握Go并发模型和常见并发模式（重要）</h3><ul>
<li><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p>
</li>
<li><p>Go始终推荐以CSP模型风格构建并发程序。</p>
</li>
<li><p>在内部创建一个goroutine并返回一个channel类型变量的函数，这是Go中最常见的goroutine创建模式</p>
</li>
<li><p>goroutine的使用代价很低，<strong>Go官方推荐多使用goroutine。</strong>在多数情况下，我们无须考虑对goroutine的退出进行控制：goroutine的执行函数返回，即意味着goroutine退出。</p>
</li>
<li><p>分类说明一下goroutine的几种退出模式：</p>
<ul>
<li>（1）分离模式，对于分离的goroutine，创建它的goroutine不需要关心它的退出，这类goroutine在启动后即与其创建者彻底分离，其生命周期与其执行的主函数相关，函数返回即goroutine退出。这类goroutine有两个常见用途。<ul>
<li>1）一次性任务：顾名思义，新创建的goroutine用来执行一个简单的任务，执行后即退出。</li>
<li>2）常驻后台执行一些特定任务，如监视（monitor）、观察（watch）等。其实现通常采用for {…}或for { select{…} }代码段形式，并多以定时器（timer）或事件（event）驱动执行。</li>
</ul>
</li>
<li>（2）join模式，goroutine的创建者需要等待新goroutine结束。笔者为这样的goroutine退出模式起名为“join模式”。<ul>
<li>① 等待一个goroutine退出</li>
<li>② 获取goroutine的退出状态</li>
<li>③ 等待多个goroutine退出</li>
</ul>
</li>
<li>（3）notify-and-wait模式<ul>
<li>① 通知并等待一个goroutine退出</li>
<li>② 通知并等待多个goroutine退出</li>
</ul>
</li>
<li>（4）退出模式的应用<ul>
<li>一组goroutine的退出总体上有两种情况。一种是并发退出，在这类退出方式下，各个goroutine的退出先后次序对数据处理无影响，因此各个goroutine可以并发执行退出逻辑；另一种则是串行退出，即各个goroutine之间的退出是按照一定次序逐个进行的，次序若错了可能会导致程序的状态混乱和错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>Go语言的channel有一个特性是，当使用close函数关闭channel时，所有阻塞到该channel上的goroutine都会得到通知。</p>
</li>
<li><p>一组goroutine的退出总体上有两种情况。一种是并发退出，在这类退出方式下，各个goroutine的退出先后次序对数据处理无影响，因此各个goroutine可以并发执行退出逻辑；另一种则是串行退出，即各个goroutine之间的退出是按照一定次序逐个进行的，次序若错了可能会导致程序的状态混乱和错误。</p>
</li>
<li><p>下面来了解两种基于管道模式的扩展模式。</p>
<ul>
<li>（1）扇出模式在某个处理环节，多个功能相同的goroutine从同一个channel读取数据并处理，直到该channel关闭，这种情况被称为“扇出”（fan-out）。使用扇出模式可以在一组goroutine中均衡分配工作量，从而更均衡地利用CPU。</li>
<li>（2）扇入模式在某个处理环节，处理程序面对不止一个输入channel。我们把所有输入channel的数据汇聚到一个统一的输入channel，然后处理程序再从这个channel中读取数据并处理，直到该channel因所有输入channel关闭而关闭。这种情况被称为“扇入”（fan-in）。</li>
<li>下面示例包含扇入扇出两种模式：</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// chapter6/sources/go-concurrency-pattern-9.go </span><br><span class="line">func newNumGenerator(start, count int) &lt;-chan int {</span><br><span class="line">    c := make(chan int)</span><br><span class="line">    go func() {</span><br><span class="line">        for i := start; i &lt; start+count; i++ {</span><br><span class="line">            c &lt;- i</span><br><span class="line">        }</span><br><span class="line">        close(c)</span><br><span class="line">    }()</span><br><span class="line">    return c</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func filterOdd(in int) (int, bool) {</span><br><span class="line">    if in%2 != 0 {</span><br><span class="line">        return 0, false</span><br><span class="line">    }</span><br><span class="line">    return in, true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func square(in int) (int, bool) {</span><br><span class="line">    return in * in, true</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func spawnGroup(name string, num int, f func(int) (int, bool), in &lt;-chan int) &lt;-chan int {</span><br><span class="line">    groupOut := make(chan int)</span><br><span class="line">    var outSlice []chan int</span><br><span class="line">    for i := 0; i &lt; num; i++ {</span><br><span class="line">        out := make(chan int)</span><br><span class="line">        go func(i int) {</span><br><span class="line">            name := fmt.Sprintf("%s-%d:", name, i)</span><br><span class="line">            fmt.Printf("%s begin to work...\n", name)</span><br><span class="line">            </span><br><span class="line">            for v := range in {</span><br><span class="line">                r, ok := f(v)</span><br><span class="line">                if ok {</span><br><span class="line">                    out &lt;- r</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            close(out)</span><br><span class="line">            fmt.Printf("%s work done\n", name)</span><br><span class="line">        }(i)</span><br><span class="line">        outSlice = append(outSlice, out)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    // 扇入模式</span><br><span class="line">    //</span><br><span class="line">    // out --\</span><br><span class="line">    //        \</span><br><span class="line">    // out ---- --&gt; groupOut</span><br><span class="line">    //        /</span><br><span class="line">    // out --/</span><br><span class="line">    //</span><br><span class="line">    go func() {</span><br><span class="line">        var wg sync.WaitGroup</span><br><span class="line">        for _, out := range outSlice {</span><br><span class="line">            wg.Add(1)</span><br><span class="line">            go func(out &lt;-chan int) {</span><br><span class="line">                for v := range out {</span><br><span class="line">                        groupOut &lt;- v</span><br><span class="line">                }</span><br><span class="line">                wg.Done()</span><br><span class="line">            }(out)</span><br><span class="line">        }</span><br><span class="line">        wg.Wait()</span><br><span class="line">        close(groupOut)</span><br><span class="line">    }()</span><br><span class="line">    </span><br><span class="line">    return groupOut</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">func main() {</span><br><span class="line">      in := newNumGenerator(1, 20)</span><br><span class="line">      out := spawnGroup("square", 2, square, spawnGroup("filterOdd", 3, filterOdd, in))</span><br><span class="line"></span><br><span class="line">      time.Sleep(3 * time.Second) //为了输出更直观的结果，这里等上面的goroutine都就绪</span><br><span class="line"></span><br><span class="line">      for v := range out {</span><br><span class="line">          fmt.Println(v)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="第34条-了解channel的妙用"><a href="#第34条-了解channel的妙用" class="headerlink" title="第34条 了解channel的妙用"></a>第34条 了解channel的妙用</h3><p><strong>channel类型在Go中为“一等公民”，</strong>我们可以像使用普通变量那样使用channel，比如：定义channel类型变量，为channel变量赋值，将channel作为参数传递给函数/方法，将channel作为返回值从函数/方法中返回，甚至将channel发送到其他channel中。</p>
<ul>
<li><p>对于无缓冲channel而言，我们得到以下结论：发送动作一定发生在接收动作完成之前；接收动作一定发生在发送动作完成之前。</p>
<ul>
<li>用作信号传递<ul>
<li>（1）一对一通知信号</li>
<li>（2）一对多通知信号</li>
</ul>
</li>
<li>用于替代锁机制</li>
</ul>
</li>
<li><p>对带缓冲channel的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是异步的（发送或接收无须阻塞等待）。</p>
<ul>
<li>用作消息队列,无论是单收单发还是多收多发，带缓冲channel的收发性能都要好于无缓冲channel的；对于带缓冲channel而言，选择适当容量会在一定程度上提升收发性能。</li>
<li>用作计数信号量</li>
</ul>
</li>
<li><p>Go并发设计的一个惯用法是将带缓冲channel用作计数信号量（counting semaphore）。带缓冲channel中的当前数据个数代表的是当前同时处于活动状态（处理业务）的goroutine的数量，而带缓冲channel的容量（capacity）代表允许同时处于活动状态的goroutine的最大数量。一个发往带缓冲channel的发送操作表示获取一个信号量槽位，而一个来自带缓冲channel的接收操作则表示释放一个信号量槽位。</p>
</li>
<li><p>len是Go语言原生内置的函数，它可以接受数组、切片、map、字符串或channel类型的参数，并返回对应类型的“长度”——一个整型值。以len(s)为例：如果s是字符串（string）类型，len(s)返回字符串中的字节数；如何s是[n]T或*[n]T的数组类型，len(s)返回数组的长度n；如果s是[]T的切片（slice）类型，len(s)返回切片的当前长度；如果s是map[K]T的map类型，len(s)返回map中已定义的key的个数；如果s是chan T类型，那么len(s)针对channel的类型不同，有如下两种语义：当s为无缓冲channel时，len(s)总是返回0；当s为带缓冲channel时，len(s)返回当前channel s中尚未被读取的元素个数。这样一来，针对带缓冲channel的len调用才是有意义的。</p>
</li>
<li><p>单纯依靠len(channel)来判断channel中元素的状态，不能保证在后续对channel进行收发时channel的状态不变。</p>
</li>
<li><p>为了不阻塞在channel上，常见的方法是将判空与读取放在一个事务中，将判满与写入放在一个事务中，而这类事务我们可以通过select实现。</p>
</li>
<li><p>a是一个多发送单接收的场景，即有多个发送者，但有且只有一个接收者。在这样的场景下，我们可以在接收者goroutine中根据len(channel)是否大于0来判断channel中是否有数据需要接收。</p>
</li>
<li><p>b是一个多接收单发送的场景，即有多个接收者，但有且只有一个发送者。在这样的场景下，我们可以在发送goroutine中根据len(channel)是否小于cap(channel)来判断是否可以执行向channel的发送操作。</p>
</li>
</ul>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_60" alt="img"></p>
<ul>
<li>34.3 nil channel的妙用：<strong>对没有初始化的channel（nil channel）进行读写操作将会发生阻塞</strong>，在判断c1或c2被关闭后，显式地将c1或c2置为nil。我们知道，对一个nil channel执行获取操作，该操作将被阻塞</li>
<li>channel与select结合使用的一些惯用法<ul>
<li>利用default分支避免阻塞</li>
<li>实现超时机制</li>
<li>实现心跳机制</li>
</ul>
</li>
</ul>
<h1 id="第35条-了解sync包的正确用法"><a href="#第35条-了解sync包的正确用法" class="headerlink" title="第35条　了解sync包的正确用法"></a>第35条　了解sync包的正确用法</h1><ul>
<li><p>在下面一些场景下，我们依然需要sync包提供的低级同步原语。</p>
<ul>
<li>（1）需要高性能的临界区同步机制场景</li>
<li>（2）不想转移结构体对象所有权，但又要保证结构体内部状态数据的同步访问的场景</li>
</ul>
</li>
<li><p>使用sync包的注意事项：那些sync包中类型的实例在首次使用后被复制得到的副本一旦再被使用将导致不可预期的结果，为此在使用sync包中类型时，推荐通过闭包方式或传递类型实例（或包裹该类型的类型实例）的地址或指针的方式进行，这是使用sync包最值得注意的事项。</p>
</li>
<li><p>读写锁还是互斥锁：在并发量较小的情况下，互斥锁性能更好；随着并发量增大，互斥锁的竞争激烈，导致加锁和解锁性能下降。读写锁的读锁性能并未随并发量的增大而发生较大变化，性能始终恒定在40ns左右。在并发量较大的情况下，读写锁的写锁性能比互斥锁、读写锁的读锁都差，并且随着并发量增大，其写锁性能有继续下降的趋势。由此我们可以看出，<strong>读写锁适合应用在具有一定并发量且读多写少的场合。</strong></p>
</li>
<li><p>在Go标准库中，sync.Once的“仅执行一次”语义被一些包用于初始化和资源清理的过程中，以避免重复执行初始化或资源关闭操作。</p>
</li>
</ul>
<h4 id="35-6-使用sync-Pool减轻垃圾回收压力"><a href="#35-6-使用sync-Pool减轻垃圾回收压力" class="headerlink" title="35.6 使用sync.Pool减轻垃圾回收压力"></a>35.6 使用sync.Pool减轻垃圾回收压力</h4><p>sync.Pool是一个数据对象缓存池，它具有如下特点：它是goroutine并发安全的，可以被多个goroutine同时使用；放入该缓存池中的数据对象的生命是暂时的，随时都可能被垃圾回收掉；缓存池中的数据对象是可以重复利用的，这样可以在一定程度上降低数据对象重新分配的频度，减轻GC的压力；sync.Pool为每个P（goroutine调度模型中的P）单独建立一个local缓存池，进一步降低高并发下对锁的争抢。</p>
<p>由于sync.Pool的Get方法从缓存池中挑选bytes.Buffer数据对象时并未考虑该数据对象是否满足调用者的需求，因此一旦返回的Buffer对象是刚刚被“大数据”撑大后的，并且即将被长期用于处理一些“小数据”时，这个Buffer对象所占用的“大内存”将长时间得不到释放。一旦这类情况集中出现，将会给Go应用带来沉重的内存消耗负担，改进措施：（1）限制要放回缓存池中的数据对象大小（2）建立多级缓存池</p>
<h4 id="36-1-atomic包与原子操作"><a href="#36-1-atomic包与原子操作" class="headerlink" title="36.1 atomic包与原子操作"></a>36.1 atomic包与原子操作</h4><ul>
<li><p>原子操作的指令是不可中断的，它就好比一个事务，要么不执行，一旦执行就一次性全部执行完毕，不可分割。</p>
</li>
<li><p>利用原子操作的无锁并发写的性能随着并发量增大几乎保持恒定；利用原子操作的无锁并发读的性能随着并发量增大有持续提升的趋势，并且性能约为读锁的200倍。</p>
</li>
<li><p>atomic通过Value类型的装拆箱操作实现了对任意自定义类型的原子操作（Load和Store），从而实现对共享自定义类型变量无锁读写的支持</p>
</li>
<li><p>atomic包更适合一些对性能十分敏感、并发量较大且读多写少的场合</p>
</li>
</ul>
<h3 id="第37条-了解错误处理的4种策略"><a href="#第37条-了解错误处理的4种策略" class="headerlink" title="第37条 了解错误处理的4种策略"></a>第37条 了解错误处理的4种策略</h3><ul>
<li><p>在标准库中，Go提供了构造错误值的两种基本方法——errors.New和fmt.Errorf</p>
</li>
<li><p>error接口的实现者负责提供错误上下文供负责错误处理的代码使用。这种错误上下文与error接口类型的分离体现了Go设计哲学中的“正交”理念。</p>
</li>
<li><p><strong>透明错误处理策略</strong>：最大限度地减少了错误处理方与错误值构造方之间的耦合关系，它们之间唯一的耦合就是error接口变量所规定的契约。</p>
</li>
<li><p>　<strong>“哨兵”错误处理策略</strong>：Go标准库采用了定义导出的（exported）“哨兵”错误值的方式来辅助错误处理方检视错误值并做出错误处理分支的决策，如果你使用的是Go 1.13及后续版本，请尽量使用errors.Is方法检视某个错误值是不是某个特定的“哨兵”错误值。</p>
</li>
<li><p>错误值类型检视策略：我们需要通过自定义错误类型的构造错误值的方式来提供更多的错误上下文信息，并且由于错误值均通过error接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用Go提供的类型断言机制（type assertion）或类型选择机制（type switch），这种错误处理笔者称之为错误值类型检视策略。我们来看一个标准库中的例子。从Go 1.13版本开始，标准库errors包提供了As方法用于错误处理方对错误值进行检视。As方法类似于通过类型断言判断一个error类型变量是否为特定的自定义错误类型。</p>
</li>
<li><p><strong>错误行为特征检视策略</strong>：将某个包中的错误类型归类，统一提取出一些公共的错误行为特征（behaviour），并将这些错误行为特征放入一个公开的接口类型中。</p>
</li>
</ul>
<p><strong>小结：</strong>尽量使用透明错误处理策略降低错误处理方与错误值构造方之间的耦合；如果可以通过错误值类型的特征进行错误检视，那么尽量使用错误行为特征检视策略；在上述两种策略无法实施的情况下，再用“哨兵”策略和错误值类型检视策略；在Go 1.13及后续版本中，尽量用errors.Is和errors.As方法替换原先的错误检视比较语句。</p>
<h1 id="第38条-尽量优化反复出现的if-err-x3D-nil"><a href="#第38条-尽量优化反复出现的if-err-x3D-nil" class="headerlink" title="第38条　尽量优化反复出现的if err != nil"></a>第38条　尽量优化反复出现的if err != nil</h1><ul>
<li><p>1）改善代码的视觉呈现。</p>
</li>
<li><p>2）降低if err != nil重复的次数。</p>
</li>
<li><p>圈复杂度是一种代码复杂度的衡量标准，我们常用它来衡量一个模块判定结构的复杂程度。圈复杂度高，说明程序代码可能质量低且难于测试和维护。根据经验，程序的可能错误与高的圈复杂度有着很大关系。圈复杂度可以通过程序控制流图计算，公式为V(G) = e + 2 - n。其中：e为控制流图中边的数量；n为控制流图中节点的数量（包括起点和终点；所有终点只计算一次，多个return和throw算作一个节点）。图38-3是不同数量的if语句对应的不同圈复杂度的示意图。<img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_65" alt="img"></p>
</li>
</ul>
<p>掌握错误处理代码优化的四种常见方法（位于三个不同象限中），并根据所处场景与约束灵活使用：</p>
<p><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/epub_42557145_66" alt="img"></p>
<h4 id="39-2-panic的典型应用"><a href="#39-2-panic的典型应用" class="headerlink" title="39.2 panic的典型应用"></a>39.2 panic的典型应用</h4><ul>
<li><p>在Go标准库中，大多数panic是充当类似断言的作用的。</p>
</li>
<li><p>用于简化错误处理控制结构。</p>
</li>
<li><p>使用recover捕获panic，防止goroutine意外退出。</p>
</li>
<li><p><strong>在Go 1.11及以后版本中，Go编译器得到更深入的优化，很多简单的函数或方法会被自动内联（inline）。函数一旦内联化，我们就无法在栈跟踪信息中看到栈帧信息了，栈帧信息都变成了省略号。</strong></p>
</li>
<li><p>深入理解不要使用panic进行正常错误处理的原因。Go标准库中panic的常见使用场景。理解程序发生panic时输出的栈帧信息有助于快速定位bug，找出“元凶”。</p>
</li>
</ul>
<h1 id="其他金句摘抄"><a href="#其他金句摘抄" class="headerlink" title="其他金句摘抄"></a>其他金句摘抄</h1><ul>
<li>语言影响或决定人类的思维方式。不能影响到你的编程思维方式的编程语言不值得学习和使用。</li>
<li>每当你花费大量时间使用某种特定工具时，深入了解它并了解如何高效地使用它是很值得的。</li>
<li>Go的设计哲学之一是偏好组合。</li>
<li>Go语言的设计哲学之一是“原生并发，轻量高效”。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">寻宝游戏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/">http://example.com/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">寻宝游戏</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GoLang/">GoLang</a></div><div class="post_share"><div class="social-share" data-image="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/08/%E3%80%8AGo%E5%9C%A3%E7%BB%8F%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《Go圣经》笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《Go圣经》笔记</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/08/%E3%80%8Ac++Primer%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《c++Primer》笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《c++Primer》笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/01/10/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/" title="Go语言常见库示例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-10</div><div class="title">Go语言常见库示例</div></div></a></div><div><a href="/2024/01/08/%E3%80%8AGo%E5%9C%A3%E7%BB%8F%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《Go圣经》笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-08</div><div class="title">《Go圣经》笔记</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_loading.gif" data-original="https://fansimage-1314135665.cos.ap-nanjing.myqcloud.com/blog_headimg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info__name">寻宝游戏</div><div class="author-info__description">思维的乐趣。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/enternityFan"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Do your own thing...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%88%E7%A5%96"><span class="toc-number">1.</span> <span class="toc-text">2.1 Go语言的先祖</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E6%9D%A1-Go%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number"></span> <span class="toc-text">第3条 Go语言设计哲学</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E6%9D%A1-%E4%BD%BF%E7%94%A8Go%E8%AF%AD%E8%A8%80%E5%8E%9F%E7%94%9F%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4%E6%9D%A5%E5%86%99Go%E4%BB%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">第4条　使用Go语言原生编程思维来写Go代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E6%9D%A1-%E4%BD%BF%E7%94%A8%E5%BE%97%E5%88%B0%E5%85%AC%E8%AE%A4%E4%B8%94%E5%B9%BF%E6%B3%9B%E4%BD%BF%E7%94%A8%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">第5条　使用得到公认且广泛使用的项目结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E6%9D%A1-%E6%8F%90%E4%BA%A4%E5%89%8D%E4%BD%BF%E7%94%A8gofmt%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BA%90%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">第6条　提交前使用gofmt格式化源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E6%9D%A1-%E4%BD%BF%E7%94%A8Go%E5%91%BD%E5%90%8D%E6%83%AF%E4%BE%8B%E5%AF%B9%E6%A0%87%E8%AF%86%E7%AC%A6%E8%BF%9B%E8%A1%8C%E5%91%BD%E5%90%8D"><span class="toc-number"></span> <span class="toc-text">第7条 使用Go命名惯例对标识符进行命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E6%9D%A1-%E4%BD%BF%E7%94%A8%E4%B8%80%E8%87%B4%E7%9A%84%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%BD%A2%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">第8条 使用一致的变量声明形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%8C%85%E7%BA%A7%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">8.1 包级变量的声明形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">8.2 局部变量的声明形式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E6%9D%A1-%E4%BD%BF%E7%94%A8%E6%97%A0%E7%B1%BB%E5%9E%8B%E5%B8%B8%E9%87%8F%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">第9条　使用无类型常量简化代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E6%9D%A1-%E4%BD%BF%E7%94%A8iota%E5%AE%9E%E7%8E%B0%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F"><span class="toc-number"></span> <span class="toc-text">第10条 使用iota实现枚举常量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E6%9D%A1-%E5%B0%BD%E9%87%8F%E5%AE%9A%E4%B9%89%E9%9B%B6%E5%80%BC%E5%8F%AF%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">第11条　尽量定义零值可用的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-%E9%9B%B6%E5%80%BC%E5%8F%AF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">11.2 零值可用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E6%9D%A1-%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E5%80%BC%E4%BD%9C%E4%B8%BA%E5%88%9D%E5%80%BC%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">第12条 使用复合字面值作为初值构造器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E6%9D%A1-%E4%BA%86%E8%A7%A3%E5%88%87%E7%89%87%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%B9%B6%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">第13条 了解切片实现原理并高效使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E6%9D%A1-%E4%BA%86%E8%A7%A3map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%B9%B6%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">第14条　了解map实现原理并高效使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E6%9D%A1-%E4%BA%86%E8%A7%A3string%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%B9%B6%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">第15条　了解string实现原理并高效使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC16%E6%9D%A1-%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%85%E5%AF%BC%E5%85%A5"><span class="toc-number"></span> <span class="toc-text">第16条　理解Go语言的包导入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC17%E6%9D%A1-%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="toc-number"></span> <span class="toc-text">第17条 理解Go语言表达式的求值顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC18%E6%9D%A1-%E7%90%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number"></span> <span class="toc-text">第18条　理解Go语言代码块与作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-Go%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">18.1 Go代码块与作用域简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC19%E6%9D%A1-%E4%BA%86%E8%A7%A3Go%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E6%83%AF%E7%94%A8%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number"></span> <span class="toc-text">第19条　了解Go语言控制语句惯用法及使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#19-2-for-range%E7%9A%84%E9%81%BF%E2%80%9C%E5%9D%91%E2%80%9D%E6%8C%87%E5%8D%97%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">19.2 for range的避“坑”指南（重要）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC20%E6%9D%A1-%E5%9C%A8init%E5%87%BD%E6%95%B0%E4%B8%AD%E6%A3%80%E6%9F%A5%E5%8C%85%E7%BA%A7%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81"><span class="toc-number"></span> <span class="toc-text">第20条　在init函数中检查包级变量的初始状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC21%E6%9D%A1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AF%E4%BA%8E%E5%87%BD%E6%95%B0%E6%98%AF%E2%80%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E2%80%9D"><span class="toc-number"></span> <span class="toc-text">第21条 让自己习惯于函数是“一等公民”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-1-%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E2%80%9D"><span class="toc-number">1.</span> <span class="toc-text">21.1 什么是“一等公民”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-2-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E2%80%9C%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%E2%80%9D%E7%9A%84%E7%89%B9%E6%AE%8A%E8%BF%90%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">21.2 函数作为“一等公民”的特殊运用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC22%E6%9D%A1-%E4%BD%BF%E7%94%A8defer%E8%AE%A9%E5%87%BD%E6%95%B0%E6%9B%B4%E7%AE%80%E6%B4%81%E3%80%81%E6%9B%B4%E5%81%A5%E5%A3%AE"><span class="toc-number"></span> <span class="toc-text">第22条　使用defer让函数更简洁、更健壮</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#22-3-%E5%85%B3%E4%BA%8Edefer%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">22.3 关于defer的几个关键问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC23%E6%9D%A1-%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BB%A5%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84receiver%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">第23条 理解方法的本质以选择正确的receiver类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC24%E6%9D%A1-%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88%E5%86%B3%E5%AE%9A%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number"></span> <span class="toc-text">第24条　方法集合决定接口实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#24-1-%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">24.1 方法集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC25%E6%9D%A1-%E4%BA%86%E8%A7%A3%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">第25条　了解变长参数函数的妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#25-2-%E6%A8%A1%E6%8B%9F%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">25.2 模拟函数重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-3-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E4%B8%8E%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">25.3 模拟实现函数的可选参数与默认参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-4-%E5%AE%9E%E7%8E%B0%E5%8A%9F%E8%83%BD%E9%80%89%E9%A1%B9%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">25.4 实现功能选项模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC26%E6%9D%A1-%E4%BA%86%E8%A7%A3%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number"></span> <span class="toc-text">第26条 了解接口类型变量的内部表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#26-2-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.</span> <span class="toc-text">26.2 接口类型变量的内部表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-4-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A3%85%E7%AE%B1%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">26.4 接口类型的装箱原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC27%E6%9D%A1-%E5%B0%BD%E9%87%8F%E5%AE%9A%E4%B9%89%E5%B0%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number"></span> <span class="toc-text">第27条 尽量定义小接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#27-3-%E5%AE%9A%E4%B9%89%E5%B0%8F%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E9%81%B5%E5%BE%AA%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">27.3 定义小接口可以遵循的一些点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC28%E6%9D%A1-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%A9%BA%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">第28条 尽量避免使用空接口作为函数参数类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC29%E6%9D%A1-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E7%A8%8B%E5%BA%8F%E6%B0%B4%E5%B9%B3%E7%BB%84%E5%90%88%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">第29条　使用接口作为程序水平组合的连接点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC30%E6%9D%A1-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">第30条 使用接口提高代码的可测试性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC31%E6%9D%A1-%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1"><span class="toc-number"></span> <span class="toc-text">第31条　优先考虑并发设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC32%E6%9D%A1-%E4%BA%86%E8%A7%A3goroutine%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">第32条　了解goroutine的调度原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC33%E6%9D%A1-%E6%8E%8C%E6%8F%A1Go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">第33条 掌握Go并发模型和常见并发模式（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC34%E6%9D%A1-%E4%BA%86%E8%A7%A3channel%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">第34条 了解channel的妙用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC35%E6%9D%A1-%E4%BA%86%E8%A7%A3sync%E5%8C%85%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">第35条　了解sync包的正确用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#35-6-%E4%BD%BF%E7%94%A8sync-Pool%E5%87%8F%E8%BD%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%8B%E5%8A%9B"><span class="toc-number">1.</span> <span class="toc-text">35.6 使用sync.Pool减轻垃圾回收压力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-1-atomic%E5%8C%85%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">36.1 atomic包与原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC37%E6%9D%A1-%E4%BA%86%E8%A7%A3%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%9A%844%E7%A7%8D%E7%AD%96%E7%95%A5"><span class="toc-number"></span> <span class="toc-text">第37条 了解错误处理的4种策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC38%E6%9D%A1-%E5%B0%BD%E9%87%8F%E4%BC%98%E5%8C%96%E5%8F%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84if-err-x3D-nil"><span class="toc-number"></span> <span class="toc-text">第38条　尽量优化反复出现的if err != nil</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-2-panic%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">39.2 panic的典型应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%87%91%E5%8F%A5%E6%91%98%E6%8A%84"><span class="toc-number"></span> <span class="toc-text">其他金句摘抄</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/06/%E5%B0%8F%E5%B2%9B%E7%BB%8F%E6%B5%8E%E5%AD%A6%E7%AC%94%E8%AE%B0/" title="小岛经济学笔记">小岛经济学笔记</a><time datetime="2025-04-06T03:14:25.128Z" title="发表于 2025-04-06 11:14:25">2025-04-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/05/%E3%80%8A%E6%B4%BB%E7%9D%80%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/" title="活着读后感">活着读后感</a><time datetime="2025-04-05T07:39:27.443Z" title="发表于 2025-04-05 15:39:27">2025-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" title="左程云算法复习">左程云算法复习</a><time datetime="2024-06-03T12:13:48.000Z" title="发表于 2024-06-03 20:13:48">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/03/%E5%B7%A6%E7%A8%8B%E4%BA%91%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="左程云经典面试题">左程云经典面试题</a><time datetime="2024-06-03T12:13:48.000Z" title="发表于 2024-06-03 20:13:48">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/05/30/%E5%B0%8F%E5%BD%AD%E8%80%81%E5%B8%88%E7%BD%91%E8%AF%BE/" title="小彭老师网课">小彭老师网课</a><time datetime="2024-05-30T12:13:48.000Z" title="发表于 2024-05-30 20:13:48">2024-05-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2020 - 2025 By 寻宝游戏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      id: 'd2f29b8b492249aa1998a9c59bec3c76',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadDisqus () {
  const disqus_config = function () {
    this.page.url = 'http://example.com/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/'
    this.page.identifier = '/2024/01/08/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/'
    this.page.title = '《Go语言精进之路》笔记'
  }

  const disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addModeChange('disqus', disqusReset)

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Gitalk' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="8507814393" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: true,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script><script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>